<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="MYSQL的FULLTEXT索引功能">








  <link rel="alternate" href="/public/default" title="追寻一颗宁静的心">




  <link rel="shortcut icon" type="image/x-icon" href="/public/favicon.ico?v=1.1">



<link rel="canonical" href="http://ningmo.github.io/2013/01/06/MYSQL的FULLTEXT索引功能/">


<meta name="description" content="下文转自某些手册，你可以用这个语句来创建FULLTEXT类型的索引： CREATE FULLTEXT INDEX INDX_TEXT ON ARTICLE (TITLE,NOTE); 到 3.23.23 时，MySQL 开始支持全文索引和搜索。全文索引在 MySQL 中是一个 FULLTEXT 类型索引。FULLTEXT 索引用于 MyISAM 表，可以在 CREATE TABLE 时或之后使用">
<meta property="og:type" content="article">
<meta property="og:title" content="MYSQL的FULLTEXT索引功能">
<meta property="og:url" content="http://ningmo.github.io/2013/01/06/MYSQL的FULLTEXT索引功能/index.html">
<meta property="og:site_name" content="追寻一颗宁静的心">
<meta property="og:description" content="下文转自某些手册，你可以用这个语句来创建FULLTEXT类型的索引： CREATE FULLTEXT INDEX INDX_TEXT ON ARTICLE (TITLE,NOTE); 到 3.23.23 时，MySQL 开始支持全文索引和搜索。全文索引在 MySQL 中是一个 FULLTEXT 类型索引。FULLTEXT 索引用于 MyISAM 表，可以在 CREATE TABLE 时或之后使用">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-08-23T09:24:57.300Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MYSQL的FULLTEXT索引功能">
<meta name="twitter:description" content="下文转自某些手册，你可以用这个语句来创建FULLTEXT类型的索引： CREATE FULLTEXT INDEX INDX_TEXT ON ARTICLE (TITLE,NOTE); 到 3.23.23 时，MySQL 开始支持全文索引和搜索。全文索引在 MySQL 中是一个 FULLTEXT 类型索引。FULLTEXT 索引用于 MyISAM 表，可以在 CREATE TABLE 时或之后使用">


<link rel="stylesheet" type="text/css" href="/public/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> MYSQL的FULLTEXT索引功能 - 追寻一颗宁静的心 </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/public/." class="logo">追寻一颗宁静的心</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/public/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/public/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          MYSQL的FULLTEXT索引功能
        
      </h1>

      <time class="post-time">
          Jan 06 2013
      </time>
    </header>



    
            <div class="post-content">
            <p>下文转自某些手册，你可以用这个语句来创建FULLTEXT类型的索引：</p>
<p>CREATE FULLTEXT INDEX INDX_TEXT ON ARTICLE (TITLE,NOTE);</p>
<p>到 3.23.23 时，MySQL 开始支持全文索引和搜索。全文索引在 MySQL 中是一个 FULLTEXT 类型索引。FULLTEXT 索引用于 MyISAM 表，可以在 CREATE TABLE 时或之后使用 ALTER TABLE 或 CREATE INDEX 在 CHAR、VARCHAR 或 TEXT 列上创建。对于大的数据库，将数据装载到一个没有 FULLTEXT 索引的表中，然后再使用 ALTER TABLE (或 CREATE INDEX) 创建索引，这将是非常快的。将数据装载到一个已经有 FULLTEXT 索引的表中，将是非常慢的。</p>
<p>全文搜索通过 MATCH() 函数完成。</p>
<p>mysql&gt; CREATE TABLE articles (<br>    -&gt;   id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,<br>    -&gt;   title VARCHAR(200),<br>    -&gt;   body TEXT,<br>    -&gt;   FULLTEXT (title,body)<br>    -&gt; );<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; INSERT INTO articles VALUES<br>    -&gt; (NULL,’MySQL Tutorial’, ‘DBMS stands for DataBase …’),<br>    -&gt; (NULL,’How To Use MySQL Efficiently’, ‘After you went through a …’),<br>    -&gt; (NULL,’Optimising MySQL’,’In this tutorial we will show …’),<br>    -&gt; (NULL,’1001 MySQL Tricks’,’1. Never run mysqld as root. 2. …’),<br>    -&gt; (NULL,’MySQL vs. YourSQL’, ‘In the following database comparison …’),<br>    -&gt; (NULL,’MySQL Security’, ‘When configured properly, MySQL …’);<br>Query OK, 6 rows affected (0.00 sec)<br>Records: 6  Duplicates: 0  Warnings: 0</p>
<p>mysql&gt; SELECT * FROM articles<br>    -&gt;          WHERE MATCH (title,body) AGAINST (‘database’);<br>+—-+——————-+——————————————+<br>| id | title             | body                                     |<br>+—-+——————-+——————————————+<br>|  5 | MySQL vs. YourSQL | In the following database comparison … |<br>|  1 | MySQL Tutorial    | DBMS stands for DataBase …             |<br>+—-+——————-+——————————————+<br>2 rows in set (0.00 sec)<br>函数 MATCH() 对照一个文本集(包含在一个 FULLTEXT 索引中的一个或多个列的列集)执行一个自然语言搜索一个字符串。搜索字符串做为 AGAINST() 的参数被给定。搜索以忽略字母大小写的方式执行。对于表中的每个记录行，MATCH() 返回一个相关性值。即，在搜索字符串与记录行在 MATCH() 列表中指定的列的文本之间的相似性尺度。</p>
<p>当 MATCH() 被使用在一个 WHERE 子句中时 (参看上面的例子)，返回的记录行被自动地以相关性从高到底的次序排序。相关性值是非负的浮点数字。零相关性意味着不相似。相关性的计算是基于：词在记录行中的数目、在行中唯一词的数目、在集中词的全部数目和包含一个特殊词的文档(记录行)的数目。</p>
<p>它也可以执行一个逻辑模式的搜索。这在下面的章节中被描述。</p>
<p>前面的例子是函数 MATCH() 使用上的一些基本说明。记录行以相似性递减的顺序返回。</p>
<p>下一个示例显示如何检索一个明确的相似性值。如果即没有 WHERE 也没有 ORDER BY 子句，返回行是不排序的。</p>
<p>mysql&gt; SELECT id,MATCH (title,body) AGAINST (‘Tutorial’) FROM articles;<br>+—-+—————————————–+<br>| id | MATCH (title,body) AGAINST (‘Tutorial’) |<br>+—-+—————————————–+<br>|  1 |                        0.64840710366884 |<br>|  2 |                                       0 |<br>|  3 |                        0.66266459031789 |<br>|  4 |                                       0 |<br>|  5 |                                       0 |<br>|  6 |                                       0 |<br>+—-+—————————————–+<br>6 rows in set (0.00 sec)<br>下面的示例更复杂一点。查询返回相似性并依然以相似度递减的次序返回记录行。为了完成这个结果，你应该指定 MATCH() 两次。这不会引起附加的开销，因为 MySQL 优化器会注意到两次同样的 MATCH() 调用，并只调用一次全文搜索代码。</p>
<p>mysql&gt; SELECT id, body, MATCH (title,body) AGAINST<br>    -&gt; (‘Security implications of running MySQL as root’) AS score<br>    -&gt; FROM articles WHERE MATCH (title,body) AGAINST<br>    -&gt; (‘Security implications of running MySQL as root’);<br>+—-+————————————-+—————–+<br>| id | body                                | score           |<br>+—-+————————————-+—————–+<br>|  4 | 1. Never run mysqld as root. 2. … | 1.5055546709332 |<br>|  6 | When configured properly, MySQL … |   1.31140957288 |<br>+—-+————————————-+—————–+<br>2 rows in set (0.00 sec)<br>MySQL 使用一个非常简单的剖析器来将文本分隔成词。一个“词”是由文字、数据、“’” 和 “_” 组成的任何字符序列。任何在 stopword 列表上出现的，或太短的(3 个字符或更少的)的 “word” 将被忽略。</p>
<p>在集和查询中的每个合适的词根据其在集与查询中的重要性衡量。这样，一个出现在多个文档中的词将有较低的权重(可能甚至有一个零权重)，因为在这个特定的 集中，它有较低的语义值。否则，如果词是较少的，它将得到一个较高的权重。然后，词的权重将被结合用于计算记录行的相似性。</p>
<p>这样一个技术工作可很好地工作与大的集(实际上，它会小心地与之谐调)。 对于非常小的表，词分类不足以充份地反应它们的语义值，有时这个模式可能产生奇怪的结果。</p>
<p>mysql&gt; SELECT * FROM articles WHERE MATCH (title,body) AGAINST (‘MySQL’);<br>Empty set (0.00 sec)<br>在上面的例子中，搜索词 MySQL 却没有得到任何结果，因为这个词在超过一半的记录行中出现。同样的，它被有效地处理为一个 stopword (即，一个零语义值的词)。这是最理想的行为 – 一个自然语言的查询不应该从一个 1GB 的表中返回每个次行(second row)。</p>
<p>匹配表中一半记录行的词很少可能找到相关文档。实际上，它可能会发现许多不相关的文档。我们都知道，当我们在互联网上通过搜索引擎试图搜索某些东西时，这会经常发生。因为这个原因，在这个特殊的数据集中，这样的行被设置一个低的语义值。</p>
<p>到 4.0.1 时，MySQL 也可以使用 IN BOOLEAN MODE 修饰语来执行一个逻辑全文搜索。</p>
<p>mysql&gt; SELECT * FROM articles WHERE MATCH (title,body)<br>    -&gt;     AGAINST (‘+MySQL -YourSQL’ IN BOOLEAN MODE);<br>+—-+——————————+————————————-+<br>| id | title                        | body                                |<br>+—-+——————————+————————————-+<br>|  1 | MySQL Tutorial               | DBMS stands for DataBase …        |<br>|  2 | How To Use MySQL Efficiently | After you went through a …        |<br>|  3 | Optimising MySQL             | In this tutorial we will show …   |<br>|  4 | 1001 MySQL Tricks            | 1. Never run mysqld as root. 2. … |<br>|  6 | MySQL Security               | When configured properly, MySQL … |<br>+—-+——————————+————————————-+<br>这个查询返回所有包含词 MySQL 的记录行(注意： 50% 的阈值没有使用)，但是它没有包含词 YourSQL。注意，一个逻辑模式的搜索不会自动地以相似值的降序排序记录行。你可以从上面的结果出看得出来，最高的相似值(包含 MySQL 两次的那个) 最列在最后，而不是第一位。一个逻辑全文搜索即使在没有一个 FULLTEXT 索引的情况下也可以工作，然而它 慢 些。</p>
<p>逻辑全文搜索支持下面的操作符：</p>
<p>+<br>一个领头的加号表示，该词必须出现在每个返回的记录行中。<br>-<br>一个领头的减号表示，该词必须不出现在每个返回的记录行中。</p>
<p>缺省的 (当既没有加号也没有负号被指定时)词是随意的，但是包含它的记录行将被排列地更高一点。这个模仿没有 IN BOOLEAN MODE 修饰词的 MATCH() … AGAINST() 的行为。<br>&lt; &gt;<br>这两个操作符用于改变一个词的相似性值的基值。&lt; 操作符减少基值，&gt; 操作符则增加它。参看下面的示例。<br>( )<br>圆括号用于对子表达式中的词分组。<br>~<br>一个领头的否定号的作用象一个否定操作符，引起行相似性的词的基值为负的。它对标记一个噪声词很有用。一个包含这样的词的记录将被排列得低一点，但是不会被完全的排除，因为这样可以使用 - 操作符。<br>*<br>一个星号是截断操作符。不想其它的操作符，它应该被追加到一个词后，不加在前面。<br>“<br>短语，被包围在双引号”中，只匹配包含这个短语(字面上的，就好像被键入的)的记录行。<br>这里是一些示例：</p>
<p>apple banana<br>找至少包含上面词中的一个的记录行<br>+apple +juice<br>… 两个词均在被包含<br>+apple macintosh<br>… 包含词 “apple”，但是如果同时包含 “macintosh”，它的排列将更高一些<br>+apple -macintosh<br>… 包含 “apple” 但不包含 “macintosh”<br>+apple +(&gt;pie &lt;strudel)<br>… 包含 “apple” 和 “pie”，或者包含的是 “apple” 和 “strudel” (以任何次序)，但是 “apple pie” 排列得比 “apple strudel” 要高一点<br>apple*<br>… 包含 “apple”，“apples”，“applesauce” 和 “applet”<br>“some words”<br>… 可以包含 “some words of wisdom”，但不是 “some noise words”<br>6.8.1 全文的限制</p>
<p>MATCH() 函数的所有参数必须是从来自于同一张表的列，同时必须是同一个FULLTEXT 索引中的一部分，除非 MATCH() 是 IN BOOLEAN MODE 的。<br>MATCH() 列列表必须确切地匹配表的某一 FULLTEXT 索引中定义的列列表，除非 MATCH() 是 IN BOOLEAN MODE 的。<br>AGAINST() 的参数必须是一个常量字符串。<br>6.8.2 微调 MySQL 全文搜索</p>
<p>不幸地，全文搜索仍然只有很少的用户可调参数，虽然增加一些在 TODO 上排列很高。如果你有一个 MySQL 源码发行(查看章节 2.3 安装一个 MySQL 源码发行)，你可以发挥对全文搜索的更多控制。</p>
<p>注意，全文搜索为最佳的搜索效果，被仔细地调整了。修改默认值的行为，在大多数情况下，只会使搜索结果更糟。不要修改 MySQL 的源代码，除非你知道你在做什么！</p>
<p>被索引的词的最小长度由 MySQL 变量 ft_min_word_len 指定。查看章节 4.5.6.4 SHOW VARIABLES。 将它改为你所希望的值，并重建你的 FULLTEXT 索引。 (这个变量只从 MySQL 4.0 开始被支持)<br>stopword 列表可以从 ft_stopword_file 变量指定的文件中读取。查看章节 4.5.6.4 SHOW VARIABLES。 在修改了 stopword 列表后，重建你的 FULLTEXT 索引。(这个变量只从 MySQL 4.0.10 开始被支持)<br>50% 阈值选择由所选择的特殊的衡量模式确定。为了禁止它，修改 `myisam/ftdefs.h’ 文件中下面的一行：</p>
<p>#define GWS_IN_USE GWS_PROB<br>改为：</p>
<p>#define GWS_IN_USE GWS_FREQ<br>然后重新编译 MySQL。在这种情况下，不需要重建索引。 注意：使用了这个，将严重地减少 MySQL 为 MATCH() 提供足够的相似性值的能力。如果你确实需要搜索这样的公共词，最好使用 IN BOOLEAN MODE 的搜索代替，它不遵守 50% 的阈值。<br>有时，搜索引擎维护员希望更改使用于逻辑全文搜索的操作符。这些由变量 ft_boolean_syntax 定义。 查看章节 4.5.6.4 SHOW VARIABLES。 然而，这个变量是只读的，它的值在 `myisam/ft_static.c’ 中被设置。<br>对于这些更改，要求你重建你的 FULLTEXT 索引，对于一个 MyISAM 表，最容易的重建索引文件的方式如下面的语句：</p>
<p>mysql&gt; REPAIR TABLE tbl_name QUICK;<br>6.8.3 全文搜索 TODO</p>
<p>使所有对 FULLTEXT 索引的操作更快<br>邻近(Proximity)操作符<br>对 “always-index words” 的支持。他们可以是用户希望视为一个词处理的任意字符串，例如 “C++”、”AS/400”、”TCP/IP”，等等<br>支持在 MERGE 表中的全文搜索<br>对多字节字符的支持<br>依照数据的语言建立 stopword 列表<br>Stemming (当然，依赖于数据的语言)<br>Generic user-suppliable UDF preparser.<br>使模式更加灵活 (通过为 CREATE/ALTER TABLE 中的 FULLTEXT 增加某些可调整参数)</p>

            </div>
          

    
      <footer class="post-footer">
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/public/2013/01/16/php中对共享内存，消息队列的操作/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">php中对共享内存，消息队列的操作</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/public/2013/01/06/MySQL索引类型一览 让MySQL高效运行起来/">
        <span class="next-text nav-default">MySQL索引类型一览 让MySQL高效运行起来</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2019
    <span class="footer-author">ningmo.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/public/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/public/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/public/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
